# 8.系统监控

在维护 Linux 系统时，您会发现自己想做的另一个常见任务是监视系统进程、内存和网络使用等情况。这有助于您衡量您正在利用多少容量。了解哪些资源可能不足，可以让您深入了解如何降低系统负载，或者应该增加哪些资源。在这一章中，我们将看看进行不同类型监控的工具。

## 顶端

每当系统或设备遇到性能问题时，首先要做的事情之一就是检查哪些程序正在运行以及它们使用了多少系统资源。简单的方法是安装在大多数 Linux 系统上的`top`。运行它将列出所有当前正在运行的进程。通过按下`z`并输入目标进程的进程 ID (PID ),您可以在不离开`top`的情况下快速终止一个进程。

如果你发现自己经常使用`top`，你可以考虑安装`htop`。htop 是`top`的增强版，具有改进的可视化界面，并显示了流程的完整路径。

如果你更喜欢使用像`top`这样的内置工具，或者你在一台不能安装`htop`的机器上，你实际上可以使用键盘命令的组合来获得看起来几乎和`htop`一样的东西，在某些方面甚至更好。

在顶部打开的情况下，按下`zxcVm1t0`(作为一个序列，而不是同时)，你将得到看起来如图 [8-1](#Fig1) 所示的东西。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig1_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig1_HTML.jpg)

图 8-1

运行后顶部`zxcVm1t0`

我们可以通过按`A`进入交替显示模式来更进一步；这将屏幕分成四个独立的字段组。一旦进入交替显示模式，您可以通过按下`g`在字段组之间切换，这将提示您输入字段编号。如果你在每个字段组之间切换并输入`zxcVm1t0`，你将得到一个整洁的多字段显示，如图 [8-2](#Fig2) 所示。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig2_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig2_HTML.jpg)

图 8-2

风格多样的多标签顶部

当然，你可能认为这看起来很棒，但是每次打开`top`都要运行很多步骤。要保存这些设置，您只需按下`W`即可。这将保存您在`top`中的当前配置，当您重新打开它时，它看起来会是一样的。

如果您想回到默认值，只需删除创建的配置文件；默认应该是`~/.toprc`。

## 类似 Top 的程序

有几个受`top`启发的程序，或者监控`top`中没有的系统的某些特定方面，或者以不同的布局提供相同的信息。在这一部分，我们将回顾一些名字和格式都来自`top`的流行节目。

### 快上来

这是一个非常类似于`top`的程序，与`top`相比，它默认提供了一个改进的图形界面，如图 [8-3](#Fig3) 所示。它不是默认安装在大多数发行版上的，但是可以通过许多包管理系统获得，比如 Debian/Ubuntu 上的`apt`。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig3_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig3_HTML.jpg)

图 8-3

htop 以默认设置运行

### 在顶上

这是一个类似于`top`的高级系统和过程监视器，但适用于长期运行的分析。它提供了将系统监控结果作为日志文件输出以供分析的能力。如图 [8-4](#Fig4) 所示，它有一个简单的循环，但提供了`top`或`htop`中没有的导出为日志的功能。

默认情况下，它没有预装在大多数发行版中，但是它在包括 Debian 和 RHEL 在内的软件包管理系统中广泛存在。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig4_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig4_HTML.jpg)

图 8-4

使用默认设置运行

默认情况下，`atop`中的日志文件将被保存到文件夹`/var/log/atop/`中。这些日志文件可以通过用如下所示的`-r`标志传递给`atop`来读取，除了用您想要打开的日志的文件名替换`atop_20200310`:

```
atop -r /var/log/atop/atop_20200310

```

### iftop

这是受`top`的启发，但专门监控网络使用，而不是 CPU 或内存使用。当给定一个网络接口时，它将侦听所有传入和传出的流量，并提供诸如起始端口和哪些外部服务器使用网络最多之类的信息。由于访问网络接口，使用`iftop`需要`sudo`权限。

默认情况下，它不会安装在大多数发行版上，但是可以广泛使用。我们将在本章后面的监控网络流量部分进一步研究这个程序。

### 恩通普

一个比`iftop`更高级的选择是`ntop`，它也监控网络流量。然而，与这里的其他程序不同，它是一个基于 GUI 的系统，可以通过浏览器访问。虽然这使得它不那么轻量级，但它确实提供了一些更高级的可视化，如图 [8-5](#Fig5) 所示。

不像到目前为止提到的其他程序，你不会在包管理器上找到带有标准名称的`ntop`。相反，你会发现它的名字是`ntopng`:

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig5_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig5_HTML.jpg)

图 8-5

ntop 中的应用程序页面

```
sudo apt-get install ntopng

```

一旦安装并启动，它将在端口 3000 上运行，并提供几个基于网络使用的统计和可视化管理页面。

### iotop

这是另一个受`top`启发的程序，它专注于文件系统的读写使用。线程按磁盘读取和磁盘写入使用的顺序列出。这个包在基于 Debian 和基于 RHEL 的系统上都广泛可用。像`iftop`使用`iotop`将需要`sudo`权限才能运行。`iotop`包含每个进程的基本信息，如用户和命令，以及磁盘写入和`IO>`(这是一个进程花费在 IO 上的时间百分比的度量)。`iotop`动作示例见图 [8-6](#Fig6) 。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig6_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig6_HTML.jpg)

图 8-6

io 以默认设置运行

### slabtop

这是一个用于监控内核 slab 缓存信息的顶级程序，如图 [8-7](#Fig7) 所示。它主要对那些需要担心内核级问题的人有好处。

像`iftop`和`iotop`一样，使用`slabtop`将需要`sudo`权限。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig7_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig7_HTML.jpg)

图 8-7

slabtop 以默认设置运行

## 查看流程的更多信息

像`top`和`atop`这样列出的程序对于查看过程来说是很棒的。也可以使用`ps`手动查询所有正在运行的任务，然后通过管道将它们传递给其他程序。当单独运行`ps`时，您将获得当前终端会话中运行的进程列表。该列表可能很小，仅包括`bash`和`ps`工艺本身，如图 [8-8](#Fig8) 所示。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig8_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig8_HTML.jpg)

图 8-8

在新的终端中运行 ps

但是，如果您的终端已经打开了一段时间，并且您已经对一些进程进行了后台处理，您可能会看到更多。我们可以手动创建一个后台流程，通过以下步骤进行演示:

1.  运行睡眠 500 秒，并在后台运行进程`sleep 500 &`。

2.  运行`ps`并观察新流程。

3.  从 sleep 命令中取出 PID，并使用 kill `kill 123`结束该过程。

4.  再次运行`ps`并观察差异。

这些步骤应该导致一个额外的过程，由`ps`返回`sleep`，如图 [8-9](#Fig9) 所示。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig9_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig9_HTML.jpg)

图 8-9

有后台进程的 ps

当然，大多数情况下，您会希望看到机器上运行的所有进程，而不仅仅是当前终端会话中的进程。要获得所有正在运行的进程，您可以运行`ps -e`或`ps -ef`，不同之处在于添加的`f`显示了更多细节。详细的`ps`视图如图 [8-10](#Fig10) 所示。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig10_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig10_HTML.jpg)

图 8-10

运行 ps -ef 查看系统范围的进程

虽然我们可以使用`grep`来按用户解析进程，但是`ps`提供了一些内置的标志来简化这一过程，例如，`ps -u philip`或者带有`ps --pid 123`的特定 PID。这两者都可以和`-e`一起使用来获得更多的细节。

## 终止一个进程

经常与`ps`结合使用的命令有`kill`和`killall`。运行`ps`时，我们看到有一列显示 PID，是进程 ID 的简称。如果一个进程运行不正常、挂起，或者我们只想结束它，一种方法是使用`kill`命令。只需将 PID 传递给它，例如，假设 PID 为 123:

```
kill 123

```

如果你想通过名字而不是 PID 来匹配进程，你可以使用`killall`，例如，如果 Firefox 被冻结，我们想强制退出:

```
killall firefox

```

另一个与`killall`非常相似的选项是`pkill`。`pkill`也可以通过名称匹配服务，但是会包含更多的匹配，不像`killall`如果使用`-i`进行模式匹配，它不需要精确匹配。例如，如果我们只是传入“Firef ”,我们仍然会杀死进程:

```
pkill -i Firef

```

同样风格的命令可以和`pgrep`一起使用，在不杀死进程的情况下找到进程。例如，如果我们在 Firefox 打开的情况下运行以下命令，我们将获得与该程序相关联的 PID 列表:

```
pgrep -i Firef

```

为了让前面的命令更有用一点，可以添加`-l`标志来获取每个进程的确切程序名，或者添加`-a`来获取更多信息。

## 用 pstree 可视化流程树

要记住的另一个概念是，流程存在于一个层次结构中，有些流程有父流程和子流程；这可以在图 [8-11](#Fig11) 中看到。例如，当您在终端中运行`ps`时，它是终端进程的子进程。如果我们运行`sleep 500`然后关闭终端，子进程`sleep 500`将随着父进程的终止而自动终止。然而，情况并非总是如此；在某些情况下，子进程将在父进程关闭后继续运行，并继承父进程的父进程。

我们的终端进程本身是另一个进程的子进程，可能`systemd`取决于您的 Linux 发行版。因此，如果一个进程在关闭终端后继续运行，在我们的例子中，新的父进程将是`systemd`。

可视化这种关系的一个很好的工具是`pstree`，它可以用来显示我们系统上运行的所有进程，就像`ps`一样，但是以可视化的方式显示进程之间的父/子关系。尝试用`-p`标志运行它，这将确保进程 ID 也被返回。它应该返回一个很长的进程列表，所有这些进程都源自左边 PID 为 1 的单个进程。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig11_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig11_HTML.jpg)

图 8-11

使用-p 标志运行 pstree 以显示进程 id

正如我们在终端中运行命令时提到的，它实际上是终端进程的一个子进程。要演示这一点，请运行以下命令:

```
sleep 500 &
pstree -p | grep -A 5 -B 5 pstree

```

这将在后台创建一个休眠进程，获取`pstree`，然后为`pstree`进程执行 greps，这样我们就可以找到当前的终端进程。`-A`旗代表比对手高出五行，`-B`代表比对手低五行。结果应该类似于图 [8-12](#Fig12) 所示。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig12_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig12_HTML.jpg)

图 8-12

点击 pstree 查看特定进程

注意以绿色突出显示的`pstree`流程及其下方的`sleep`流程。它们都源于 bash 过程，而 bash 过程本身又源于`gnome-terminal`。

## 处理好价值

当使用`top`时，你可能已经注意到标有“NI”的列。这指的是“好的”价值观，这是 Linux 中的一个关键概念。每个进程都有一个很好的值-20 到 19。数字越小，进程在调度中的优先级越高。一种思考方式是，好的进程(例如， *10 个好值*)在队列中等待，而不好的进程插在前面( *-20 个好值*)，真正好的进程( *19 个好值*)让其他进程插在队列的前面。当然，这是一种简化，因为 nice 值是相对于队列中其他值而言的。

如上所述，您可以在列`NI`下的`top`中查看流程的 nice 值。另一种方法是使用带有`-o`标志的`ps`，后跟您想要查看的列(*包括* `ni`，例如:

```
ps ax -o pid,ni,cmd

```

这将返回所有运行进程的进程 ID、nice 值和命令，如图 [8-13](#Fig13) 所示。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig13_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig13_HTML.jpg)

图 8-13

用 ps 获取命令、PID 和 nice 值

请注意，在启动过程中启动的几个命令(*我们可以知道，因为 PID 接近 1* )有一个很好的值-20，因为它们被认为是运行操作系统的关键。

您可能还会注意到一些标有`-`的进程(取决于您的操作系统)；这些是系统级的进程，由一组不同的优先级控制(它们总是先运行)。在大多数情况下，您不需要担心这些底层流程。

## 其他优先系统

如前所述，一些流程由不同的优先级集控制。我们在用户空间中主要关心的正常进程由`SCHED_OTHER`控制。

其他主调度器`SCHED_FIFO`和`SCHED_RR`用于需要在所有正常进程之前运行的实时进程。这两个调度器具有相同的优先级，但调度方式不同。FIFO 代表先进先出(如*先来先服务*，RR 代表循环法(*轮流，直到流程完成*)。

如果您不在内核级工作，您可能不需要处理这些调度程序。如果您想了解进程的实时和绝对优先级值，可以运行

```
ps -e -o class,rtprio,pri,nice,cmd

```

从输出中，您会发现几个进程比那些被列为`-20` nice 值的进程具有更高的绝对优先级；这些都是实时过程。

## 更改好的值

现在你知道了 nice，你是如何使用它的？您可以使用`renice`命令更改任何正在运行的进程的 nice 值。通常，更改好的值不是一项常见的任务。然而，没有什么理由让你想这么做。比方说，您已经创建了一个自定义脚本，它通过压缩旧的日志文件并将其发送到长期存储服务来清理旧的日志文件。您可能希望为这个过程赋予一个很高的 nice 值，这样使用服务器的用户总是比备份过程具有更高的优先级，备份过程没有截止日期或紧迫性。

让我们创建一个流程来使用:

```
sleep 500&

```

获取返回的进程 ID(在我们的示例中是的 *1234)并与`renice`一起使用:*

```
renice -n 19 1234

```

现在，如果我们使用`ps`检查 nice 值，我们应该看到该值已经更新。

```
ps -o ni 1234

```

## 僵尸进程

在下一节中，我们将编译一个 C 程序来探索僵尸进程的概念。这有点技术性，关于僵尸进程的知识并不重要。如果您觉得这一部分太专业，请随意跳过。

本节将要求您安装 C 编译器和这里使用的库。它们都可以在基于 Debian 的系统上的`build-essential`包中获得。

```
sudo apt-get install build-essential

```

在查看进程时，另一个值得理解的概念是僵尸。僵尸进程是一个已经退出的子进程，但是还没有被它的父进程清除。大多数程序在退出后会很快移除其子进程，所以僵尸进程相当罕见。尽管名字邪恶，僵尸进程是相当无害的，不会对你的机器性能产生负面影响。

为了演示，我们将创建一个 C 程序来制作我们自己的僵尸进程。

```
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

int main () {

  // Create variable with type of process identification
  pid_t child_pid;

  // Fork main process creating a child
  child_pid = fork ();

  // Both main script and forked child run the code below the fork point

  // Child process will have a PID of 0 within script
  if (child_pid > 0) {
    // Only parent process runs this section
    sleep (500);
  }
  else {
    // Only forked child runs this section, exiting immediately
    exit (0);
  }

  return 0;
}

```

写完前面的 C 程序，另存为`zombie.c`。接下来，您需要通过运行以下命令来编译它

```
cc zombie.c -o zombie

```

一旦你成功编译了`zombie`，我们就可以演示僵尸进程是什么样子的了。运行可执行文件并在后台运行:

```
./zombie &

```

接下来，我们将使用前面的一些命令来查看该过程。不带选项的第一次运行`ps`。您应该会看到父进程`zombie`和子进程的条目，后面跟有`<defunct>`，如图 [8-14](#Fig14) 所示；这表明该进程处于僵死状态。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig14_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig14_HTML.jpg)

图 8-14

创建僵尸进程

如果你要运行`top`，你也会在右上角看到一个僵尸进程正在运行的提示，如图 [8-15](#Fig15) 所示。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig15_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig15_HTML.jpg)

图 8-15

在顶部查看僵尸数量

如前所述，僵尸进程是相当无害的，并且从技术上讲已经不运行了。因此，运行`kill 7450`(基于图 [8-14](#Fig14) 中的进程 ID)将无效。杀死僵尸进程的唯一方法是杀死它的父进程。

```
kill 7449

```

当然，如果你想让这个程序继续运行，这是一个问题。我们的建议是让僵尸进程自己处理，因为它们通常不会引起问题。

## 检查可用磁盘空间

服务器或嵌入式设备的另一个常见问题是磁盘空间不足。我遇到过一些这样的情况，由于一个程序在几个月的时间里无法压缩或删除旧的日志文件，导致一个停止工作的设备没有足够的空间来写入数据。

检查可用磁盘空间最简单的方法是使用实用程序`df`，它是“空闲空间”的缩写。要找到您的可用磁盘空间，请运行命令

```
df -h

```

前面的命令将返回包含每个分区信息的分区列表。其中一个分区将是您的系统使用的主分区。您可以通过查看“挂载于”列并找到值为“/”的那个来找到它。

接下来，您需要查看该分区的“大小”和“使用%”。这将告诉你有多少磁盘空间，以及目前使用的百分比。

关于`df`返回的列的完整列表，参见表 [8-1](#Tab1) 。这个表还包括可以用`-i`标志启用的 inodes used 列和用`-T`标志启用的 type 列。

注意我们在前面的例子中使用了`-h`标志；这代表“人类可读”如果没有`-h`标志，`df`仍然可以工作，但是以 KB 为单位显示可用空间，而不是将大量空间转换为 MB 或 GB。建议使用`-h`,除非您有特定的原因需要 KB 中的所有值。

表 8-1

df 命令返回的信息

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

圆柱

 | 

描述

 |
| --- | --- |
| 文件系统 | 文件系统的名称 |
| 大小 | 分区的大小(默认情况下隐藏，用-h 显示) |
| 1K 块 | 以 1K 块为单位的系统大小(使用-h 时替换为大小) |
| 二手的 | 使用的空间量 |
| 有空的 | 可用空间量 |
| 使用% | 以百分比显示的已用空间量 |
| 安装在 | 分区的目录位置 |
| IUsed | 分区上使用的索引节点(默认情况下隐藏，使用-i 显示) |
| 类型 | 分区文件系统类型(默认情况下隐藏，用-T 显示) |

## 查找系统中最大的文件

如果您发现系统空间不足，您可能希望在系统中搜索大文件。这里有一个超过 100 米的例子:

```
sudo find / -xdev -type f -size +100M -exec ls -la {} \; \
  | sort -nk 5 \
  | tac

```

前面的命令假设您想要查看系统上的每个文件。如果您想只包含特定文件夹中的文件，您可以修改`find`命令的第一个参数，例如，假设我想只搜索用户 philip 的文件夹中的文件，那么我将使用

```
sudo find /home/username -xdev -type f \
  -size +100M -exec ls -la {} \; \
    | sort -nk 5 \
    | tac

```

如果您只想查找总容量超过 1gb 的文件和目录，您可以这样做

```
sudo du -ahx / | grep -E '\d*\.?\d*+G\s+'

```

Note

通过组合`-size`和`-printf`标志，也可以用`find`获取和打印尺寸；但是，find 只显示以 KB 为单位的大小，与 GB 相比很难阅读。详见`man find`。

## 监控设备网络使用

您可能想要检查的另一个统计数据是系统整体的网络使用情况，以及按进程或网络接口的细分情况。这在互联网接入受限或带宽昂贵的设备上非常有用，例如，通过 GSM SIM 卡连接的物联网设备甚至笔记本电脑。在这种情况下，使用过多数据的程序会非常昂贵。

即使您不在数据有限的系统上，查看哪些程序正在使用您的互联网连接也会很有用。如果你看到一些让你吃惊的事情，你可能想进一步调查。我用了几个不错的程序来进行网络监控，每个程序都略有不同。

### bmon–监控每个网络接口

使用 bmon，您可以监控每个接口(例如，Wi-Fi、以太网)。这在前面描述的 GSM SIM 卡情况下非常好。想象一下，你有一台同时支持 Wi-Fi 和 5G 的设备。你可能不介意 Wi-Fi 接口上的高网络使用率，但会希望确保 5G 使用保持在一定水平以下。

在这种情况下，您可以编写软件来检测正在使用的互联网接口，并根据连接类型减少或增加数据使用。`bmon`通过分解每个接口上传输的数据量，为您提供了一种确保这些措施切实有效的方法。

默认情况下不会安装，但大多数软件包管理器上都有。当在终端运行`bmon`打开时，你会看到如图 [8-16](#Fig16) 所示的界面。如果您的终端窗口没有最大化，底部的绿色/红色图形可能会被隐藏。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig16_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig16_HTML.jpg)

图 8-16

运行 bmon

### nethogs 按带宽使用列出程序

大多数时候，你不会对正在使用的接口感兴趣，而是想知道哪些程序使用了最多的带宽。为此安装并运行`nethogs`；你会看到如图 [8-17](#Fig17) 所示的界面。请记住，如果您关闭该程序，当您稍后打开它时，它将再次从头开始。为了清楚地了解一段时间内的使用情况，您需要打开`nethogs`并让它运行一段时间。几个小时甚至几天后再回来，您会更清楚哪些程序使用了最多的带宽。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig17_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig17_HTML.jpg)

图 8-17

运行网络猪

### iftop

另一个选择是`iftop`，这是顶级家族的另一个项目。`iftop`让我们可以根据流量大小来监控哪些外部 IP 地址的通信量最大，而不是通过接口或应用程序进行监控。

启动`iftop`时，需要指定网络接口。如果您不知道您的网络接口，您可以通过运行

```
ip a

```

您将得到一个包含大量细节的接口列表；接口是左边的键值。在我这里，Wi-Fi 接口叫做`wlp3s0`，如图 [8-18](#Fig18) 。你通常可以分辨出哪个接口是 Wi-Fi，因为它会包含一个“w”。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig18_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig18_HTML.jpg)

图 8-18

从`ip a`返回的 Wi-Fi 接口

一旦有了想要监控的接口，就用`-i`标志将其传递给`iftop`:

```
sudo iftop -i wlp3s0

```

这将产生一个外部 IP 地址列表以及正在上传和下载的数据量，如图 [8-19](#Fig19) 所示。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig19_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig19_HTML.jpg)

图 8-19

使用 iftop 监控 Wi-Fi

为了让事情变得更清楚，你可以按下`s`来隐藏左边的信号源(*因为它们大部分是本地信号源*)。然后按`p`显示始发端口。Port 比 source 有用得多，因为它让我们对原始程序有了更好的了解，并且如果我们想进一步研究某个连接，它还提供了一种更深入的方法。图 [8-20](#Fig20) 所示为用端口替换源的`iftop`界面。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig20_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig20_HTML.jpg)

图 8-20

在 iftop 中按传出端口查看流量

## 用于监控的其他程序

### -嘘-嘘

另一个可以用来长时间监控系统使用情况的程序是`sysstat`，类似于`atop`，但更全面。与其检查系统的当前状态，不如让`sysstat`在后台运行，然后阅读每日报告。它的工作原理是每 10 分钟运行一次 cron 作业并记录系统数据。

默认情况下它可能是可用的，但是如果不是，您可以使用

```
sudo apt-get install sysstat

```

首先打开`/etc/default/sysstat`,确保下面一行设置为真；默认情况下，在 Ubuntu 上，它将被设置为 false:

```
ENABLED="true"

```

然后用`systemctl`启用它:

```
sudo systemctl enable --now sysstat

```

完成这些简单的步骤后，您的系统将开始在`/var/log/sysstat`文件夹中保存系统数据。将为该月的每一天创建一个新文件，例如，如果您从 26 日开始，该文件将是`/var/log/sysstat/sa26`。您可以通过运行以下命令来查看当天的数据

```
sar

```

一旦它运行了一段时间，`sar`将返回如图 [8-21](#Fig21) 所示的内容。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig21_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig21_HTML.jpg)

图 8-21

运行 sar

如上所述，这些统计数据保存在`/var/log/sysstat`文件夹中。如果您想查看之前监控的一天，用`sar`指定要打开的文件:

```
sar -f /var/log/sysstat/sa27

```

请注意，一旦您使用`sysstat`超过一个月，这些文件将开始被覆盖。如果您想将日志保存更长时间，您必须手动备份它们。

### 平均负载

平均负载是指正在运行或等待运行的线程的平均数量。有许多方法可以获得这些信息，最简单的方法是运行

```
uptime

```

这将返回系统运行的时间、登录的用户以及三个不同的平均负载值。这三个不同的值是 1 分钟、5 分钟和 15 分钟的平均值。使用这三个值，您可以了解负载是增加还是减少。

如果你现在已经经常使用`top`，你可以在顶行找到相同的三个负载平均值。

重要的是要记住，无论计算机有多少个 CPU，平均负载都是由队列中的线程来衡量的。在单 CPU 机器上平均负载为 2 比在有两个 CPU 的机器上平均负载为 3 要高。想象一下，每个线程都是一个在杂货店等待付款的人，每个 CPU 都是一个收银员。在不知道店内收银员人数的情况下，知道有多少人在排队并不一定有用。

要考虑的一个更有用的统计数据是平均负载除以 CPU。如果平均负载除以 CPU 数量大于 1，这可能表明您的系统过载。考虑一下前面探讨的友善的概念。如果一个 nice 值为 19 的进程正在运行，但是平均负载总是高于可用的 CPU，它可能永远不会结束执行，因为它一直允许进入该行的新进程首先运行。

根据一个传闻，当麻省理工学院的 IBM 7094 在 1973 年被关闭时，他们发现了一个低优先级的进程，该进程在 1967 年就已经提交，并且还没有运行。这正是所描述的队列一直存在的情况，因为进程的优先级低，所以它一直排队等待，总是让新的高优先级任务先运行。这个问题通常被称为资源匮乏。

Note

如果您忘记了一台机器上有多少个 CPU，您可以使用`lscpu`来查找标题为“CPU(s)”的行

### 用户

在上一节中，我们看到`uptime`返回的第三个值实际上是登录的用户。如果你最终看到了一个你没有预料到的数字，你可以使用`who`或`w`获得更多关于当前登录用户的信息。如果你的系统有，`w`是首选，因为它是对`who`的重写，包含了更多的用户信息。简单地跑

```
w

```

您将获得用户列表以及他们正在使用的 TTY。如果用户使用多个 tty，它们会被多次列出。用户使用单个 TTY 的示例如图 [8-22](#Fig22) 所示。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig22_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig22_HTML.jpg)

图 8-22

使用 w 查看已登录的用户

图 [8-23](#Fig23) 显示了一个用户使用多 TTY ( *通过* `tmux` *，一个保持终端会话打开但后台*的程序)的例子。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig23_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig23_HTML.jpg)

图 8-23

在几个 tmux 会话打开的情况下运行 w

## 日志文件夹

在监控或调试系统时，您需要注意系统日志文件夹。最好的地方之一是`/var/log`，这是存放各种日志的系统文件夹。导航到文件夹并查看文件:

```
cd /var/log
ls

```

根据正在运行的服务和系统运行的时间，您应该会在这里看到几个不同的文件和文件夹。我的日志文件夹的内容如图 [8-24](#Fig24) 所示。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig24_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig24_HTML.jpg)

图 8-24

/var/log 中的内容示例

如果你在 Ubuntu 这样的 Debian 系统上，主日志文件将会是`/var/log/syslog`。如果你在 CentOS 这样的非 Debian 系统上，你应该寻找`/var/log/messages`。我们会打开它

```
less /var/log/syslog

```

你会看到来自不同程序的各种信息。

在大多数系统上负责写这些日志的程序是`rsyslogd`。可以通过编辑`/etc/rsyslog.conf`文件进行定制。

Note

除了 syslog，另一个检查日志的好方法是 systemd 的`journalctl`；参见第 [11](11.html) 章中的`Journalctl`部分。

### 其他 sysstat 实用程序

当您安装并启用`sysstat`时，您实际上获得了一整盒实用程序和二进制文件，它们以各种方式处理和显示系统数据。这些公用设施在表 [8-2](#Tab2) 中列出。

表 8-2

sysstat 实用程序列表

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

命令

 | 

描述

 |
| --- | --- |
| 特别行政区 | 收集数据并显示所有系统活动 |
| 南共体 | “系统活动数据收集器”在后台运行 |
| sa1 | 从 cron 运行并处理收集的数据 |
| sa2 | 创建每日摘要，从 cron 运行 |
| 萨夫 | 将 sar 报告导出为 CSV、JSON、XML 等格式。 |
| 监视磁盘状态 | 用于查看 I/O 用途 |
| 系统的工具 | 用于查看与流程相关的统计数据 |
| 你会的 | 按进程 ID 查看数据 |
| cifsiostat | 查看 CIFS ( *通用互联网文件系统*)统计信息；这是一个微软的文件系统，可以在 Linux 中通过 Samba 启用 |

### 显示虚拟内存状态

`vmstat`是一个较旧的系统监控工具，它返回与系统内存、进程、中断、分页和块 I/O 相关的系统信息。它没有安装在大多数系统上，但可以在大多数软件包管理器中找到。

它接受两个输入值；第一个是以秒为单位的采样周期，第二个是要采集多少样本。因此，如果我们使用输入 1 和 10 运行，如下所示:

```
vmstat 1 10

```

我们退回十排。第一行永远是开机以来的总结。然后我们得到 9 行，每一行在最后一行之后 1 秒打印，显示 1 秒样本的平均值。图 [8-25](#Fig25) 显示了运行`vmstat`10 个 1 秒周期的示例。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig25_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig25_HTML.jpg)

图 8-25

使用 vmstat 获取 9 秒长的样本

由于用来显示表的空间被压缩了，所以很难解释列值。表 [8-3](#Tab3) 列出了缩写形式及其含义。

表 8-3

vmstat 列列表

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

顺序

 | 

描述

 |
| --- | --- |
| r | 队列中等待 CPU 的线程 |
| b | I/O 上阻塞的线程 |
| swpd 的 | 使用的总交换空间(KB) |
| 自由的 | 总空闲内存 |
| 爱好者 | 用作缓冲区的内存 |
| 躲藏 | 用作缓存的内存 |
| 大音阶第七音 | 从磁盘换入的内存 |
| 因此 | 内存交换到磁盘 |
| 双性恋的 | 从块设备接收的块 |
| 呸 | 发送到块设备的块 |
| 在 | 每秒中断数 |
| 铯 | 每秒的上下文切换 |
| 我们 | 运行非内核代码花费的时间 |
| 叙利亚 | 运行内核代码花费的时间 |
| 编号 | 空闲时间 |
| 华盛顿 | 等待 I/O 花费的时间 |
| 标准时间 | 从虚拟机窃取的时间 |

### r–等待运行时的线程

正如我们在讨论平均负载时提到的，队列中的线程是等待在 CPU 上运行的进程。因此，该列基本上与平均负载相同。然而，返回的第一行将是启动机器后的平均值(如果已经安装了`vmstat`)。这给了你一个完整运行时间的平均值，这是用`top`或`uptime`无法得到的。

对于顶线以下的值，您将获得取样瞬间的值，而不是平均值。

### b–被 I/O 阻塞的线程

I/O 阻塞的线程是在等待进程读取或写入存储时被内核置于等待状态的线程。如果有大量线程被 I/O 阻塞，这可能表明存在与存储设备相关的问题，或者仅仅是大量使用 I/O 的进程正在运行。

### swpd–使用的总交换

交换指的是当实际 RAM 内存已满时，分配给充当 RAM 的磁盘空间。交换内存比普通 RAM 慢得多，会导致依赖该内存的程序运行缓慢。如果您经常使用交换内存，您的系统可能需要 ram，或者某个程序可能不必要地使用了过多的 RAM。

### 空闲–总空闲内存

这以 KB 为单位显示了系统中未使用的内存总量。这类似于运行`free`命令时显示的自由栏。这让你知道你有多接近使用你所有的内存。

### buff–缓冲区中使用的内存

这类似于缓存，但特定于文件元数据；有关更多详细信息，请参见下一节。

### 缓存–用作缓存的内存

有时内存会被用来缓存程序经常访问的数据。这加快了程序的速度，但是看起来你的可用内存比实际情况要少；如果您的系统已经运行了很长时间，这种情况经常发生。

如果`free`的值很低，而`cache`的值很高，那么您仍然不需要担心交换空间被使用，因为缓冲区中的内存可以被重新分配。然而，如果`cache` + `buff` + `free`加在一起接近 0，这是你的机器资源紧张的迹象。

### si–从磁盘换入的内存

如前所述，数据或元数据(*与缓冲区*一样)通常存储在内存中，以提高程序运行的速度。我们讨论了如果更多的内存最终被其他东西需要，如何释放这些内存。在其他情况下，缓存在内存中的数据可能会被其他数据换出。

通过交换，该数据实际上包含执行程序本身的方面，例如，由程序产生的仅在程序运行时存在的数据结构。这种交换就是`si`列所测量的。`si`是每秒从磁盘交换的内存。

交换的使用表明系统没有足够的内存可用于缓存，只能求助于使用磁盘空间。如果您有一致的或高交换率，这意味着您的系统没有足够的内存。

### 所以–内存从磁盘换出

顾名思义，这与内存交换密切相关。换入是将数据从磁盘加载回内存的过程，而换出是数据首次保存到磁盘的过程。

### bi-从块设备接收的块

这实际上是从磁盘存储设备中读取的数据量。默认情况下，块的大小为 512 字节。

### bo–发送到块设备的块

这是通过块设备保存到磁盘的块数。

### 输入-每秒中断次数

中断是需要立即处理的信号。例如，当按下键盘上的一个键时，就会产生一个需要处理的中断。同样，当连接到互联网的网卡产生输入信号时，就会产生一个中断。可以通过查看文件`/proc/interrupts`直接查看中断。

中断发生是系统操作的正常部分，但是如果中断高于正常，可能有硬件问题。下一步可能是查看`/proc/interrupts`,并找出是什么设备导致了高计数。

### cs–上下文切换

当 CPU 在一个进程和另一个进程之间切换而没有完成第一个进程时，就会发生上下文切换。上下文切换需要保存第一个进程的状态，以便稍后完成。存在与上下文切换相关联的成本，因为需要资源来保存第一个进程的状态并在稍后加载该状态。

如果您看到异常大量的上下文切换，这可能与某个严重使用多线程的特定程序有关。

### us——运行非内核代码花费的时间

如题，`us`是运行非内核代码的时间。我们前面提到的内核是类 Unix 系统的核心，它将物理硬件连接到用户级软件。所有“花费的时间”值都是以时间的百分比来度量的，因此值 2 表示在所度量的时间段内有 2%的时间花费在非内核代码上。

### sy——运行内核代码花费的时间

这是运行内核代码所用时间的百分比；一个简单的方法是，花费在用户级别之外的系统进程上的时间。花费在系统进程上的时间值异常高可能表示硬件问题、内存瓶颈或内核级锁定问题。

### id–空闲时间

这是空闲时间的百分比。这用于与`us`和`sy`进行比较。请注意，添加`us`、`sy`、`id`和`wa` ( *，我们将在下一个*中查看)后的总和应该在 100%左右(由于四舍五入，可能会略有出入)。如果你在测试`vmstat`时没有在后台运行很多程序，很可能大部分时间都是空闲的。较低的空闲时间表示您的系统正在进行大量处理。

### wa—等待 I/O 花费的时间

第四类“花费在`vmstat`上的时间”是花费在等待 I/O 上的时间百分比。在关于`b`的章节中，我们提到了线程在等待写入磁盘或从磁盘读取时如何被阻塞。`wa`为我们提供了一个衡量等待 I/O 时损失了多少 CPU 时间的指标。等待 I/O 的时间百分比高可能表明我们的磁盘存储很慢，或者我们只是在对磁盘进行大量的读写操作。如果您发现等待 I/O 似乎占用了您系统的大量时间，您可以通过用具有更高读/写速度的磁盘存储升级底层硬件来降低这一百分比。

如果您想模拟一个导致大量磁盘读写的进程来观察`vmstat`中的效果，您可以运行以下代码片段:

```
 (cd /tmp &&
  (sync ; vmstat 1 & PID1=$! ; \
  cat </dev/zero >test & PID2=$! ; \
  sleep 3 ; kill $PID2 ; sync ; kill $PID1))

```

这个代码片段移动到`/tmp`目录，启动`vmstat`，然后开始从`/dev/zero`读取零，并将它们写入`/tmp/test`。PID1 和 PID2 包含两个正在运行的进程的进程 ID，并在休眠 3 秒后杀死它们。当运行这个命令时，您应该看到`wa`值上升到一些高值。

### ST-从虚拟机窃取的时间

顾名思义，`st`值表示运行在您系统上的虚拟机等待访问分配给它的资源所花费的时间。这仅在您的系统运行虚拟机时才相关。值持续大于 0 可能表明您为虚拟机分配了过多的内存，这意味着您的主系统不得不从它们那里窃取时间，或者您根本没有足够的内存来运行您托管的虚拟机和主系统。

### 工具

“`nmon`”系统监控工具可以显示 CPU、内存、网络、磁盘(迷你图或数字)、文件系统、NFS、顶级进程、资源(Linux 版本和处理器)和电源微分区信息。`nmon`的独特之处在于，它允许您在这些不同的统计数据之间混合和匹配，以创建您自己的定制显示屏。`nmon`不是默认安装的，但是在大多数软件包管理器上都可以找到`nmon`。

当你第一次通过运行不带选项的命令打开`nmon`时，你会看到一个类似于图 [8-26](#Fig26) 的开始屏幕。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig26_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig26_HTML.jpg)

图 8-26

运行 nmon

在这里，您可以按底部列出的任何按钮来打开特定的统计数据。比如我们按`n`，屏幕会显示网络信息；如果我们按下`c`，我们将会看到网络和 CPU 信息，如图 [8-27](#Fig27) 所示。

![../images/494886_1_En_8_Chapter/494886_1_En_8_Fig27_HTML.jpg](../images/494886_1_En_8_Chapter/494886_1_En_8_Fig27_HTML.jpg)

图 8-27

在 nmon 中查看 CPU 和网络信息

你一次可以查看多少不同的统计数据的唯一限制是你的屏幕大小。任何时候，您都可以通过按下用于激活某个部分的按钮来删除该部分。

## 使用 Snort 进行高级网络监控

另一个值得一提的监控系统是 Snort，这是一个开源的网络入侵预防和检测系统。Snort 的工作原理是实时分析网络流量，并根据一组定义的规则进行检查。常见的规则集包括

*   对照黑名单检查 IP 地址

*   检查来自 IP 的异常请求量

*   检查请求的内容

*   特定于 FTP、SSH 或 https 等特定服务的规则

*   任何自定义规则

Snort 还允许系统管理员连接规则来触发操作，例如向系统管理员发送通知或阻止来自违规 IP 的请求。Snort 是完全开源的，有几个社区维护的规则集，也有定期更新的高级规则集，并作为付费服务提供。

我们不会详细讨论如何安装或设置`snort`,尽管它可以从大多数软件包管理器中获得。设置过程相当长，超出了本书的范围，但是如果用例适用于您的设置，这是值得研究的。

## 纳吉奥斯

另一个开源的全套网络监控系统是 Nagios，它配有基于 web 的 GUI。它可用于监控多台机器和基础设施上的资源，其特性包括

*   基于潜在问题的警报

*   监控你的网站，记录任何停机时间

*   捕获端口使用( *http，SMTP，SNMP，FTP，SSH，POP 等。*)

*   网络请求的大量日志

与 Snort 一样，Nagios 服务器对于那些运行大中型基础设施来提供基于 web 的服务的人来说更有用。

## 摘要

在这一章中，我们看了可以用来监控 Linux 系统的各种程序和命令，从使用`top`或`atop`的基本进程监控到更具体的监控程序，如`nethogs`和`iftop`。