第二章

![image](img/image00264.jpeg)

输入、输出和吞吐量

我们在第 1 章的[中使用的两个命令是 shell 脚本程序的核心:`echo`和`printf`。两者都是`bash`内置的*命令。两者都以*标准输出*流打印信息，但是`printf`要强大得多，而`echo`也有它的问题。*](01.html)

在这一章中，我将介绍`echo`及其问题、`printf`的功能、`read`命令以及标准的输入和输出流。然而，我将从参数和变量的概述开始。

参数和变量

引用`bash`手册(在命令提示符下键入`man bash`以阅读它)，“参数是存储值的实体。”有三种类型的参数:位置参数、特殊参数和变量。*位置参数*是命令行上出现的参数，它们由一个数字引用。*特殊参数*由 shell 设置，用于存储关于其当前状态的信息，例如参数的数量和最后一个命令的退出代码。它们的名字是非字母数字字符(例如，`*`、`#`和`_`)。*变量*由一个*名称*标识。名称又能代表什么呢我将在“变量”部分解释这一点。

通过在参数名称、数字或字符前加上美元符号来访问参数值，如`$3`、`$#`或`$HOME`。这个名字可以用大括号括起来，如`${10}`、`${PWD}`或`${USER}`。

位置参数

命令行上的参数可以作为编号参数供 shell 程序使用。第一个参数是`$1`，第二个是`$2`，以此类推。

您可以通过使用位置参数使《T2》第 1 章中的`hw`脚本更加灵活。[清单 2-1](#list1) 称之为`hello`。

[***清单 2-1***](#_list1) 。`hello`

```sh
#: Description: print Hello and the first command-line argument
printf "Hello, %s!\n" "$1"
```

现在，您可以调用带有参数的脚本来更改其输出:

```sh
$ hello John
Hello, John!
$ hello Susan
Hello, Susan!
```

Bourne shell 最多只能处理九个位置参数。如果一个脚本使用了`$10`，它将被解释为`$1`后跟一个零。为了能够运行旧的脚本，`bash`保持这种行为。要访问大于`9`的位置参数，数字必须用大括号括起来:`${15}`。

脚本被传递给参数，这些参数可以通过它们的位置、$0、$1、$2 等等来访问。函数`shift N`将位置参数移动`N`个位置，如果运行`shift`(`N`的默认值为 1)，那么`$0`将被丢弃，`$1`将变成`$0` , `$2`将变成`$1`，以此类推:它们都将被移动 1 个位置。shift 有一些非常聪明和简单的用法来遍历未知长度的参数列表。

![Image](img/image00265.jpeg) **注**移位功能是破坏性的:即被丢弃的参数不见了，不能再取回。

特殊 **@#0$？_!-* 参数

前两个特殊参数`$*`和`$@`扩展为所有位置参数的组合值。`$#`扩展到位置参数的个数。`$0`包含当前运行脚本的路径，如果没有脚本正在执行，则包含 shell 本身的路径。

`$$`包含当前进程的进程标识号(PID)，`$?`被设置为最后执行的命令的退出代码，`$_`被设置为该命令的最后一个参数。`$!`包含后台执行的最后一个命令的 PID，`$-`设置为当前有效的选项标志。

我将在编写脚本的过程中更详细地讨论这些参数。

变量

*变量*是用名称表示的参数；*名称*是一个只包含字母、数字或下划线，并以字母或下划线开头的单词。

可以按以下形式将值赋给变量:

```sh
name=VALUE
```

![Image](img/image00265.jpeg) **注意** Bash 对间距非常讲究:注意=前面没有空格，后面也没有。如果有空格，该命令将不起作用。

许多变量是由 shell 自己设置的，包括您已经看到的三个:`HOME`、`PWD`和`PATH`。除了两个小的例外，`auto_resume`和`histchars`，shell 设置的所有变量都是大写字母。

参数和选项

在命令后输入的单词是它的*参数*。这些单词由空格分隔(一个或多个空格或制表符)。如果空格被转义或引用，它不再分隔单词，而是成为单词的一部分。

以下命令行都有四个参数:

```sh
echo 1 '2   3'   4 5
echo  -n  Now\ is  the  time
printf "%s %s\n" one two three
```

在第一行中，`2`和`3`之间的空格被*引用了*，因为它们被单引号包围了。在第二个例子中，`now`后面的空格用反斜杠进行转义，这是 shell 的转义字符。

在最后一行，空格用双引号引起来。

在第二个命令中，第一个参数是一个选项。传统上，Unix 命令的选项是前面带连字符的单个字母，有时后面跟一个参数。Linux 发行版中的 GNU 命令通常也接受*长选项*。这些单词前面有一个双连字符。例如，大多数 GNU 实用程序都有一个名为`--version`的选项来打印版本:

```sh
$ bash --version
GNU bash, version 4.3.11(1)-release (x86_64-unknown-linux-gnu)

Copyright (C) 2013 Free Software Foundation, Inc.

License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>

This is free software; you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
```

回声，以及为什么你应该避免它

当我开始编写 shell 脚本时，我很快就了解了 Unix 的两个主要分支:美国电话电报公司的 System V 和 BSD 。他们的不同之处之一是`echo`的行为。所有现代 shells 中的一个内部命令，`echo`将其参数打印到标准输出流中，参数之间有一个空格，后跟一个换行符:

```sh
$ echo The quick brown fox
The quick brown fox
```

根据 shell 的不同，默认换行符可以通过以下两种方式取消:

```sh
$ echo -n No newline
No newline$ echo "No newline\c"
No newline$
```

`echo`的 BSD 变体接受了*选项* `-n`，抑制了换行符。T 的版本使用了一个*转义序列*、`\c`来做同样的事情。还是反过来了？我很难记住哪个是哪个，因为尽管我使用的是 AT & T 系统(硬件*和*操作系统)，它的`echo`命令接受 AT & T 和 BSD 语法。

当然，这是历史。在这本书里，我们要讨论的是`bash`，那么这有什么关系呢？`bash`有`-e`选项来激活转义序列，比如`\c`，但是默认情况下使用`-n`来防止换行被打印。(除了`\c`之外，`echo -e`识别的转义序列与下一节描述的相同)。

![Image](img/image00265.jpeg) **提示**如果您想让转义序列被识别，请在 echo 命令中添加–e。

问题是,`bash`有一个`xpg_echo`选项(XPG 代表 X/Open Portability Guide，Unix 系统的一个规范),使得`echo`的行为像另一个版本。这可以在 shell 中打开或关闭(在命令行或脚本中使用`shopt -s xpg_echo`)，也可以在编译 shell 时打开。换句话说，即使在`bash`中，你也不能绝对确定你会得到什么样的行为。

如果您将`echo`的使用限制在不存在冲突的情况下，也就是说，您确定参数不是以`-n`开始并且不包含转义序列，那么您将会相当安全。对于其他一切(或者如果你不确定)，使用`printf`。

printf :格式化和打印数据

shell 命令`printf`源自 C 编程语言的同名函数，目的相似，但在一些细节上有所不同。像 C 函数一样，它使用一个格式字符串来指示如何表示其余的参数:

```sh
printf FORMAT ARG ...
```

`FORMAT`字符串可以包含普通字符、转义序列和格式说明符。普通字符按标准输出原样打印。转义序列被转换成它们所代表的字符。格式说明符被替换为命令行中的参数。

转义序列

转义序列是以反斜杠开头的单个字母:

*   `\a`::警报(铃声)
*   `\b`:退格
*   `\e`:转义字符
*   `\f`:表格进给
*   `\n`:换行符
*   `\r`:回车
*   `\t`:水平标签
*   `\v`:垂直制表符
*   `\\`:反斜杠
*   `\nnn`:由一至三个八进制数字指定的字符
*   `\xHH`:由一个或两个十六进制数字指定的字符

必须用引号或另一个反斜杠来保护反斜杠不受 shell 的影响:

```sh
$  printf "Q\t\141\n\x42\n"
Q       a
B
```

格式规范

格式说明符是以百分号开头的字母。可选的修饰语可以放在两个字符之间。说明符被相应的参数替换。当参数多于说明符时，格式字符串将被重用，直到所有的参数都用完为止。最常用的说明符有`%s``%d``%f`和`%x`。

`%s`说明符打印参数中的文字字符:

```sh
$ printf "%s\n" Print arguments on "separate lines"
Print
arguments
on
separate lines
```

除了参数中的转义序列被转换之外，`%b`与`%s`相似:

```sh
$ printf "%b\n" "Hello\nworld" "12\tword"
Hello
world
12      word
```

整数打印有`%d` 。该整数可以指定为十进制、八进制(使用前导 0)或十六进制(在十六进制数前面加上`0x`)数。如果该数字不是有效的整数，`printf`会打印一条错误消息:

```sh
$ printf "%d\n" 23 45 56.78 0xff 011
23
45
bash: printf: 56.78: invalid number
0
255
9
```

对于小数或浮点数，使用`%f` 。默认情况下，它们将以六位小数打印:

```sh
$ printf "%f\n" 12.34 23 56.789 1.2345678
12.340000
23.000000
56.789000
1.234568
```

浮点数可以使用`%e` 以指数(也称为*科学*符号)表示:

```sh
$ printf "%e\n" 12.34 23 56.789 123.45678
1.234000e+01
2.300000e+01
5.678900e+01
1.234568e+02
```

整数可以用十六进制打印，小写字母用`%x`表示，大写字母用`%X`表示。例如，当指定网页的颜色时，它们是用十六进制表示法指定的。我从 X Window 系统包含的`rgb.txt`文件中知道，皇家蓝的红绿蓝值分别是 65、105 和 225。要将它们转换为网页的样式规则，请使用:

```sh
$ printf "color: #%02x%02x%02x;\n" 65 105 225
color: #4169e1;
```

宽度规格

您可以通过在百分号后加上宽度规格来修改格式。参数将在该宽度的字段中右对齐打印，如果数字为负数，则左对齐打印。这里我们有宽度为 8 个字符的第一个字段；这些字将被打印在右边。然后是一个 15 个字符宽的字段，它将左对齐打印:

```sh
$ printf "%8s %-15s:\n" first second third fourth fifth sixth
   first second         :
   third fourth         :
   fifth sixth          :
```

如果宽度规格以 0 开头，则数字以前导零填充，以填充宽度:

```sh
$ printf "%04d\n" 12 23 56 123 255
0012
0023
0056
0123
0255
```

带小数的宽度说明符指定浮点数的精度或字符串的最大宽度:

```sh
$  printf "%12.4s %9.2f\n" John 2 Jackson 4.579 Walter 2.9
        John      2.00
        Jack      4.58
        Walt      2.90

```

中显示的脚本。[清单 2-2](#list2) 使用`printf`输出一个简单的销售报告。

[***清单 2-2***](#_list2) 。报告

```sh
#!/bin/bash
#: Description : print formatted sales report

## Build a long string of equals signs
divider=====================================
divider=$divider$divider

## Format strings for printf
header="\n %-10s %11s %8s %10s\n"
format=" %-10s %11.2f %8d %10.2f\n"

## Width of divider
totalwidth=44

## Print categories
printf "$header" ITEM  "PER UNIT" NUM TOTAL

## Print divider to match width of report
printf "%$totalwidth.${totalwidth}s\n" "$divider"

## Print lines of report
printf "$format" \
    Chair 79.95 4 319.8 \
   Table  209.99 1 209.99 \
   Armchair 315.49 2 630.98
```

生成的报告如下所示:

```sh
 ITEM          PER UNIT      NUM      TOTAL
============================================
 Chair            79.95        4     319.80
 Table           209.99        1     209.99
 Armchair        315.49        2     630.98
```

注意在第二个`totalwidth`变量名:`${totalwidth}`周围使用了大括号。在第一个实例中，名称后面跟一个句点，句点不能是变量名的一部分。在第二个中，它后面跟有字母`s`，可能是，所以`totalwidth`名称必须用大括号与它分开。

打印到变量

在 3.1 版本中，`bash`增加了一个`-v`选项，将输出存储在一个变量中，而不是打印到标准输出:

```sh
$ printf -v num4 "%04d" 4
$ printf "%s\n" "$num4"
0004
```

行延续

在`report`脚本的结尾，使用*行继续符*，最后四行作为一行读取。行尾的反斜杠告诉 shell 忽略换行符，有效地将下一行连接到当前行。

标准输入/输出流和重定向

在 Unix 中(Linux 是其中的一个变种)，一切都是字节流。这些流可以作为文件访问，但是有三个流很少通过文件名访问。这些是附加到每个命令的输入/输出(I/O)流:标准输入、标准输出和标准错误。默认情况下，这些流连接到您的终端。

当一个命令读取一个字符或一行时，它从标准输入流中读取，标准输入流就是键盘。当它打印信息时，它被发送到标准输出，你的显示器。第三个流，标准误差，也连接到您的监视器；顾名思义，它用于错误消息。这些流用数字来指代，称为*文件* *描述符* (FDs )。它们分别是 0、1 和 2。流名也常常缩写为 *stdin* 、 *stdout* 和 *stderr* 。

I/O 流可以重定向到(或来自)一个文件或一个*管道。*

重定向 : >、>、T3、<

在第 1 章中，您使用`>`重定向操作符将标准输出重定向到一个文件。

使用`>`重定向时，如果文件不存在，则创建该文件。如果它确实存在，在向它发送任何内容之前，该文件会被截断为零长度。您可以通过将空字符串(即空字符串)重定向到文件来创建空文件:

```sh
printf "" > FILENAME
```

或者简单地用这个:

```sh
> FILENAME
```

重定向是在执行该行上的任何命令之前执行的。如果您重定向到您正在读取的同一个文件，该文件将被截断，并且该命令将没有可读取的内容。

`>>`操作符不会截断目标文件；它附加到它上面。通过执行以下操作，您可以在第一章的`hw`命令中添加一行:

```sh
echo exit 0 >> bin/hw
```

重定向标准输出不会重定向标准错误。错误信息仍会显示在您的显示器上。要将错误消息发送到一个文件，换句话说，要重定向 FD2，重定向操作符前面要有 FD。

标准输出和标准错误都可以重定向到同一行。下一个命令向`FILE`发送标准输出，向`ERRORFILE`发送标准误差:

```sh
$ printf '%s\n%v\n' OK? Oops! > FILE 2> ERRORFILE
$ cat ERRORFILE
bash4: printf: `v': invalid format character
```

在这种情况下，错误消息将被保存到一个特殊的文件`/dev/null`。有时称为*比特桶* ，任何写入其中的东西都被丢弃。

```sh
printf '%s\n%v\n' OK? Oops! 2>/dev/null
```

可以使用`>&N`将输出重定向到另一个 I/O 流，而不是将输出发送到文件，其中`N`是文件描述符的编号。该命令将标准输出和标准误差发送到`FILE`:

```sh
printf '%s\n%v\n' OK? Oops! > FILE 2>&1
```

在这里，顺序很重要。标准输出被发送到`FILE`，然后标准错误被重定向到标准输出要去的地方。如果顺序反过来，效果就不一样了。重定向将标准错误发送到标准输出当前所在的位置，然后更改标准输出所在的位置。标准误差仍然指向标准输出最初指向的地方:

```sh
printf '%s\n%v\n' OK? Oops! 2>&1 > FILE
```

`bash`还有一个非标准语法，用于将标准输出和标准错误重定向到同一个位置:

```sh
&> FILE
```

要将标准输出和标准误差附加到`FILE`，使用以下命令:

```sh
&>> FILE
```

从标准输入读取的命令可以将其输入从文件重定向:

```sh
tr, H wY < bin/hw
```

您可以使用`exec`命令为脚本的其余部分重定向 I/O 流，或者直到它再次被更改。

```sh
exec 1>tempfile
exec 0<datafile
exec 2>errorrfile
```

所有标准输出现在都将转到文件`tempfile` ，输入将从`datafile` 中读取，错误信息将转到`errorfile` ，而无需为每个命令指定。

阅读输入

`read`命令是一个从标准输入读取的内置命令。默认情况下，它会一直读取，直到收到一个换行符。输入存储在一个或多个作为参数给出的变量中:

```sh
read var
```

如果给定了多个变量，则第一个单词(直到第一个空格或制表符的输入)被分配给第一个变量，第二个单词被分配给第二个变量，依此类推，剩余的单词被分配给最后一个变量:

```sh
$ read a b c d
January February March April May June July August
$ echo $a
January
$ echo $b
February
$ echo $c
March
$ echo $d
April May June July August
```

`read`的`bash`版本有几个选项。POSIX 标准只认可`-r`选项。它告诉 shell 逐字解释转义序列。

默认情况下，`read`从输入中去掉反斜杠，后面的字符按字面理解。这种默认行为的主要效果是允许行的延续。使用`-r`选项，一个反斜杠后跟一个换行符被读为一个字面反斜杠和输入的结束。

我将在第 15 章中讨论其他选项。

像任何其他读取标准输入的命令一样，`read`可以通过重定向从文件中获取输入。例如，要从`FILENAME`中读取第一行，请使用以下命令:

```sh
read var < FILENAME
```

管道

*管道*将一个命令的标准输出直接连接到另一个命令的标准输入。管道符号(`|`)用于命令之间:

```sh
$ printf "%s\n" "$RANDOM" "$RANDOM" "$RANDOM" "$RANDOM" | tee FILENAME
618
11267
5890
8930
```

`tee`命令读取标准输入，并将其传递给一个或多个文件以及标准输出。`$RANDOM` 是一个`bash`变量，每次被引用时返回 0 到 32，767 之间的不同整数。

```sh
$ cat FILENAME
618
11267
5890
8930
```

命令替换

使用*命令替换*可以将命令的输出存储在变量中。有两种形式可以做到这一点。第一个源自《谍影重重》,使用了反斜杠:

```sh
date=`date`
```

较新的(也是推荐的)语法如下:

```sh
date=$( date )
```

命令替换通常应该保留给外部命令。当与内置命令一起使用时，它非常慢。这就是为什么`printf`中增加了`-v`选项。

摘要

以下是您在本章中学到的命令和概念。

命令

*   `cat`:将一个或多个文件的内容打印到标准输出
*   `tee`:将标准输入复制到标准输出以及一个或多个文件中
*   `read`:从标准输入中读取一行的内置 shell 命令
*   `date`:打印当前日期和时间

概念

*   *标准 I/O 流*:这些是字节流，命令从这些字节流中读取，输出发送到这些字节流。
*   *自变量*:这些是跟随命令的字；参数可能包括选项以及其他信息，如文件名。
*   *参数*:这些是存储值的实体；这三种类型是位置参数、特殊参数和变量。
*   *管道*:管道是由`|`分隔的一个或多个命令的序列；管道符号之前的命令的标准输出被提供给其后的命令的标准输入。
*   *行继续符*:这是一行末尾的反斜杠，用于移除新行并将该行与下一行合并。
*   *命令替换*:这意味着将命令的输出存储在变量中或命令行上。

练习

1.  这个命令有什么问题？

    ```sh
    tr A Z < $HOME/temp > $HOME/temp
    ```

2.  使用`$RANDOM`编写一个脚本，将以下输出写入文件和变量。以下数字仅用于显示格式；你的脚本应该产生不同的数字:

    ```sh
     1988.2365
    13798.14178
    10081.134
     3816.15098
    ```