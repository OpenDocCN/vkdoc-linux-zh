# 13.OpenMAX 日期

OpenMAX 是 Khronos Group 为低性能设备设计的音频和视频开放标准。卡的供应商被期望生产实现。一般的 Linux 实现方式很少，但是 Broadcom 已经实现了其中一个规范(OpenMAX IL)，它的芯片被用于 Raspberry Pi。其他 Khronos 规范(OpenMAX AL 和 OpenSL ES)已经在 Android 设备中实现，可通过原生开发套件(NDK)访问，但这些并不打算直接使用；它们只能通过 Java APIs 使用。本书不讨论它们。本章仅讨论 OpenMAX IL。

## 资源

以下是一些资源:

*   来自 eLinux 的 OpenMAX 集成层(IL)标准( [`http://elinux.org/images/e/e0/The_OpenMAX_Integration_Layer_standard.pdf`](http://elinux.org/images/e/e0/The_OpenMAX_Integration_Layer_standard.pdf) )。
*   Khronos 主页( [`www.khronos.org/`](http://www.khronos.org/) )给出了免费下载的规范；它们做得很好，可读性很强。
*   LIM OpenMAX 实现( [`http://limoa.sourceforge.net/`](http://limoa.sourceforge.net/) )是一个 Linux 实现。从`lim-omx-1.0.tar.gz` ( [`http://sourceforge.net/projects/limoa/files/1.0/lim-omx-1.0.tar.gz/download`](http://sourceforge.net/projects/limoa/files/1.0/lim-omx-1.0.tar.gz/download) )下载 1.0 就可以了。
*   OpenMAX IL Bellagio 包( [`http://omxil.sourceforge.net/`](http://omxil.sourceforge.net/) )源码，DEB 包，RPM 都有。
*   德州仪器 OpenMax 开发指南( [`http://processors.wiki.ti.com/index.php/OpenMax_Development_Guide`](http://processors.wiki.ti.com/index.php/OpenMax_Development_Guide) )。
*   OpenMAX(开放媒体加速)( [`www.cnx-software.com/2011/11/11/openmax-open-media-acceleration/`](http://www.cnx-software.com/2011/11/11/openmax-open-media-acceleration/) )。

## 引用

以下是一些引述:

*   根据 jamesh 的说法，“使用 OpenMAX 完全是一场噩梦……”([`www.raspberrypi.org/forums/viewtopic.php?t=5621`](http://www.raspberrypi.org/forums/viewtopic.php?t=5621))。
*   根据 dom ( [`www.raspberrypi.org/forums/memberlist.php?mode=viewprofile&u=754`](http://www.raspberrypi.org/forums/memberlist.php?mode=viewprofile&u=754) )，“我已经写了相当多的[OpenMAX ]客户端代码，发现很难。在你得到任何有用的东西之前，你必须得到很多正确的东西。如果你幸运的话，会有很多 OMX 错误无效状态和 OMX 错误错误参数的消息。如果你不在的话，什么也不会发生。”
*   根据 Twinkletoes ( [`www.raspberrypi.org/forums/viewtopic.php?t=6577`](http://www.raspberrypi.org/forums/viewtopic.php?t=6577) )，“我来自 DirectShow 背景，我认为那是很糟糕的记录……然后我遇到了[OpenMAX ]。很多 PPT 都在谈论它，但我找不到任何文档或代码示例。”

## OpenMAX 概念

OpenMAX IL API 与 OpenMAX AL 的 API 截然不同。基本概念是组件，即某种类型的音频/视频(或其他)处理单元，如音量控制、混音器或输出设备。每个组件有零个或多个输入和输出端口，每个端口可以有一个或多个携带数据的缓冲器。

OpenMAX IL 通常由某种 A/V 框架使用，如 OpenMAX AL。除了 OpenMAX AL，目前还有一个 GStreamer 插件在底层使用 OpenMAX IL。但是也可以构建独立的应用程序，直接调用 OpenMAX IL API。总的来说，这些都被称为 IL 客户端。

OpenMAX IL API 很难直接使用。错误消息经常是无用的，线程会毫无解释地阻塞，直到一切都完全正确，静默阻塞不会给你任何关于什么是不正确的线索。此外，我必须处理的例子并没有完全正确地遵循规范，这会导致大量的时间浪费。

OpenMAX IL 组件使用缓冲区来传送数据。组件通常会处理来自输入缓冲区的数据，并将其放在输出缓冲区。这种处理对 API 是不可见的，因此它允许供应商在硬件或软件中实现组件，构建在其他 A/V 组件之上，等等。OpenMAX IL 提供了设置和获取组件参数、调用组件上的标准函数或从组件中获取数据的机制。

虽然一些 OpenMAX IL 调用是同步的，但是那些可能需要大量处理的调用是异步的，通过回调函数传递结果。这自然会导致多线程处理模型，尽管 OpenMAX IL 并不明显使用任何线程库，并且应该不知道 IL 客户端如何使用线程。Bellagio 示例使用 pthreads，而 Broadcom 的 Raspberry Pi 示例使用 Broadcom 的 video core OS(VCO)线程( [`https://github.com/raspberrypi/userland/blob/master/interface/vcos/vcos_semaphore.h`](https://github.com/raspberrypi/userland/blob/master/interface/vcos/vcos_semaphore.h) )。

有两种机制可以让数据进出组件。第一个是 IL 客户端调用组件的地方。所有组件都需要支持此机制。第二种是在两个组件之间建立一个隧道，让数据沿着共享缓冲区流动。支持这种机制不需要组件。

## OpenMAX IL 组件

OpenMAX IL in 1.1.2 lists 中列出了许多标准组件，包括(对于音频)解码器、编码器、混合器、读取器、渲染器、写入器、捕获器和处理器。一个 IL 客户端通过调用`OMX_GetHandle()`获得这样一个组件，并传入组件的名称。这是一个问题:组件没有标准的名称。

1.1.2 规范说，“由于组件是按名称请求的，因此定义了命名约定。OpenMAX IL 组件名是以零结尾的字符串，格式如下:`OMX.<vendor_name>.<vendor_specified_convention>`，例如`OMX.CompanyABC.MP3Decoder.productXYZ`。不同供应商的组件名称之间没有标准化。”

在这一点上，您必须查看当前可用的实现，因为这种标准化的缺乏会导致即使是最基本的程序也存在差异。

## 履行

以下是实现。

### 树莓皮

Raspberry Pi 有一个 Broadcom 图形处理单元(GPU)，Broadcom 支持 OpenMAX IL。构建应用程序所需的包含文件在`/opt/vc/include/IL`、`/opt/vc/include`和`/opt/vc/include/interface/vcos/pthreads`中。需要链接的库在`/opt/vc/lib`目录下，分别是`openmaxil`和`bcm_host`。

Broadcom 库需要调用额外的代码以及标准的 OpenMAX IL 函数。此外，OpenMAX IL 还有许多(合法的)扩展，这些扩展在规范或其他实现中是找不到的。这些在`/opt/vc/include/IL/OMX_Broadcom.h`中有描述。由于这些原因，我定义了`RASPBERRY_PI`来允许这些被处理。

例如，`listcomponents.c`的编译行如下:

```
cc -g -DRASPBERRY_PI -I /opt/vc/include/IL -I /opt/vc/include \
   -I /opt/vc/include/interface/vcos/pthreads \
   -o listcomponents listcomponents.c \
   -L /opt/vc/lib -l openmaxil -l bcm_host

```

Broadcom 实现是闭源的。它似乎是其 GPU API 的一个薄薄的包装，Broadcom 不会发布该 API 的任何细节。这意味着您不能扩展组件集或支持的编解码器，因为没有关于如何构建新组件的详细信息。虽然组件的设置是合理的，但目前除了 PCM 之外不支持编解码器，也不支持非 GPU 硬件，如 USB 声卡。

OtherCrashOverride ( [`www.raspberrypi.org/phpBB3/viewtopic.php?f=70&t=33101&p=287590#p287590`](http://www.raspberrypi.org/phpBB3/viewtopic.php?f=70&t=33101&p=287590#p287590) )说他已经设法让 Broadcom 组件在 LIM 实现下运行，但我还没有证实这一点。

就音频而言，Raspberry Pi 上的实现非常弱，因为所有音频解码都要在软件中完成，并且它只能播放 PCM 数据。视频更令人印象深刻，在我的书《Raspberry Pi GPU 音频视频编程》中有所论述。

### 百乐宫（美国酒店名）

Bellagio 库不需要额外的代码或任何扩展。有一些小错误，所以我定义`BELLAGIO`来处理它们。我从源代码构建但没有安装，所以 includes 和 libraries 在一个有趣的地方。我的编译代码如下:

```
cc  -g -DBELLAGIO -I ../libomxil-bellagio-0.9.3/include/ \
    -o listcomponents listcomponents.c \
    -L ../libomxil-bellagio-0.9.3/src/.libs -l omxil-bellagio

```

这是运行时的代码行:

```
export LD_LIBRARY_PATH=../libomxil-bellagio-0.9.3/src/.libs/
./listcomponents

```

Bellagio 代码是开源的。

### 潜象存储器（Latent Image Memory 的缩写）

下载 1.1 版本很麻烦，因为 1.1 下载使用了已经消失的 Git repo(截至 2016 年 11 月)。相反，您必须运行以下命令:

```
  git clone git://limoa.git.sourceforge.net/gitroot/limoa/limoi-components
  git clone git://limoa.git.sourceforge.net/gitroot/limoa/limoi-core
  git clone git://limoa.git.sourceforge.net/gitroot/limoa/limoi-plugins
  git clone git://limoa.git.sourceforge.net/gitroot/limoa/limutil
  git clone git://limoa.git.sourceforge.net/gitroot/limoa/manifest

```

您必须将构建中的`root.mk`文件复制到包含所有代码的顶层文件夹中，并将其重命名为`Makefile`。`root.readme`文件有构建指令。感谢 OtherCrashOverride ( [`www.raspberrypi.org/phpBB3/viewtopic.php?f=70&t=33101&p=286516#p286516`](http://www.raspberrypi.org/phpBB3/viewtopic.php?f=70&t=33101&p=286516#p286516) )的这些指令。

建造图书馆遇到了一些小问题。我不得不注释掉一个视频文件中的几行，因为它引用了不存在的结构字段，并且不得不从一个`Makefile.am`中移除`-Werrors`，否则关于未使用变量的警告将会中止编译。

库构建将文件放在我的`HOME`中的新目录中。到目前为止，我在实现中发现了一些小错误。我的编译代码如下:

```
cc -g -DLIM -I ../../lim-omx-1.1/LIM/limoi-core/include/ \
   -o listcomponents listcomponents.c \
   -L /home/newmarch/osm-build/lib/ -l limoa -l limoi-core

```

以下是运行时的代码行:

```
export LD_LIBRARY_PATH=/home/newmarch/osm-build/lib/
./listcomponents

```

LIM 代码是开源的。

### 硬件支持的版本

您可以在 open max IL Conformant Products([`www.khronos.org/conformance/adopters/conformant-products#openmaxil`](http://www.khronos.org/conformance/adopters/conformant-products#openmaxil))找到硬件支持的版本列表。

## 组件的实现

Bellagio 库(你需要源码包才能看到这些文件)在其`README`中只列出了两个音频组件。

*   OMX 音量控制
*   OMX 混音器组件

它们的名字(来自示例测试文件)分别是`OMX.st.volume.component`和`OMX.st.audio.mixer`。百乐宫背后的公司是意法半导体( [`www.st.com/internet/com/home/home.jsp`](http://www.st.com/internet/com/home/home.jsp) )，这就解释了`st`。

Raspberry Pi 上使用的 Broadcom OpenMAX IL 实现有更好的文档记录。如果您下载 Raspberry Pi 的固件主文件，它会在`documentation/ilcomponents`目录中列出 IL 组件。这列出了组件`audio_capture`、`audio_decode`、`audio_encode`、`audio_lowpower`、`audio_mixer`、`audio_processor`、`audio_render`和`audio_splitter`。

Broadcom 示例中的许多 OpenMAX IL 函数调用都隐藏在 Broadcom 便利函数中，如下所示:

```
ilclient_create_component(st->client, &st->audio_render,
                         "audio_render",
                         ILCLIENT_ENABLE_INPUT_BUFFERS | ILCLIENT_DISABLE_ALL_PORTS);

```

这围绕着`OMX_GetHandle()`。但是至少`ilclient.h`声明，“在传递给 IL 核心之前，所提供的组件名称会自动加上前缀`OMX.broadcom.`”所以，你可以断定真名是，比如`OMX.broadcom.audio_render`，等等。

有一种简单的方法可以通过编程获得受支持的组件。首先用`OMX_init()`初始化 OpenMAX 系统，然后调用`OMX_ComponentNameEnum()`。对于连续的索引值，它每次都返回一个唯一的名称，直到最后返回一个错误值`OMX_ErrorNoMore`。

每个组件可以支持多个角色。这些都是由`OMX_GetRolesOfComponent`给出的。1.1 规范在第 8.6 节“标准音频组件”中列出了音频组件的类别和相关角色 LIM 库匹配这些，而 Bellagio 和 Broadcom 不匹配。

下面的程序是`listcomponents.c`:

```
#include <stdio.h>
#include <stdlib.h>

#include <OMX_Core.h>

#ifdef RASPBERRY_PI
#include <bcm_host.h>
#endif

OMX_ERRORTYPE err;

//extern OMX_COMPONENTREGISTERTYPE OMX_ComponentRegistered[];

void listroles(char *name) {
    int n;
    OMX_U32 numRoles;
    OMX_U8 *roles[32];

    /* get the number of roles by passing in a NULL roles param */
    err = OMX_GetRolesOfComponent(name, &numRoles, NULL);
    if (err != OMX_ErrorNone) {
        fprintf(stderr, "Getting roles failed\n", 0);
        exit(1);
    }
    printf("  Num roles is %d\n", numRoles);
    if (numRoles > 32) {
        printf("Too many roles to list\n");
        return;
    }

    /* now get the roles */
    for (n = 0; n < numRoles; n++) {
        roles[n] = malloc(OMX_MAX_STRINGNAME_SIZE);
    }
    err = OMX_GetRolesOfComponent(name, &numRoles, roles);
    if (err != OMX_ErrorNone) {
        fprintf(stderr, "Getting roles failed\n", 0);
        exit(1);
    }
    for (n = 0; n < numRoles; n++) {
        printf("    role: %s\n", roles[n]);
        free(roles[n]);
    }

    /* This is in version 1.2
    for (i = 0; OMX_ErrorNoMore != err; i++) {
        err = OMX_RoleOfComponentEnum(role, name, i);
        if (OMX_ErrorNone == err) {
            printf("   Role of omponent is %s\n", role);
        }
    }
    */
}

int main(int argc, char** argv) {

    int i;
    unsigned char name[OMX_MAX_STRINGNAME_SIZE];

# ifdef RASPBERRY_PI
    bcm_host_init();
# endif

    err = OMX_Init();
    if (err != OMX_ErrorNone) {
        fprintf(stderr, "OMX_Init() failed\n", 0);
        exit(1);
    }

    err = OMX_ErrorNone;
    for (i = 0; OMX_ErrorNoMore != err; i++) {
        err = OMX_ComponentNameEnum(name, OMX_MAX_STRINGNAME_SIZE, i);
        if (OMX_ErrorNone == err) {
            printf("Component is %s\n", name);
            listroles(name);
        }
    }
    printf("No more components\n");

    /*
    i= 0 ;
    while (1) {
        printf("Component %s\n", OMX_ComponentRegistered[i++]);
    }
    */
    exit(0);
}

```

Bellagio 库的输出如下:

```
Component is OMX.st.clocksrc
  Num roles is 1
    role: clocksrc
Component is OMX.st.clocksrc
  Num roles is 1
    role: clocksrc
Component is OMX.st.video.scheduler
  Num roles is 1
    role: video.scheduler
Component is OMX.st.video.scheduler
  Num roles is 1
    role: video.scheduler
Component is OMX.st.volume.component
  Num roles is 1
    role: volume.component
Component is OMX.st.volume.component
  Num roles is 1
    role: volume.component
Component is OMX.st.audio.mixer
  Num roles is 1
    role: audio.mixer
Component is OMX.st.audio.mixer
  Num roles is 1
    role: audio.mixer
Component is OMX.st.clocksrc
  Num roles is 1
    role: clocksrc
Component is OMX.st.clocksrc
  Num roles is 1
    role: clocksrc
Component is OMX.st.video.scheduler
  Num roles is 1
    role: video.scheduler
Component is OMX.st.video.schedu

ler
  Num roles is 1
    role: video.scheduler
Component is OMX.st.volume.component
  Num roles is 1
    role: volume.component
Component is OMX.st.volume.component
  Num roles is 1
    role: volume.component
Component is OMX.st.audio.mixer
  Num roles is 1
    role: audio.mixer
Component is OMX.st.audio.mixer
  Num roles is 1
    role: audio.mixer
No more components

```

这不太正确。OpenMAX IL 规范规定每个组件只能出现一次，不能重复。

Raspberry Pi 报告了大量的组件，但是没有为它们中的任何一个定义角色。

```
Component is OMX.broadcom.audio_capture
  Num roles is 0
Component is OMX.broadcom.audio_decode
  Num roles is 0
Component is OMX.broadcom.audio_encode
  Num roles is 0
Component is OMX.broadcom.audio_render
  Num roles is 0
Component is OMX.broadcom.audio_mixer
  Num roles is 0
Component is OMX.broadcom.audio_splitter
  Num roles is 0
Component is OMX.broadcom.audio_processor
  Num roles is 0
Component is OMX.broadcom.camera
  Num roles is 0
Component is OMX.broadcom.clock
  Num roles is 0
Component is OMX.broadcom.coverage
  Num roles is 0
Component is OMX.broadcom.egl_render
  Num roles is 0
Component is OMX.broadcom.image_fx
  Num roles is 0
Component is OMX.broadcom.image_decode
  Num roles is 0
Component is OMX.broadcom.image_encode
  Num roles is 0
Component is OMX.broadcom.image_read
  Num roles is 0
Component is OMX.broadcom.image_write
  Num roles is 0
Component is OMX.broadcom.read_media
  Num roles is 0
Component is OMX.broadcom.resize
  Num roles is 0
Component is OMX.broadcom.source
  Num roles is 0
Component is OMX.broadcom.text_scheduler
  Num roles is 0
Component is OMX.broadcom.transition
  Num roles is 0
Component is OMX.broadcom.video_decode
  Num roles is 0
Component is OMX.broadcom.video_encode
  Num roles is 0
Component is OMX.broadcom.video_render
  Num roles is 0
Component is OMX.broadcom.video_scheduler
  Num roles is 0
Component is OMX.broadcom.video_splitter
  Num roles is 0
Component is OMX.broadcom.visualisation
  Num roles is 0
Component is OMX.broadcom.write_media
  Num roles is 0
Component is OMX.broadcom.write_still
  Num roles is 0
No more components

```

LIM 的输出如下:

```
Component is OMX.limoi.alsa_sink
  Num roles is 1
    role: audio_renderer.pcm
Component is OMX.limoi.clock
  Num roles is 1
    role: clock.binary
Component is OMX.limoi.ffmpeg.decode.audio
  Num roles is 8
    role: audio_decoder.aac
    role: audio_decoder.adpcm
    role: audio_decoder.amr
    role: audio_decoder.mp3
    role: audio_decoder.ogg
    role: audio_decoder.pcm
    role: audio_decoder.ra
    role: audio_decoder.wma
Component is OMX.limoi.ffmpeg.decode.video
  Num roles is 7
    role: video_decoder.avc
    role: video_decoder.h263
    role: video_decoder.mjpeg
    role: video_decoder.mpeg2
    role: video_decoder.mpeg4
    role: video_decoder.rv
    role: video_decoder.wmv
Component is OMX.limoi.ffmpeg.demux
  Num roles is 1
    role: container_demuxer.all
Component is OMX.limoi.ffmpeg.encode.audio
  Num roles is 2
    role: audio_encoder.aac
    role: audio_encoder.mp3
Component is OMX.limoi.ffmpeg.encode.video
  Num roles is 2
    role: video_encoder.h263
    role: video_encoder.mpeg4
Component is OMX.limoi.ffmpeg.mux
  Num roles is 1
    role: container_muxer.all
Component is OMX.limoi.ogg_dec
  Num roles is 1
    role: audio_decoder_with_framing.ogg
Component is OMX.limoi.sdl.renderer.video
  Num roles is 1
    role: iv_renderer.yuv.overlay
Component is OMX.limoi.vid

eo_scheduler
  Num roles is 1
    role: video_scheduler.binary
No more components

```

### 获取关于 IL 组件的信息

接下来，您将了解如何获取有关 OpenMAX IL 系统和您使用的任何组件的信息。所有 IL 客户端必须通过调用`OMX_Init()`来初始化 OpenMAX IL。几乎所有函数都返回错误值，Bellagio 使用的风格如下:

```
  err = OMX_Init();
  if(err != OMX_ErrorNone) {
      fprintf(stderr, "OMX_Init() failed\n", 0);
      exit(1);
  }

```

这在我看来是一种合理的风格，所以我在续集中遵循了它。

下一个需求是获得组件的句柄。这需要组件的供应商名称，可以使用前面显示的`listcomponents.c`程序找到。函数`OMX_GetHandle`接受一些参数，包括一组回调函数。这些是跟踪应用程序的行为所需要的，但对于本节中的示例并不需要。这段代码显示了如何获得 Bellagio 音量组件的句柄:

```
  OMX_HANDLETYPE handle;
  OMX_CALLBACKTYPE callbacks;
  OMX_ERRORTYPE err;

  err = OMX_GetHandle(&handle, "OMX.st.volume.component", NULL /*appPriv */, &callbacks);
  if(err != OMX_ErrorNone) {
      fprintf(stderr, "OMX_GetHandle failed\n", 0);
      exit(1);
  }

```

组件有端口，端口有通道。这些信息的获取和设置由函数`OMX_GetParameter()`、`OMX_SetParameter()`、`OMX_GetConfig()`和`OMX_GetConfig()`完成。在组件被“加载”之前进行`…Parameter`调用，在组件被加载之后进行`…Config`调用。

c 不是 OO 语言，这是一个普通的函数调用(嗯，实际上是一个宏)。在 OO 语言中，它是一个对象将另一个对象作为参数的方法，如`component.method(object)`。在 OpenMAX IL 中，Get/Set 函数将调用“对象”作为第一个参数(组件，该方法的参数是什么类型的“对象”的指示符)，可能的“对象”类型的索引，以及参数对象的结构。索引值与 1.1 规范表 4-2 中的结构相关。

这些调用采用一个(指向的)结构来填充或提取值。这些结构都是规范化的，因此它们共享公共字段，如结构的大小。在 Bellagio 示例中，这是通过宏`setHeader()`完成的。传入以获取端口信息的结构通常是类型为`OMX_PORT_PARAM_TYPE`的通用结构。有些字段可以直接访问，有些需要转换为更特殊的类型，有些隐藏在联合中，必须提取出来。

端口由整数索引标记。不同的功能有不同的端口，如音频、图像、视频等。要获取有关音频端口起始值的信息，请使用以下命令:

```
  setHeader(&param, sizeof(OMX_PORT_PARAM_TYPE));
  err = OMX_GetParameter(handle, OMX_IndexParamAudioInit, &param);
  if(err != OMX_ErrorNone){
      fprintf(stderr, "Error in getting OMX_PORT_PARAM_TYPE parameter\n", 0);
    exit(1);
  }
  printf("Audio ports start on %d\n",
         ((OMX_PORT_PARAM_TYPE)param).nStartPortNumber);
  printf("There are %d open ports\n",
         ((OMX_PORT_PARAM_TYPE)param).nPorts);

```

宏`setHeader`只是填充头部信息，比如版本号和数据结构的大小。

现在可以询问特定端口的能力。您可以查询端口类型(音频或其他)、方向(输入或输出)以及有关支持的 MIME 类型的信息。

```
  OMX_PARAM_PORTDEFINITIONTYPE sPortDef;

  setHeader(&sPortDef, sizeof(OMX_PARAM_PORTDEFINITIONTYPE));
  sPortDef.nPortIndex = 0;
  err = OMX_GetParameter(handle, OMX_IndexParamPortDefinition, &sPortDef);
  if(err != OMX_ErrorNone){
      fprintf(stderr, "Error in getting OMX_PORT_PARAM_TYPE parameter\n", 0);
    exit(1);
  }
  if (sPortDef.eDomain == OMX_PortDomainAudio) {
      printf("Is an audio port\n");
  } else {
      printf("Is other device port\n");
  }

  if (sPortDef.eDir == OMX_DirInput) {
      printf("Port is an input port\n");
  } else {
      printf("Port is an output port\n");
  }

  /* the Audio Port info is buried in a union format.audio within the struct */
  printf("Port min buffers %d,  mimetype %s, encoding %d\n",
         sPortDef.nBufferCountMin,
         sPortDef.format.audio.cMIMEType,
         sPortDef.format.audio.eEncoding);

```

Bellagio 库为其音量控制组件支持的 MIME 类型返回“raw/audio”。但是，这不是 IANA MIME 媒体类型( [`www.iana.org/assignments/media-types`](http://www.iana.org/assignments/media-types) )列出的有效 MIME 类型。编码返回的值是零，对应`OMX_AUDIO_CodingUnused`，这个好像也不正确。

如果您在 Raspberry Pi 组件`audio_render`和 LIM 组件`OMX.limoi.alsa_sink`上尝试相同的程序，您会得到 MIME 类型的`NULL`，但是编码值为 2，也就是`OMX_AUDIO_CodingPCM`。PCM 有一个哑剧类型的`audio/L16`，所以`NULL`似乎不合适。

OpenMAX IL 库允许向端口查询其支持的数据类型。这是通过使用索引`OMX_IndexParamAudioPortFormat`查询`OMX_AUDIO_PARAM_PORTFORMATTYPE`对象来完成的。根据规范，对于从零开始的每个索引，对`GetParameter()`的调用应该返回一个编码，比如`OMX_AUDIO_CodingPCM`或`OMX_AUDIO_CodingMp3`，直到不再有支持的格式，在这种情况下，调用将返回`OMX_ErrorNoMore`。

Bellagio 代码返回值`OMX_AUDIO_CodingUnused`，这是不正确的。LIM 代码根本没有设置值，所以您得到的只是垃圾。Broadcom 实现工作正常，但正如将要讨论的那样，它会返回实际上不受支持的值。所以，这种呼吁的价值有限。

以下代码对此进行了测试:

```
void getSupportedAudioFormats(int indentLevel, int portNumber) {
    OMX_AUDIO_PARAM_PORTFORMATTYPE sAudioPortFormat;

    setHeader(&sAudioPortFormat, sizeof(OMX_AUDIO_PARAM_PORTFORMATTYPE));
    sAudioPortFormat.nIndex = 0;
    sAudioPortFormat.nPortIndex = portNumber;

    printf("Supported audio formats are:\n");
    for(;;) {
        err = OMX_GetParameter(handle, OMX_IndexParamAudioPortFormat, &sAudioPortFormat);
        if (err == OMX_ErrorNoMore) {
            printf("No more formats supported\n");
            return;
        }

        /* This shouldn't occur, but does with Broadcom library */
        if (sAudioPortFormat.eEncoding == OMX_AUDIO_CodingUnused) {
             printf("No coding format returned\n");
             return;
        }

        switch (sAudioPortFormat.eEncoding) {
        case OMX_AUDIO_CodingPCM:
            printf("Supported encoding is PCM\n");
            break;
        case OMX_AUDIO_CodingVORBIS:
            printf("Supported encoding is Ogg Vorbis\n");
            break;
        case OMX_AUDIO_CodingMP3:
            printf("Supported encoding is MP3\n");
            break;
#ifdef RASPBERRY_PI
        case OMX_AUDIO_CodingFLAC:
            printf("Supported encoding is FLAC\n");
            break;
        case OMX_AUDIO_CodingDDP:
            printf("Supported encoding is DDP\n");
            break;
        case OMX_AUDIO_CodingDTS:
            printf("Supported encoding is DTS\n");
            break;
        case OMX_AUDIO_CodingWMAPRO:
            printf("Supported encoding is WMAPRO\n");
            break;
#endif
        case OMX_AUDIO_CodingAAC:
            printf("Supported encoding is AAC\n");
            break;
        case OMX_AUDIO_CodingWMA:
            printf("Supported encoding is WMA\n");
            break;
        case OMX_AUDIO_CodingRA:
            printf("Supported encoding is RA\n");
            break;
        case OMX_AUDIO_CodingAMR:
            printf("Supported encoding is AMR\n");
            break;
        case OMX_AUDIO_CodingEVRC:
            printf("Supported encoding is EVRC\n");
            break;
        case OMX_AUDIO_CodingG726:
            printf("Supported encoding is G726\n");
            break;
        case OMX_AUDIO_CodingMIDI:
            printf("Supported encoding is MIDI\n");
            break;
        case OMX_AUDIO_CodingATRAC3:
            printf("Supported encoding is ATRAC3\n");
            break;
        case OMX_AUDIO_CodingATRACX:
            printf("Supported encoding is ATRACX\n");
            break;
        case OMX_AUDIO_CodingATRACAAL:
            printf("Supported encoding is ATRACAAL\n");
            break;
        default:
            printf("Supported encoding is %d\n",
                  sAudioPortFormat.eEncoding);
        }
        sAudioPortFormat.nIndex++;
    }
}

```

请注意，该代码包含特定于 Broadcom 库的枚举值，如`OMX_AUDIO_CodingATRAC3`。根据 OpenMAX IL 扩展机制，这些是合法的值，但当然不是可移植的值。

Bellagio 库错误地为每个索引值返回`OMX_AUDIO_CodingUnused`。

Broadcom 库可以返回许多值。例如，对于`audio_decode`组件，它返回以下内容:

```
      Supported audio formats are:
      Supported encoding is MP3
      Supported encoding is PCM
      Supported encoding is AAC
      Supported encoding is WMA
      Supported encoding is Ogg Vorbis
      Supported encoding is RA
      Supported encoding is AMR
      Supported encoding is EVRC
      Supported encoding is G726
      Supported encoding is FLAC
      Supported encoding is DDP
      Supported encoding is DTS
      Supported encoding is WMAPRO
      Supported encoding is ATRAC3
      Supported encoding is ATRACX
      Supported encoding is ATRACAAL
      Supported encoding is MIDI
      No more formats supported

```

遗憾的是，除了 PCM 之外，这些都不被支持。以下是根据 jamesh 在“音频解码器组件的 OMX _ 分配缓冲区失败”中的说法:

> The way it works is that the component returns success for all codecs it may support (that is, all codecs we once owned). This is limited by the actual installed codec. It is best to detect which codecs exist at runtime, but these codes have never been written because they are never needed. This is also unlikely to happen, because Broadcom no longer supports audio codecs in this way, they have moved from the video core to the host CPU, because they are now strong enough to handle any audio decoding task.

这真的有点可悲。

将所有的位放在一起就产生了程序`info.c`，如下所示:

```
/**
   Based on code
   Copyright (C) 2007-2009 STMicroelectronics
   Copyright (C) 2007-2009 Nokia Corporation and/or its subsidiary(-ies).
   under the LGPL
*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/stat.h>

#include <OMX_Core.h>
#include <OMX_Component.h>
#include <OMX_Types.h>
#include <OMX_Audio.h>

#ifdef RASPBERRY_PI
#include <bcm_host.h>
#endif

OMX_ERRORTYPE err;
OMX_HANDLETYPE handle;
OMX_VERSIONTYPE specVersion, compVersion;

OMX_CALLBACKTYPE callbacks;

#define indent {int n = 0; while (n++ < indentLevel*2) putchar(' ');}

static void setHeader(OMX_PTR header, OMX_U32 size) {
    /* header->nVersion */
    OMX_VERSIONTYPE* ver = (OMX_VERSIONTYPE*)(header + sizeof(OMX_U32));
    /* header->nSize */
    *((OMX_U32*)header) = size;

    /* for 1.2
       ver->s.nVersionMajor = OMX_VERSION_MAJOR;
       ver->s.nVersionMinor = OMX_VERSION_MINOR;
       ver->s.nRevision = OMX_VERSION_REVISION;
       ver->s.nStep = OMX_VERSION_STEP;
    */
    ver->s.nVersionMajor = specVersion.s.nVersionMajor;
    ver->s.nVersionMinor = specVersion.s.nVersionMinor;
    ver->s.nRevision = specVersion.s.nRevision;
    ver->s.nStep = specVersion.s.nStep;
}

void printState() {
    OMX_STATETYPE state;
    err = OMX_GetState(handle, &state);
    if (err != OMX_ErrorNone) {
        fprintf(stderr, "Error on getting state\n");
        exit(1);
    }
    switch (state) {
    case OMX_StateLoaded: fprintf(stderr, "StateLoaded\n"); break;
    case OMX_StateIdle: fprintf(stderr, "StateIdle\n"); break;
    case OMX_StateExecuting: fprintf(stderr, "StateExecuting\n"); break;
    case OMX_StatePause: fprintf(stderr, "StatePause\n"); break;
    case OMX_StateWaitForResources: fprintf(stderr, "StateWiat\n"); break;
    default:  fprintf(stderr, "State unknown\n"); break;
    }
}

OMX_ERRORTYPE setEncoding(int portNumber, OMX_AUDIO_CODINGTYPE encoding) {
    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;

    setHeader(&sPortDef, sizeof(OMX_PARAM_PORTDEFINITIONTYPE));
    sPortDef.nPortIndex = portNumber;
    sPortDef.nPortIndex = portNumber;
    err = OMX_GetParameter(handle, OMX_IndexParamPortDefinition, &sPortDef);
    if(err != OMX_ErrorNone){
        fprintf(stderr, "Error in getting OMX_PORT_DEFINITION_TYPE parameter\n",
 0);
        exit(1);
    }

    sPortDef.format.audio.eEncoding = encoding;
    sPortDef.nBufferCountActual = sPortDef.nBufferCountMin;

    err = OMX_SetParameter(handle, OMX_IndexParamPortDefinition, &sPortDef);
    return err;
}

void getPCMInformation(int indentLevel, int portNumber) {
    /* assert: PCM is a supported mode */
    OMX_AUDIO_PARAM_PCMMODETYPE sPCMMode;

    /* set it into PCM format before asking for PCM info */
    if (setEncoding(portNumber, OMX_AUDIO_CodingPCM) != OMX_ErrorNone) {
        fprintf(stderr, "Error in setting coding to PCM\n");
        return;
    }

    setHeader(&sPCMMode, sizeof(OMX_AUDIO_PARAM_PCMMODETYPE));
    sPCMMode.nPortIndex = portNumber;
    err = OMX_GetParameter(handle, OMX_IndexParamAudioPcm, &sPCMMode);
    if(err != OMX_ErrorNone){
        indent printf("PCM mode unsupported\n");
    } else {
        indent printf("  PCM default sampling rate %d\n", sPCMMode.nSamplingRate);
        indent printf("  PCM default bits per sample %d\n", sPCMMode.nBitPerSample);
        indent printf("  PCM default number of channels %d\n", sPCMMode.nChannels);
    }

    /*
    setHeader(&sAudioPortFormat, sizeof(OMX_AUDIO_PARAM_PORTFORMATTYPE));
    sAudioPortFormat.nIndex = 0;
    sAudioPortFormat.nPortIndex = portNumber;
    */

}
void getMP3Information(int indentLevel, int portNumber) {
    /* assert: MP3 is a supported mode */
    OMX_AUDIO_PARAM_MP3TYPE sMP3Mode;

    /* set it into MP3 format before asking for MP3 info */
    if (setEncoding(portNumber, OMX_AUDIO_CodingMP3) != OMX_ErrorNone) {
        fprintf(stderr, "Error in setting coding to MP3\n");
        return;
    }

    setHeader(&sMP3Mode, sizeof(OMX_AUDIO_PARAM_MP3TYPE));
    sMP3Mode.nPortIndex = portNumber;
    err = OMX_GetParameter(handle, OMX_IndexParamAudioMp3, &sMP3Mode);
    if(err != OMX_ErrorNone){
        indent printf("MP3 mode unsupported\n");
    } else {
        indent printf("  MP3 default sampling rate %d\n", sMP3Mode.nSampleRate);
        indent printf("  MP3 default bits per sample %d\n", sMP3Mode.nBitRate);
        indent printf("  MP3 default number of channels %d\n", sMP3Mode.nChannels);
    }
}

void getSupportedAudioFormats(int indentLevel, int portNumber) {
    OMX_AUDIO_PARAM_PORTFORMATTYPE sAudioPortFormat;

    setHeader(&sAudioPortFormat, sizeof(OMX_AUDIO_PARAM_PORTFORMATTYPE));
    sAudioPortFormat.nIndex = 0;
    sAudioPortFormat.nPortIndex = portNumber;

#ifdef LIM
    printf("LIM doesn't set audio formats properly\n");
    return;
#endif

    indent printf("Supported audio formats are:\n");
    for(;;) {
        err = OMX_GetParameter(handle, OMX_IndexParamAudioPortFormat, &sAudioPortFormat);
        if (err == OMX_ErrorNoMore) {
            indent printf("No more formats supported\n");
            return;
        }

        /* This shouldn't occur, but does with Broadcom library */
        if (sAudioPortFormat.eEncoding == OMX_AUDIO_CodingUnused) {
             indent printf("No coding format returned\n");
             return;
        }

        switch (sAudioPortFormat.eEncoding) {
        case OMX_AUDIO_CodingPCM:
            indent printf("Supported encoding is PCM\n");
            getPCMInformation(indentLevel+1, portNumber);
            break;
        case OMX_AUDIO_CodingVORBIS:
            indent printf("Supported encoding is Ogg Vorbis\n");
            break;
        case OMX_AUDIO_CodingMP3:
            indent printf("Supported encoding is MP3\n");
            getMP3Information(indentLevel+1, portNumber);
            break;
#ifdef RASPBERRY_PI
        case OMX_AUDIO_CodingFLAC:
            indent printf("Supported encoding is FLAC\n");
            break;
        case OMX_AUDIO_CodingDDP:
            indent printf("Supported encoding is DDP\n");
            break;
        case OMX_AUDIO_CodingDTS:
            indent printf("Supported encoding is DTS\n");
            break;
        case OMX_AUDIO_CodingWMAPRO:
            indent printf("Supported encoding is WMAPRO\n");
            break;
        case OMX_AUDIO_CodingATRAC3:
            indent printf("Supported encoding is ATRAC3\n");
            break;
        case OMX_AUDIO_CodingATRACX:
            indent printf("Supported encoding is ATRACX\n");
            break;
        case OMX_AUDIO_CodingATRACAAL:
            indent printf("Supported encoding is ATRACAAL\n");
            break;
#endif
        case OMX_AUDIO_CodingAAC:
            indent printf("Supported encoding is AAC\n");
            break;
        case OMX_AUDIO_CodingWMA:
            indent printf("Supported encoding is WMA\n");
            break;
        case OMX_AUDIO_CodingRA:
            indent printf("Supported encoding is RA\n");
            break;
        case OMX_AUDIO_CodingAMR:
            indent printf("Supported encoding is AMR\n");
            break;
        case OMX_AUDIO_CodingEVRC:
            indent printf("Supported encoding is EVRC\n");
            break;
        case OMX_AUDIO_CodingG726:
            indent printf("Supported encoding is G726\n");
            break;
        case OMX_AUDIO_CodingMIDI:
            indent printf("Supported encoding is MIDI\n");
            break;

            /*
        case OMX_AUDIO_Coding:
            indent printf("Supported encoding is \n");
            break;
            */
        default:
            indent printf("Supported encoding is not PCM or MP3 or Vorbis, is 0x%X\n",
                  sAudioPortFormat.eEncoding);
        }
        sAudioPortFormat.nIndex++;
    }
}

void getAudioPortInformation(int indentLevel, int nPort, OMX_PARAM_PORTDEFINITIONTYPE sPortDef) {
    indent printf("Port %d requires %d buffers\n", nPort, sPortDef.nBufferCountMin);
    indent printf("Port %d has min buffer size %d bytes\n", nPort, sPortDef.nBufferSize);

    if (sPortDef.eDir == OMX_DirInput) {
        indent printf("Port %d is an input port\n", nPort);
    } else {
        indent printf("Port %d is an output port\n",  nPort);
    }
    switch (sPortDef.eDomain) {
    case OMX_PortDomainAudio:
        indent printf("Port %d is an audio port\n", nPort);
        indent printf("Port mimetype %s\n",
               sPortDef.format.audio.cMIMEType);

        switch (sPortDef.format.audio.eEncoding) {
        case OMX_AUDIO_CodingPCM:
            indent printf("Port encoding is PCM\n");
            break;
        case OMX_AUDIO_CodingVORBIS:
            indent printf("Port encoding is Ogg Vorbis\n");
            break;
        case OMX_AUDIO_CodingMP3:
            indent printf("Port encoding is MP3\n");
            break;
        default:
            indent printf("Port encoding is not PCM or MP3 or Vorbis, is %d\n",
                   sPortDef.format.audio.eEncoding);
        }
        getSupportedAudioFormats(indentLevel+1, nPort);

        break;
        /* could put other port types here */
    default:
        indent printf("Port %d is not an audio port\n",  nPort);
    }
}

void getAllAudioPortsInformation(int indentLevel) {
    OMX_PORT_PARAM_TYPE param;
    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;

    int startPortNumber;
    int nPorts;
    int n;

    setHeader(&param, sizeof(OMX_PORT_PARAM_TYPE));

    err = OMX_GetParameter(handle, OMX_IndexParamAudioInit, &param);
    if(err != OMX_ErrorNone){
        fprintf(stderr, "Error in getting audio OMX_PORT_PARAM_TYPE parameter\n", 0);
        return;
    }
    indent printf("Audio ports:\n");
    indentLevel++;

    startPortNumber = param.nStartPortNumber;
    nPorts = param.nPorts;
    if (nPorts == 0) {
        indent printf("No ports of this type\n");
        return;
    }

    indent printf("Ports start on %d\n", startPortNumber);
    indent printf("There are %d open ports\n", nPorts);

    for (n = 0; n < nPorts; n++) {
        setHeader(&sPortDef, sizeof(OMX_PARAM_PORTDEFINITIONTYPE));
        sPortDef.nPortIndex = startPortNumber + n;
        err = OMX_GetParameter(handle, OMX_IndexParamPortDefinition, &sPortDef);
        if(err != OMX_ErrorNone){
            fprintf(stderr, "Error in getting OMX_PORT_DEFINITION_TYPE parameter\n", 0);
            exit(1);
        }
        getAudioPortInformation(indentLevel+1, startPortNumber + n, sPortDef);
    }
}

void getAllVideoPortsInformation(int indentLevel) {
    OMX_PORT_PARAM_TYPE param;
    int startPortNumber;
    int nPorts;
    int n;

    setHeader(&param, sizeof(OMX_PORT_PARAM_TYPE));

    err = OMX_GetParameter(handle, OMX_IndexParamVideoInit, &param);
    if(err != OMX_ErrorNone){
        fprintf(stderr, "Error in getting video OMX_PORT_PARAM_TYPE parameter\n", 0);
        return;
    }
    printf("Video ports:\n");
    indentLevel++;

    startPortNumber = param.nStartPortNumber;
    nPorts = param.nPorts;
    if (nPorts == 0) {
        indent printf("No ports of this type\n");
        return;
    }

    indent printf("Ports start on %d\n", startPortNumber);
    indent printf("There are %d open ports\n", nPorts);
}

void getAllImagePortsInformation(int indentLevel) {
    OMX_PORT_PARAM_TYPE param;
    int startPortNumber;
    int nPorts;
    int n;

    setHeader(&param, sizeof(OMX_PORT_PARAM_TYPE));

    err = OMX_GetParameter(handle, OMX_IndexParamVideoInit, &param);
    if(err != OMX_ErrorNone){
        fprintf(stderr, "Error in getting image OMX_PORT_PARAM_TYPE parameter\n", 0);
        return;
    }
    printf("Image ports:\n");
    indentLevel++;

    startPortNumber = param.nStartPortNumber;
    nPorts = param.nPorts;
    if (nPorts == 0) {
        indent printf("No ports of this type\n");
        return;
    }

    indent printf("Ports start on %d\n", startPortNumber);
    indent printf("There are %d open ports\n", nPorts);
}

void getAllOtherPortsInformation(int indentLevel) {
    OMX_PORT_PARAM_TYPE param;
    int startPortNumber;
    int nPorts;
    int n;

    setHeader(&param, sizeof(OMX_PORT_PARAM_TYPE));

    err = OMX_GetParameter(handle, OMX_IndexParamVideoInit, &param);
    if(err != OMX_ErrorNone){
        fprintf(stderr, "Error in getting other OMX_PORT_PARAM_TYPE parameter\n", 0);
        exit(1);
    }
    printf("Other ports:\n");
    indentLevel++;

    startPortNumber = param.nStartPortNumber;
    nPorts = param.nPorts;
    if (nPorts == 0) {
        indent printf("No ports of this type\n");
        return;
    }

    indent printf("Ports start on %d\n", startPortNumber);
    indent printf("There are %d open ports\n", nPorts);
}

int main(int argc, char** argv) {

    OMX_PORT_PARAM_TYPE param;
    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
    OMX_AUDIO_PORTDEFINITIONTYPE sAudioPortDef;
    OMX_AUDIO_PARAM_PORTFORMATTYPE sAudioPortFormat;
    OMX_AUDIO_PARAM_PCMMODETYPE sPCMMode;

#ifdef RASPBERRY_PI
    char *componentName = "OMX.broadcom.audio_mixer";
#endif
#ifdef LIM
    char *componentName = "OMX.limoi.alsa_sink";
#else
    char *componentName = "OMX.st.volume.component";
#endif
    unsigned char name[128]; /* spec says 128 is max name length */
    OMX_UUIDTYPE uid;
    int startPortNumber;
    int nPorts;
    int n;

    /* ovveride component name by command line argument */
    if (argc == 2) {
        componentName = argv[1];
    }

# ifdef RASPBERRY_PI
    bcm_host_init();
# endif

    err = OMX_Init();
    if(err != OMX_ErrorNone) {
        fprintf(stderr, "OMX_Init() failed\n", 0);
        exit(1);
    }
    /** Ask the core for a handle to the volume control component
     */
    err = OMX_GetHandle(&handle, componentName, NULL /*app private data */, &callbacks);
    if (err != OMX_ErrorNone) {
        fprintf(stderr, "OMX_GetHandle failed\n", 0);
        exit(1);
    }
    err = OMX_GetComponentVersion(handle, name, &compVersion, &specVersion, &uid);
    if (err != OMX_ErrorNone) {
        fprintf(stderr, "OMX_GetComponentVersion failed\n", 0);
        exit(1);
    }
    printf("Component name: %s version %d.%d, Spec version %d.%d\n",
           name, compVersion.s.nVersionMajor,
           compVersion.s.nVersionMinor,
           specVersion.s.nVersionMajor,
           specVersion.s.nVersionMinor);

    /** Get  ports information */
    getAllAudioPortsInformation(0);
    getAllVideoPortsInformation(0);
    getAllImagePortsInformation(0);
    getAllOtherPortsInformation(0);

    exit(0);
}

```

Bellagio 版本的`Makefile`如下:

```
INCLUDES=-I ../libomxil-bellagio-0.9.3/include/
LIBS=-L ../libomxil-bellagio-0.9.3/src/.libs -l omxil-bellagio
CFLAGS = -g

info: info.c
        cc $(FLAGS) $(INCLUDES) -o info info.c $(LIBS)

```

使用 Bellagio 实现的输出如下:

```
Component name: OMX.st.volume.component version 1.1, Spec version 1.1
Audio ports:
  Ports start on 0
  There are 2 open ports
    Port 0 requires 2 buffers
    Port 0 is an input port
    Port 0 is an audio port
    Port mimetype raw/audio
    Port encoding is not PCM or MP3 or Vorbis, is 0
      Supported audio formats are:
      No coding format returned
    Port 1 requires 2 buffers
    Port 1 is an output port
    Port 1 is an audio port
    Port mimetype raw/audio
    Port encoding is not PCM or MP3 or Vorbis, is 0
      Supported audio formats are:
      No coding format returned
Video ports:
  No ports of this type
Image ports:
  No ports of this type
Other ports:
  No ports of this type

```

树莓派的`Makefile`如下:

```
INCLUDES=-I /opt/vc/include/IL -I /opt/vc/include -I /opt/vc/include/interface/vcos/pthreads
CFLAGS=-g -DRASPBERRY_PI
LIBS=-L /opt/vc/lib -l openmaxil -l bcm_host

info: info.c
        cc $(CFLAGS) $(INCLUDES) -o info info.c $(LIBS)

```

组件`audio_render`在 Raspberry Pi 上的输出如下:

```
Audio ports:
  Ports start on 100
  There are 1 open ports
    Port 100 requires 1 buffers
    Port 100 is an input port
    Port 100 is an audio port
    Port mimetype (null)
    Port encoding is PCM
      Supported audio formats are:
      Supported encoding is PCM
          PCM default sampling rate 44100
          PCM default bits per sample 16
          PCM default number of channels 2
      Supported encoding is DDP
      No more formats supported
Video ports:
  No ports of this type
Image ports:
  No ports of this type
Other ports:
  No ports of this type

```

直线电机的`Makefile`如下:

```
INCLUDES=-I ../../lim-omx-1.1/LIM/limoi-core/include/
#LIBS=-L ../../lim-omx-1.1/LIM/limoi-base/src/.libs -l limoi-base
LIBS = -L /home/newmarch/osm-build/lib/ -l limoa -l limoi-core
CFLAGS = -g -DLIM

info: info.c
        cc $(CFLAGS) $(INCLUDES) -o info info.c $(LIBS)

```

`alsa_sink`组件的 LIM 输出如下:

```
Component name: OMX.limoi.alsa_sink version 0.0, Spec version 1.1
Audio ports:
  Ports start on 0
  There are 1 open ports
    Port 0 requires 2 buffers
    Port 0 is an input port
    Port 0 is an audio port
    Port mimetype (null)
    Port encoding is PCM
LIM doesn't set audio formats properly
Error in getting video OMX_PORT_PARAM_TYPE parameter
Error in getting image OMX_PORT_PARAM_TYPE parameter
Error in getting other OMX_PORT_PARAM_TYPE parameter

```

当组件不支持某个模式时(这里的音频组件不支持视频、图像或其他模式)，LIM 实现会抛出错误。这违反了 1.1 规范，该规范规定如下:

```
"All standard components shall support the following parameters:
  o OMX_IndexParamPortDefinition
  o OMX_IndexParamCompBufferSupplier
  o OMX_IndexParamAudioInit
  o OMX_IndexParamImageInit
  o OMX_IndexParamVideoInit
  o OMX_IndexParamOtherInit"

```

我想你可能会说`alsa_sink`组件不是标准组件，所以它是允许的。嗯，好吧…

## 播放 PCM 音频文件

向输出设备播放音频需要使用`audio_render`设备。这是 1.1 规范中的标准设备之一，包含在 Broadcom Raspberry Pi 库中，但不包含在 Bellagio 库中。LIM 有一个组件`alsa_sink`，起着同样的作用。

播放音频的程序结构如下:

1.  初始化库和音频渲染组件。
2.  不断填充输入缓冲区，并要求组件清空缓冲区。
3.  从组件捕获事件，告知缓冲区已被清空，以便安排重新填充缓冲区并请求清空缓冲区。
4.  完工后清理。

请注意，Raspberry Pi 音频渲染组件将只播放 PCM 数据，而 LIM `alsa_sink`组件只能以 44，100Hz 播放。

### 状态

初始化组件是一个多步骤的过程，具体取决于组件的状态。组件在`Loaded`状态下创建。它们通过`OMX_SendCommand(handle, OMX_CommandStateSet, <next state>, <param>)`从一种状态转换到另一种状态。从`Loaded`出发的下一个州应该是`Idle`，从那里到`Executing`。还有其他一些你不需要关心的状态。

改变状态的请求是异步的。send 命令立即返回(嗯，在 5 毫秒内)。当状态发生实际变化时，会调用事件处理程序回调函数。

### 线

一些命令要求组件处于特定状态。将组件置于某种状态的请求是异步的。因此，客户端可以发出请求，但是客户端可能必须等待，直到状态发生变化。这最好通过客户端暂停其线程的操作来完成，直到被事件处理程序中发生的状态变化唤醒。

Linux/Unix 已经在管理多线程的 Posix pthreads 库上实现了标准化。出于我们的目的，您使用了这个库中的两个部分:在关键部分放置互斥体的能力和基于条件挂起/唤醒线程的能力。Pthreads 在很多地方都有涉及，Blaise Barney 有一个很短很好的教程叫做“POSIX Threads 编程”( [`https://computing.llnl.gov/tutorials/pthreads/#Misc`](https://computing.llnl.gov/tutorials/pthreads/#Misc) )。

您使用的函数和数据如下:

```
pthread_mutex_t mutex;
OMX_STATETYPE currentState = OMX_StateLoaded;
pthread_cond_t stateCond;

void waitFor(OMX_STATETYPE state) {
    pthread_mutex_lock(&mutex);
    while (currentState != state)
        pthread_cond_wait(&stateCond, &mutex);
    fprintf(stderr, "Wait successfully completed\n");
    pthread_mutex_unlock(&mutex);
}

void wakeUp(OMX_STATETYPE newState) {
    pthread_mutex_lock(&mutex);
    currentState = newState;
    pthread_cond_signal(&stateCond);
    pthread_mutex_unlock(&mutex);
}
pthread_mutex_t empty_mutex;
int emptyState = 0;
OMX_BUFFERHEADERTYPE* pEmptyBuffer;
pthread_cond_t emptyStateCond;

void waitForEmpty() {
    pthread_mutex_lock(&empty_mutex);
    while (emptyState == 1)
        pthread_cond_wait(&emptyStateCond, &empty_mutex);
    emptyState = 1;
    pthread_mutex_unlock(&empty_mutex);
}

void wakeUpEmpty(OMX_BUFFERHEADERTYPE* pBuffer) {
    pthread_mutex_lock(&empty_mutex);
    emptyState = 0;
    pEmptyBuffer = pBuffer;
    pthread_cond_signal(&emptyStateCond);
    pthread_mutex_unlock(&empty_mutex);
}

void mutex_init() {
    int n = pthread_mutex_init(&mutex, NULL);
    if ( n != 0) {
        fprintf(stderr, "Can't init state mutex\n");
    }
    n = pthread_mutex_init(&empty_mutex, NULL);
    if ( n != 0) {
        fprintf(stderr, "Can't init empty mutex\n");
    }
}

```

### OpenMAX IL 中的匈牙利符号

匈牙利符号是由查尔斯·西蒙尼发明的，用来给变量、结构和字段名添加类型或功能信息。Microsoft Windows SDK 中大量使用了一个窗体。在 OpenMAX IL 中，通过为变量、字段等添加前缀，使用了一种简化形式，如下所示:

*   以某种数字为前缀。
*   `p`给指针加前缀。
*   给结构或字符串加前缀。
*   给回调函数加前缀。

这些公约的价值是很有争议的。

### 回收

两种类型的回调函数与这个例子相关:在状态和一些其他事件改变时发生的事件回调，以及当组件清空输入缓冲区时发生的空缓冲区回调。这些在以下机构注册:

```
OMX_CALLBACKTYPE callbacks  = { .EventHandler = cEventHandler,
            .EmptyBufferDone = cEmptyBufferDone,
};
err = OMX_GetHandle(&handle, componentName, NULL /*app private data */, &callbacks);

```

### 组件资源

每个组件都有许多需要配置的端口。端口是组件的一些资源。每个端口开始时是启用的，但可以用`OMX_SendCommand(handle, OMX_CommandPortDisable, <port number>, NULL)`设置为禁用。

启用的端口可以分配缓冲区，用于将数据传入和传出组件。这可以通过两种方式完成:`OMX_AllocateBuffer`要求组件为客户端执行分配，而使用`OMX_UseBuffer`客户端将一个缓冲区交给组件。由于可能存在缓冲区内存对齐问题，我更喜欢让组件进行分配。

这是一个棘手的部分。要在组件上分配或使用缓冲区，必须请求从`Loaded`状态转换到`Idle`。因此，在分配缓冲区之前，必须调用`OMX_SendCommand(handle, OMX_CommandStateSet, OMX_StateIdle, <param>)`。但是直到每个端口都被禁用或者所有的缓冲区都被分配后，到`Idle`的转换才会发生。

这最后一步让我绞尽脑汁了将近一周。`audio_render`组件有两个端口:一个输入音频端口和一个时间更新端口。虽然我已经正确配置了音频端口，但我没有禁用时间端口，因为我不知道它有时间端口。因此，到`Idle`的转换从未发生。下面是处理这种情况的代码:

```
    setHeader(&param, sizeof(OMX_PORT_PARAM_TYPE));
    err = OMX_GetParameter(handle, OMX_IndexParamOtherInit, &param);
    if(err != OMX_ErrorNone){
        fprintf(stderr, "Error in getting OMX_PORT_PARAM_TYPE parameter\n", 0);
        exit(1);
    }
    startPortNumber = ((OMX_PORT_PARAM_TYPE)param).nStartPortNumber;
    nPorts = ((OMX_PORT_PARAM_TYPE)param).nPorts;
    printf("Other has %d ports\n", nPorts);
    /* and disable it */
    err = OMX_SendCommand(handle, OMX_CommandPortDisable, startPortNumber, NULL);
    if (err != OMX_ErrorNone) {
        fprintf(stderr, "Error on setting port to disabled\n");
        exit(1);
    }

```

以下是如何设置音频端口的参数:

```
    /** Get audio port information */
    setHeader(&param, sizeof(OMX_PORT_PARAM_TYPE));
    err = OMX_GetParameter(handle, OMX_IndexParamAudioInit, &param);
    if(err != OMX_ErrorNone){
        fprintf(stderr, "Error in getting OMX_PORT_PARAM_TYPE parameter\n", 0);
        exit(1);
    }
    startPortNumber = ((OMX_PORT_PARAM_TYPE)param).nStartPortNumber;
    nPorts = ((OMX_PORT_PARAM_TYPE)param).nPorts;
    if (nPorts > 1) {
        fprintf(stderr, "Render device has more than one port\n");
        exit(1);
    }

    setHeader(&sPortDef, sizeof(OMX_PARAM_PORTDEFINITIONTYPE));
    sPortDef.nPortIndex = startPortNumber;
    err = OMX_GetParameter(handle, OMX_IndexParamPortDefinition, &sPortDef);
    if(err != OMX_ErrorNone){
        fprintf(stderr, "Error in getting OMX_PORT_DEFINITION_TYPE parameter\n", 0);
        exit(1);
    }
    if (sPortDef.eDomain != OMX_PortDomainAudio) {
        fprintf(stderr, "Port %d is not an audio port\n", startPortNumber);
        exit(1);
    }

    if (sPortDef.eDir != OMX_DirInput) {
        fprintf(stderr, "Port is not an input port\n");
        exit(1);
    }
    if (sPortDef.format.audio.eEncoding == OMX_AUDIO_CodingPCM) {
        printf("Port encoding is PCM\n");
    }    else {
        printf("Port has unknown encoding\n");
    }

    /* create minimum number of buffers for the port */
    nBuffers = sPortDef.nBufferCountActual = sPortDef.nBufferCountMin;
    printf("Number of bufers is %d\n", nBuffers);
    err = OMX_SetParameter(handle, OMX_IndexParamPortDefinition, &sPortDef);
    if(err != OMX_ErrorNone){
        fprintf(stderr, "Error in setting OMX_PORT_PARAM_TYPE parameter\n", 0);
        exit(1);
    }

    /* call to put state into idle before allocating buffers */
    err = OMX_SendCommand(handle, OMX_CommandStateSet, OMX_StateIdle, NULL);
    if (err != OMX_ErrorNone) {
        fprintf(stderr, "Error on setting state to idle\n");
        exit(1);
    }

    err = OMX_SendCommand(handle, OMX_CommandPortEnable, startPortNumber, NULL);
    if (err != OMX_ErrorNone) {
        fprintf(stderr, "Error on setting port to enabled\n");
        exit(1);
    }

    nBufferSize = sPortDef.nBufferSize;
    printf("%d buffers of size is %d\n", nBuffers, nBufferSize);

    inBuffers = malloc(nBuffers * sizeof(OMX_BUFFERHEADERTYPE *));
    if (inBuffers == NULL) {
        fprintf(stderr, "Can't allocate buffers\n");
        exit(1);
    }
    for (n = 0; n < nBuffers; n++) {
        err = OMX_AllocateBuffer(handle, inBuffers+n, startPortNumber, NULL,
                                 nBufferSize);
        if (err != OMX_ErrorNone) {
            fprintf(stderr, "Error on AllocateBuffer in 1%i\n", err);
            exit(1);
        }

    }

    waitFor(OMX_StateIdle);
    /* try setting the encoding to PCM mode */
    setHeader(&sPCMMode, sizeof(OMX_AUDIO_PARAM_PCMMODETYPE));
    sPCMMode.nPortIndex = startPortNumber;
    err = OMX_GetParameter(handle, OMX_IndexParamAudioPcm, &sPCMMode);
    if(err != OMX_ErrorNone){
        printf("PCM mode unsupported\n");
        exit(1);
    } else {
        printf("PCM mode supported\n");
        printf("PCM sampling rate %d\n", sPCMMode.nSamplingRate);
        printf("PCM nChannels %d\n", sPCMMode.nChannels);
    }

```

### 设置输出设备

OpenMAX 有一个标准的音频渲染组件。但是它渲染到什么设备上呢？内置声卡？USB 声卡？这不是 OpenMAX IL 的一部分；甚至没有办法列出音频设备，只有音频组件。

OpenMAX 有一个扩展机制，OpenMAX 实现者可以使用它来回答类似这样的问题。Broadcom 核心实现具有可用于设置音频目的(源)设备的扩展类型`OMX_CONFIG_BRCMAUDIODESTINATIONTYPE`(和`OMX_CONFIG_BRCMAUDIOSOURCETYPE`)。下面是执行此操作的代码:

```
void setOutputDevice(const char *name) {
   int32_t success = -1;
   OMX_CONFIG_BRCMAUDIODESTINATIONTYPE arDest;

   if (name && strlen(name) < sizeof(arDest.sName)) {
       setHeader(&arDest, sizeof(OMX_CONFIG_BRCMAUDIODESTINATIONTYPE));
       strcpy((char *)arDest.sName, name);

       err = OMX_SetParameter(handle, OMX_IndexConfigBrcmAudioDestination, &arDest);
       if (err != OMX_ErrorNone) {
           fprintf(stderr, "Error on setting audio destination\n");
           exit(1);
       }
   }
}

```

这是它再次陷入黑暗的地方。头文件`<IL/OMX_Broadcom.h>`声明`sName`的默认值是“local ”,但没有给出任何其他值。Raspberry Pi 论坛表示，这是指 3.5 毫米模拟音频输出，hdmi 是通过使用值“HDMI”来选择的没有记录其他值，并且 Broadcom OpenMAX IL 似乎不支持任何其他音频设备。特别是，当前的 Broadcom OpenMAX IL 组件不支持 USB 音频设备的输入或输出。因此，你不能使用 OpenMAX IL 在 Raspberry Pi 上进行音频捕获，因为它没有 Broadcom 支持的音频输入。

### 主循环

一旦所有端口都设置好，播放音频文件包括填充缓冲区，等待它们变空，然后再填充它们，直到数据结束。有两种可能的样式。

*   在主循环中填充缓冲区一次，然后在空缓冲区回调中继续填充和清空缓冲区。
*   在主循环中，不断地填充和清空缓冲区，在每次填充之间等待缓冲区清空。

Bellagio 示例使用了第一种技术。然而，1.2 规范说“…IL 客户端不应该从 IL 回调上下文中调用 IL 核心或组件函数”，所以这不是一个好的技术。Raspberry Pi 示例使用了第二种技术，但是使用了一个非标准调用来查找当时的等待时间和延迟。最好只设置更多的 pthreads 条件，并在这些条件上进行阻塞。

这将导致一个如下所示的主循环:

```
    emptyState = 1;
    for (;;) {
        int data_read = read(fd, inBuffers[0]->pBuffer, nBufferSize);
        inBuffers[0]->nFilledLen = data_read;
        inBuffers[0]->nOffset = 0;
        filesize -= data_read;
        if (data_read <= 0) {
            fprintf(stderr, "In the %s no more input data available\n", __func__);
            inBuffers[0]->nFilledLen=0;
            inBuffers[0]->nFlags = OMX_BUFFERFLAG_EOS;
            bEOS=OMX_TRUE;
            err = OMX_EmptyThisBuffer(handle, inBuffers[0]);
            break;
        }
        if(!bEOS) {
            fprintf(stderr, "Emptying again buffer %p %d bytes, %d to go\n", inBuffers[0], data_read, filesize);
            err = OMX_EmptyThisBuffer(handle, inBuffers[0]);
        }else {
            fprintf(stderr, "In %s Dropping Empty This buffer to Audio Dec\n", __func__);
        }
        waitForEmpty();
        printf("Waited for empty\n");
    }

    printf("Buffers emptied\n");

```

### 完整程序

完整的程序如下:

```
/**
   Based on code
   Copyright (C) 2007-2009 STMicroelectronics
   Copyright (C) 2007-2009 Nokia Corporation and/or its subsidiary(-ies).
   under the LGPL
*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/stat.h>
#include <pthread.h>

#include <OMX_Core.h>
#include <OMX_Component.h>
#include <OMX_Types.h>
#include <OMX_Audio.h>

#ifdef RASPBERRY_PI
#include <bcm_host.h>
#include <IL/OMX_Broadcom.h>
#endif

OMX_ERRORTYPE err;
OMX_HANDLETYPE handle;
OMX_VERSIONTYPE specVersion, compVersion;

int fd = 0;
unsigned int filesize;
static OMX_BOOL bEOS=OMX_FALSE;

OMX_U32 nBufferSize;
int nBuffers;

pthread_mutex_t mutex;
OMX_STATETYPE currentState = OMX_StateLoaded;
pthread_cond_t stateCond;

void waitFor(OMX_STATETYPE state) {
    pthread_mutex_lock(&mutex);
    while (currentState != state)
        pthread_cond_wait(&stateCond, &mutex);
    pthread_mutex_unlock(&mutex);
}

void wakeUp(OMX_STATETYPE newState) {
    pthread_mutex_lock(&mutex);
    currentState = newState;
    pthread_cond_signal(&stateCond);
    pthread_mutex_unlock(&mutex);
}

pthread_mutex_t empty_mutex;
int emptyState = 0;
OMX_BUFFERHEADERTYPE* pEmptyBuffer;
pthread_cond_t emptyStateCond;

void waitForEmpty() {
    pthread_mutex_lock(&empty_mutex);
    while (emptyState == 1)
        pthread_cond_wait(&emptyStateCond, &empty_mutex);
    emptyState = 1;
    pthread_mutex_unlock(&empty_mutex);
}

void wakeUpEmpty(OMX_BUFFERHEADERTYPE* pBuffer) {
    pthread_mutex_lock(&empty_mutex);
    emptyState = 0;
    pEmptyBuffer = pBuffer;
    pthread_cond_signal(&emptyStateCond);
    pthread_mutex_unlock(&empty_mutex);
}

void mutex_init() {
    int n = pthread_mutex_init(&mutex, NULL);
    if ( n != 0) {
        fprintf(stderr, "Can't init state mutex\n");
    }
    n = pthread_mutex_init(&empty_mutex, NULL);
    if ( n != 0) {
        fprintf(stderr, "Can't init empty mutex\n");
    }
}

static void display_help() {
    fprintf(stderr, "Usage: render input_file");
}

/** Gets the file descriptor's size
 * @return the size of the file. If size cannot be computed
 * (i.e. stdin, zero is returned)
 */
static int getFileSize(int fd) {

    struct stat input_file_stat;
    int err;

    /* Obtain input file length */
    err = fstat(fd, &input_file_stat);
    if(err){
        fprintf(stderr, "fstat failed",0);
        exit(-1);
    }
    return input_file_stat.st_size;
}

OMX_ERRORTYPE cEventHandler(
                            OMX_HANDLETYPE hComponent,
                            OMX_PTR pAppData,
                            OMX_EVENTTYPE eEvent,
                            OMX_U32 Data1,
                            OMX_U32 Data2,
                            OMX_PTR pEventData) {

    fprintf(stderr, "Hi there, I am in the %s callback\n", __func__);
    if(eEvent == OMX_EventCmdComplete) {
        if (Data1 == OMX_CommandStateSet) {
            fprintf(stderr, "Component State changed in ", 0);
            switch ((int)Data2) {
            case OMX_StateInvalid:
                fprintf(stderr, "OMX_StateInvalid\n", 0);
                break;
            case OMX_StateLoaded:
                fprintf(stderr, "OMX_StateLoaded\n", 0);
                break;
            case OMX_StateIdle:
                fprintf(stderr, "OMX_StateIdle\n",0);
                break;
            case OMX_StateExecuting:
                fprintf(stderr, "OMX_StateExecuting\n",0);
                break;
            case OMX_StatePause:
                fprintf(stderr, "OMX_StatePause\n",0);
                break;
            case OMX_StateWaitForResources:
                fprintf(stderr, "OMX_StateWaitForResources\n",0);
                break;
            }
            wakeUp((int) Data2);
        } else  if (Data1 == OMX_CommandPortEnable){

        } else if (Data1 == OMX_CommandPortDisable){

        }
    } else if(eEvent == OMX_EventBufferFlag) {
        if((int)Data2 == OMX_BUFFERFLAG_EOS) {

        }
    } else {
        fprintf(stderr, "Param1 is %i\n", (int)Data1);
        fprintf(stderr, "Param2 is %i\n", (int)Data2);
    }

    return OMX_ErrorNone;
}

OMX_ERRORTYPE cEmptyBufferDone(
                               OMX_HANDLETYPE hComponent,
                               OMX_PTR pAppData,
                               OMX_BUFFERHEADERTYPE* pBuffer) {

    fprintf(stderr, "Hi there, I am in the %s callback.\n", __func__);
    if (bEOS) {
        fprintf(stderr, "Buffers emptied, exiting\n");
    }
    wakeUpEmpty(pBuffer);
    fprintf(stderr, "Exiting callback\n");

    return OMX_ErrorNone;
}

OMX_CALLBACKTYPE callbacks  = { .EventHandler = cEventHandler,
                                .EmptyBufferDone = cEmptyBufferDone,
};

void printState() {
    OMX_STATETYPE state;
    err = OMX_GetState(handle, &state);
    if (err != OMX_ErrorNone) {
        fprintf(stderr, "Error on getting state\n");
        exit(1);
    }
    switch (state) {
    case OMX_StateLoaded: fprintf(stderr, "StateLoaded\n"); break;
    case OMX_StateIdle: fprintf(stderr, "StateIdle\n"); break;
    case OMX_StateExecuting: fprintf(stderr, "StateExecuting\n"); break;
    case OMX_StatePause: fprintf(stderr, "StatePause\n"); break;
    case OMX_StateWaitForResources: fprintf(stderr, "StateWiat\n"); break;
    default:  fprintf(stderr, "State unknown\n"); break;
    }
}

static void setHeader(OMX_PTR header, OMX_U32 size) {
    /* header->nVersion */
    OMX_VERSIONTYPE* ver = (OMX_VERSIONTYPE*)(header + sizeof(OMX_U32));
    /* header->nSize */
    *((OMX_U32*)header) = size;

    /* for 1.2
       ver->s.nVersionMajor = OMX_VERSION_MAJOR;
       ver->s.nVersionMinor = OMX_VERSION_MINOR;
       ver->s.nRevision = OMX_VERSION_REVISION;
       ver->s.nStep = OMX_VERSION_STEP;
    */
    ver->s.nVersionMajor = specVersion.s.nVersionMajor;
    ver->s.nVersionMinor = specVersion.s.nVersionMinor;
    ver->s.nRevision = specVersion.s.nRevision;
    ver->s.nStep = specVersion.s.nStep;
}

/**
 * Disable unwanted ports, or we can't transition to Idle state
 */
void disablePort(OMX_INDEXTYPE paramType) {
    OMX_PORT_PARAM_TYPE param;
    int nPorts;
    int startPortNumber;
    int n;

    setHeader(&param, sizeof(OMX_PORT_PARAM_TYPE));
    err = OMX_GetParameter(handle, paramType, &param);
    if(err != OMX_ErrorNone){
        fprintf(stderr, "Error in getting OMX_PORT_PARAM_TYPE parameter\n", 0);
        exit(1);
    }
    startPortNumber = ((OMX_PORT_PARAM_TYPE)param).nStartPortNumber;
    nPorts = ((OMX_PORT_PARAM_TYPE)param).nPorts;
    if (nPorts > 0) {
        fprintf(stderr, "Other has %d ports\n", nPorts);
        /* and disable it */
        for (n = 0; n < nPorts; n++) {
            err = OMX_SendCommand(handle, OMX_CommandPortDisable, n + startPortNumber, NULL);
            if (err != OMX_ErrorNone) {
                fprintf(stderr, "Error on setting port to disabled\n");
                exit(1);
            }
        }
    }
}

#ifdef RASPBERRY_PI
/* For the RPi name can be "hdmi" or "local" */
void setOutputDevice(const char *name) {
   int32_t success = -1;
   OMX_CONFIG_BRCMAUDIODESTINATIONTYPE arDest;

   if (name && strlen(name) < sizeof(arDest.sName)) {
       setHeader(&arDest, sizeof(OMX_CONFIG_BRCMAUDIODESTINATIONTYPE));
       strcpy((char *)arDest.sName, name);

       err = OMX_SetParameter(handle, OMX_IndexConfigBrcmAudioDestination, &arDest);
       if (err != OMX_ErrorNone) {
           fprintf(stderr, "Error on setting audio destination\n");
           exit(1);
       }
   }
}
#endif

void setPCMMode(int startPortNumber) {
    OMX_AUDIO_PARAM_PCMMODETYPE sPCMMode;

    setHeader(&sPCMMode, sizeof(OMX_AUDIO_PARAM_PCMMODETYPE));
    sPCMMode.nPortIndex = startPortNumber;
    sPCMMode.nSamplingRate = 48000;
    sPCMMode.nChannels;

    err = OMX_SetParameter(handle, OMX_IndexParamAudioPcm, &sPCMMode);
    if(err != OMX_ErrorNone){
        fprintf(stderr, "PCM mode unsupported\n");
        return;
    } else {
        fprintf(stderr, "PCM mode supported\n");
        fprintf(stderr, "PCM sampling rate %d\n", sPCMMode.nSamplingRate);
        fprintf(stderr, "PCM nChannels %d\n", sPCMMode.nChannels);
    }
}

int main(int argc, char** argv) {

    OMX_PORT_PARAM_TYPE param;
    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
    OMX_AUDIO_PORTDEFINITIONTYPE sAudioPortDef;
    OMX_AUDIO_PARAM_PORTFORMATTYPE sAudioPortFormat;
    OMX_AUDIO_PARAM_PCMMODETYPE sPCMMode;
    OMX_BUFFERHEADERTYPE **inBuffers;

#ifdef RASPBERRY_PI
    char *componentName = "OMX.broadcom.audio_render";
#endif
#ifdef LIM
    char *componentName = "OMX.limoi.alsa_sink";
#endif
    unsigned char name[OMX_MAX_STRINGNAME_SIZE];
    OMX_UUIDTYPE uid;
    int startPortNumber;
    int nPorts;
    int n;

# ifdef RASPBERRY_PI
    bcm_host_init();
# endif

    fprintf(stderr, "Thread id is %p\n", pthread_self());
    if(argc < 2){
        display_help();
        exit(1);
    }

    fd = open(argv[1], O_RDONLY);
    if(fd < 0){
        perror("Error opening input file\n");
        exit(1);
    }
    filesize = getFileSize(fd);

    err = OMX_Init();
    if(err != OMX_ErrorNone) {
        fprintf(stderr, "OMX_Init() failed\n", 0);
        exit(1);
    }
    /** Ask the core for a handle to the audio render component
     */
    err = OMX_GetHandle(&handle, componentName, NULL /*app private data */, &callbacks);
    if(err != OMX_ErrorNone) {
        fprintf(stderr, "OMX_GetHandle failed\n", 0);
        exit(1);
    }
    err = OMX_GetComponentVersion(handle, name, &compVersion, &specVersion, &uid);
    if(err != OMX_ErrorNone) {
        fprintf(stderr, "OMX_GetComponentVersion failed\n", 0);
        exit(1);
    }

    /** disable other ports */
    disablePort(OMX_IndexParamOtherInit);

    /** Get audio port information */
    setHeader(&param, sizeof(OMX_PORT_PARAM_TYPE));
    err = OMX_GetParameter(handle, OMX_IndexParamAudioInit, &param);
    if(err != OMX_ErrorNone){
        fprintf(stderr, "Error in getting OMX_PORT_PARAM_TYPE parameter\n", 0);
        exit(1);
    }
    startPortNumber = ((OMX_PORT_PARAM_TYPE)param).nStartPortNumber;
    nPorts = ((OMX_PORT_PARAM_TYPE)param).nPorts;
    if (nPorts > 1) {
        fprintf(stderr, "Render device has more than one port\n");
        exit(1);
    }

    /* Get and check port information */
    setHeader(&sPortDef, sizeof(OMX_PARAM_PORTDEFINITIONTYPE));
    sPortDef.nPortIndex = startPortNumber;
    err = OMX_GetParameter(handle, OMX_IndexParamPortDefinition, &sPortDef);
    if(err != OMX_ErrorNone){
        fprintf(stderr, "Error in getting OMX_PORT_DEFINITION_TYPE parameter\n", 0);
        exit(1);
    }
    if (sPortDef.eDomain != OMX_PortDomainAudio) {
        fprintf(stderr, "Port %d is not an audio port\n", startPortNumber);
        exit(1);
    }

    if (sPortDef.eDir != OMX_DirInput) {
        fprintf(stderr, "Port is not an input port\n");
        exit(1);
    }
    if (sPortDef.format.audio.eEncoding == OMX_AUDIO_CodingPCM) {
        fprintf(stderr, "Port encoding is PCM\n");
    }    else {
        fprintf(stderr, "Port has unknown encoding\n");
    }

    /* Create minimum number of buffers for the port */
    nBuffers = sPortDef.nBufferCountActual = sPortDef.nBufferCountMin;
    fprintf(stderr, "Number of bufers is %d\n", nBuffers);
    err = OMX_SetParameter(handle, OMX_IndexParamPortDefinition, &sPortDef);
    if(err != OMX_ErrorNone){
        fprintf(stderr, "Error in setting OMX_PORT_PARAM_TYPE parameter\n", 0);
        exit(1);
    }
    if (sPortDef.bEnabled) {
        fprintf(stderr, "Port is enabled\n");
    } else {
        fprintf(stderr, "Port is not enabled\n");
    }

    /* call to put state into idle before allocating buffers */
    err = OMX_SendCommand(handle, OMX_CommandStateSet, OMX_StateIdle, NULL);
    if (err != OMX_ErrorNone) {
        fprintf(stderr, "Error on setting state to idle\n");
        exit(1);
    }

    err = OMX_SendCommand(handle, OMX_CommandPortEnable, startPortNumber, NULL);
    if (err != OMX_ErrorNone) {
        fprintf(stderr, "Error on setting port to enabled\n");
        exit(1);
    }

    /* Configure buffers for the port */
    nBufferSize = sPortDef.nBufferSize;
    fprintf(stderr, "%d buffers of size is %d\n", nBuffers, nBufferSize);

    inBuffers = malloc(nBuffers * sizeof(OMX_BUFFERHEADERTYPE *));
    if (inBuffers == NULL) {
        fprintf(stderr, "Can't allocate buffers\n");
        exit(1);
    }

    for (n = 0; n < nBuffers; n++) {
        err = OMX_AllocateBuffer(handle, inBuffers+n, startPortNumber, NULL,
                                 nBufferSize);
        if (err != OMX_ErrorNone) {
            fprintf(stderr, "Error on AllocateBuffer in 1%i\n", err);
            exit(1);
        }
    }
    /* Make sure we've reached Idle state */
    waitFor(OMX_StateIdle);

    /* Now try to switch to Executing state */
    err = OMX_SendCommand(handle, OMX_CommandStateSet, OMX_StateExecuting, NULL);
    if(err != OMX_ErrorNone){
        exit(1);
    }

    /* One buffer is the minimum for Broadcom component, so use that */
    pEmptyBuffer = inBuffers[0];
    emptyState = 1;
    /* Fill and empty buffer */
    for (;;) {
        int data_read = read(fd, pEmptyBuffer->pBuffer, nBufferSize);
        pEmptyBuffer->nFilledLen = data_read;
        pEmptyBuffer->nOffset = 0;
        filesize -= data_read;
        if (data_read <= 0) {
            fprintf(stderr, "In the %s no more input data available\n", __func__);
            pEmptyBuffer->nFilledLen=0;
            pEmptyBuffer->nFlags = OMX_BUFFERFLAG_EOS;
            bEOS=OMX_TRUE;
        }
        fprintf(stderr, "Emptying again buffer %p %d bytes, %d to go\n", pEmptyBuffer, data_read, filesize);
        err = OMX_EmptyThisBuffer(handle, pEmptyBuffer);
        waitForEmpty();
        fprintf(stderr, "Waited for empty\n");
        if (bEOS) {
            fprintf(stderr, "Exiting loop\n");
            break;
        }
    }
    fprintf(stderr, "Buffers emptied\n");
    exit(0);
}

```

## 结论

Khronos 集团已经为低性能系统中的音频和视频制定了规范。这些目前被 Android 和 Raspberry Pi 使用。本章已经给出了这些规范和一些示例程序的介绍性概述。LIM 包自 2012 年以来就没有更新过，而 Bellagio 包自 2011 年以来就没有更新过，所以它们似乎没有得到积极的维护。另一方面，RPi 正在蓬勃发展，使用 GPU 的 OpenMAX 编程在我的书《Raspberry Pi GPU 音频视频编程》中有详细介绍。