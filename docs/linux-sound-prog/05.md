# 5.驱动

ALSA 是声卡的底层接口。如果您正在构建自己的声音服务器系统或编写设备驱动程序，那么您会对 ALSA 感兴趣。它位于当前大多数 Linux 系统的底部，所以要理解它们，你可能需要理解 ALSA 的方方面面。如果没兴趣，可以继续。

## 资源

以下是一些资源:

*   杰夫·特兰特的《ALSA 声音编程入门》( [`www.linuxjournal.com/article/6735?page=0,1`](http://www.linuxjournal.com/article/6735?page=0,1) )
*   近距离观察 ALSA ( [`www.volkerschatz.com/noise/alsa.html`](http://www.volkerschatz.com/noise/alsa.html) )
*   ALSA API ( [`www.alsa-project.org/alsa-doc/alsa-lib/`](http://www.alsa-project.org/alsa-doc/alsa-lib/)
*   ALSA 编程指南( [`www.suse.de/~mana/alsa090_howto.html`](http://www.suse.de/%7Emana/alsa090_howto.html) )
*   Linux sound HOWTO for ALSA 用户( [`http://techpatterns.com/forums/about1813.html`](http://techpatterns.com/forums/about1813.html) )来自技术模式

## 用户空间工具

ALSA 既是一组与声卡对话的 API，也是一组用户级应用程序，当然是使用 ALSA API 构建的。它包括查询和控制声卡以及从声卡上录音和播放的命令。本节考虑命令行工具。

### alsamixer

在终端窗口中运行，允许你选择声卡和控制这些卡上的接口。看起来像图 [5-1](#Fig1) 。

![A435426_1_En_5_Fig1_HTML.jpg](A435426_1_En_5_Fig1_HTML.jpg)

图 5-1。

alsamixer display

`amixer`是一个具有类似功能的命令行应用程序。

与第 [1](01.html) 章中描述的通用混音器功能相比，混音器功能非常有限:

*   设置输出和输入通道的回放和采集音量
*   使卡静音或取消静音

Stephen C. Phillips 的文档“具有 ALSA 的 Raspberry Pi 上的声音配置”( [`http://blog.scphillips.com/2013/01/sound-configuration-on-raspberry-pi-with-alsa/`](http://blog.scphillips.com/2013/01/sound-configuration-on-raspberry-pi-with-alsa/) )适用于所有其他 ALSA 系统，而不仅仅是 Raspberry Pi。

### alsactl

这是一个简单的 ALSA 配置控制程序。

### 扬声器测试

该命令允许您测试哪些输出会到达哪里。例如，对于五声道声音，运行以下命令:

```sh
speaker-test -t wav -c 5

```

这将在我的默认声卡上产生以下文本和音频:

```sh
speaker-test 1.0.25

Playback device is default
Stream parameters are 48000Hz, S16_LE, 5 channels
WAV file(s)
Rate set to 48000Hz (requested 48000Hz)
Buffer size range from 39 to 419430
Period size range from 12 to 139810
Using max buffer size 419428
Periods = 4
was set period_size = 104857
was set buffer_size = 419428
 0 - Front Left
 1 - Front Right
 2 - Rear Left
 3 - Rear Right
 4 - Center
Time per period = 12.948378

```

它还会向相关的说话者播放短语“左前方”等。

### 展平/圆角

这将播放一个文件或记录到一个文件中。要向扬声器播放麦克风，请使用:

```sh
arecord -r 44100 --buffer-size=128 | aplay --buffer-size=128

```

要将其记录到文件中，请使用以下命令:

```sh
arecord -f dat -d 20 -D hw:0,0 test.wav

```

这将在您第一个可用的声卡(`hw:0,0`)上以 DAT 质量录制一个 20 秒的 WAV 文件。DAT 质量定义为以 48kHz 采样速率和 16 位分辨率录制的立体声数字音频。

### 识别 ALSA 卡片

最简单的方法是使用`-l`选项运行`aplay`和`arecord`，如下所示:

```sh
arecord -l

      **** List of CAPTURE Hardware Devices ****
      card 0: PCH [HDA Intel PCH], device 0: STAC92xx Analog [STAC92xx Analog]
        Subdevices: 1/1
        Subdevice #0: subdevice #0
      card 2: Pro [SB X-Fi Surround 5.1 Pro], device 0: USB Audio [USB Audio]
        Subdevices: 1/1
        Subdevice #0: subdevice #0

aplay -l

      **** List of PLAYBACK Hardware Devices ****
      card 0: PCH [HDA Intel PCH], device 0: STAC92xx Analog [STAC92xx Analog]
        Subdevices: 1/1
        Subdevice #0: subdevice #0
      card 1: NVidia [HDA NVidia], device 3: HDMI 0 [HDMI 0]
        Subdevices: 1/1
        Subdevice #0: subdevice #0
      card 1: NVidia [HDA NVidia], device 7: HDMI 1 [HDMI 1]
        Subdevices: 1/1
        Subdevice #0: subdevice #0
      card 1: NVidia [HDA NVidia], device 8: HDMI 2 [HDMI 2]
        Subdevices: 1/1
        Subdevice #0: subdevice #0
      card 2: Pro [SB X-Fi Surround 5.1 Pro], device 0: USB Audio [USB Audio]
        Subdevices: 1/1
        Subdevice #0: subdevice #0
      card 2: Pro [SB X-Fi Surround 5.1 Pro], device 1: USB Audio [USB Audio #1]
        Subdevices: 1/1
        Subdevice #0: subdevice #0

```

### 设备名称

在诸如`qjackctl`的程序中，这些卡片通常被赋予诸如`hw:0`或`hw:2.2`的名称(参见第 [7 章](07.html))。术语`hw`指的是硬件设备。主号是指卡号，副号是指设备号。设备的名称在括号中。

设备也可能有别名。命令`aplay -L`列出了设备别名。例如，`hdmi`别名是在我的系统上的配置文件`/etc/asound.conf`中定义的。

```sh
pcm.hdmi0 {
        type hw
        card 1
        device 3 }

pcm.hdmi1 {
        type hw
        card 1
        device 7 }

pcm.hdmi2 {
        type hw
        card 1
        device 8 }

```

所以，`hdmi:0`其实就是`hw:1,3`:卡 1，设备 3。

可以定义其他别名来涵盖一系列设备，通过卡和设备进行参数化。例如，`/usr/share/alsa/pcm/surround40.conf`定义如下:

```sh
pcm.!surround40 {
        @args [ CARD DEV ]
        @args.CARD {
                type string
                default {
                        @func getenv
                        vars [
                                ALSA_SURROUND40_CARD
                                ALSA_PCM_CARD
                                ALSA_CARD
                        ]
                        default {
                                @func refer
                                name defaults.pcm.surround40.card
                        }
                }
        }
        @args.DEV {
                type integer
                default {
                        @func igetenv
                        vars [

                                ALSA_SURROUND40_DEVICE
                        ]
                        default {
                                @func refer
                                name defaults.pcm.surround40.device
                        }
                }
        }
        ...
}

```

例如，这将`surround40:CARD=PCH,DEV=0`定义为`hw:0,0`在我的系统上的别名(`PCH`是卡 0)。

我不知道从`card 1, device 3`到`hdmi:0`的简单编程方式。

您可以使用`aplay`和`arecord`显示别名集。

我的系统上来自`aplay -L`的输出如下:

```sh
default
    Default
sysdefault:CARD=PCH
    HDA Intel PCH, STAC92xx Analog
    Default Audio Device
front:CARD=PCH,DEV=0
    HDA Intel PCH, STAC92xx Analog
    Front speakers
surround40:CARD=PCH,DEV=0
    HDA Intel PCH, STAC92xx Analog
    4.0 Surround output to Front and Rear speakers
surround41:CARD=PCH,DE

V=0
    HDA Intel PCH, STAC92xx Analog
    4.1 Surround output to Front, Rear and Subwoofer speakers
surround50:CARD=PCH,DEV=0
    HDA Intel PCH, STAC92xx Analog
    5.0 Surround output to Front, Center and Rear speakers
surround51:CARD=PCH,DEV=0
    HDA Intel PCH, STAC92xx Analog
    5.1 Surround output to Front, Center, Rear and Subwoofer speakers
surround71:CARD=PCH,DEV=0
    HDA Intel PCH, STAC92xx Analog
    7.1 Surround output to Front, Center, Side, Rear and Woofer speakers
hdmi:CARD=NVidia,DEV=0
    HDA NVidia, HDMI 0
    HDMI Audio Output
hdmi:CARD=NVidia,DEV=1
    HDA NVidia, HDMI 1
    HDMI Audio Output
hdmi:CARD=NVidia,DEV=2
    HDA NVidia, HDMI 2
    HDMI Audio Output
sysdefault:CARD=Pro
    SB X-Fi Surround 5.1 Pro, USB Audio
    Default Audio Device
front:CARD=Pro,DEV=0
    SB X-Fi Surround 5.1 Pro, USB Audio
    Front speakers
surround40:CARD=Pro,DEV=0
    SB X-Fi Surround 5.1 Pro, USB Audio
    4.0 Surround output to Front and Rear speakers
surround41:CARD=Pro,DEV=0
    SB X-Fi Surround 5.1 Pro, USB Audio
    4.1 Surround output to Front, Rear and Subwoofer speakers
surround50:CARD=Pro,DEV=0
    SB X-Fi Surround 5.1 Pro, USB Audio
    5.0 Surround output to Front, Center and Rear speakers
surround51:CARD=Pro,DEV=0
    SB X-Fi Surround 5.1 Pro, USB Audio
    5.1 Surround output to Front, Center, Rear and Subwoofer speakers
surround71:CARD=Pro,DEV=0

    SB X-Fi Surround 5.1 Pro, USB Audio
    7.1 Surround output to Front, Center, Side, Rear and Woofer speakers
iec958:CARD=Pro,DEV=0
    SB X-Fi Surround 5.1 Pro, USB Audio
    IEC958 (S/PDIF) Digital Audio Output

```

`arecord -L`的输出如下:

```sh
default
    Default
sysdefault:CARD=PCH
    HDA Intel PCH, STAC92xx Analog
    Default Audio Device
front:CARD=PCH,DEV=0
    HDA Intel PCH, STAC92xx Analog
    Front speakers
surround40:CARD=PCH,DEV=0
    HDA Intel PCH, STAC92xx Analog
    4.0 Surround output to Front and Rear speakers
surround41:CARD=PCH,DEV=0
    HDA Intel PCH, STAC92xx Analog
    4.1 Surround output to Front, Rear and Subwoofer speakers
surround50:CARD=PCH,DEV=0
    HDA Intel PCH, STAC92xx Analog
    5.0 Surround output to Front, Center and Rear speakers
surround51:CARD=PCH,DEV=0
    HDA Intel PCH, STAC92xx Analog
    5.1 Surround output to Front, Center, Rear and Subwoofer speakers
surround71:CARD=PCH,DEV=0
    HDA Intel PCH, STAC92xx Analog
    7.1 Surround output to Front, Center, Side, Rear and Woofer speakers
sysdefault:CARD=Pro
    SB X-Fi Surround 5.1 Pro, USB Audio
    Default Audio Device
front:CARD=Pro,DEV=0
    SB X-Fi Surround 5.1 Pro, USB Audio
    Front speakers
surround40:CARD=Pro,DEV=0
    SB X-Fi Surround 5.1 Pro, USB Audio
    4.0 Surround output to Front and Rear speakers
surround41:CARD=Pro,DEV=0
    SB X-Fi Surround 5.1 Pro, USB Audio
    4.1 Surround output to Front, Rear and Subwoofer speakers
surround50:CARD=Pro,DEV=0
    SB X-Fi Surround 5.1 Pro, USB Audio
    5.0 Surround output to Front, Center and Rear speakers
surround51:CARD=Pr

o,DEV=0
    SB X-Fi Surround 5.1 Pro, USB Audio
    5.1 Surround output to Front, Center, Rear and Subwoofer speakers
surround71:CARD=Pro,DEV=0
    SB X-Fi Surround 5.1 Pro, USB Audio
    7.1 Surround output to Front, Center, Side, Rear and Woofer speakers
iec958:CARD=Pro,DEV=0
    SB X-Fi Surround 5.1 Pro, USB Audio
    IEC958 (S/PDIF) Digital Audio Output

```

### ALSA 配置文件

Volker Schatz 的这个教程解释了 ALSA 配置文件中正在发生的事情，真的很好:“近距离观察 ALSA”([`www.volkerschatz.com/noise/alsa.html`](http://www.volkerschatz.com/noise/alsa.html))。

请注意，默认的 ALSA 设备是`hw:0`。这是硬编码到 ALSA。但是它可以在配置文件中被覆盖。例如，这可以通过 PulseAudio 来实现(见下一章)。

### 阿尔萨信息

这将收集有关您的系统的信息，并将其保存在一个文件中。这是一个提供大量信息的 shell 脚本。这是一个被严重删减的信息子集:

```sh
upload=true&script=true&cardinfo=
!!################################
!!ALSA Information Script v 0.4.60
!!################################

!!Script ran on: Tue Jun 12 04:50:22 UTC 2012

!!Linux Distribution
!!------------------

Fedora release 16 (Verne) Fedora release 16 (Verne) Fedora release 16 (Verne) Fedora release 16 (Verne)

...

!!ALSA Version
!!------------

Driver version:     1.0.24
Library version:    1.0.25
Utilities version:  1.0.25

!!Loaded ALSA modules
!!-------------------

snd_hda_intel
snd_hda_intel

!!Sound Servers on this system
!!----------------------------

Pulseaudio:
      Installed - Yes (/usr/bin/pulseaudio)
      Running - Yes

Jack:
      Installed - Yes (/usr/bin/jackd)
      Running - No

!!Soundcards recognised by ALSA
!!-----------------------------

 0 [PCH            ]: HDA-Intel - HDA Intel PCH
                      HDA Intel PCH at 0xe6e60000 irq 47
 1 [NVidia         ]: HDA-Intel - HDA NVidia
                      HDA NVidia at 0xe5080000 irq 17

!!PCI Soundcards installed in the system
!!--------------------------------------

00:1b.0 Audio device
: Intel Corporation 6 Series/C200 Series Chipset Family High Definition Audio Controller (rev 04)
01:00.1 Audio device: nVidia Corporation HDMI Audio stub (rev a1)

...

!!HDA-Intel Codec information
!!---------------------------

...

Default PCM:
    rates [0x5e0]: 44100 48000 88200 96000 192000
    bits [0xe]: 16 20 24
    formats [0x1]: PCM

Node 0x0a [Pin Complex] wcaps 0x400583: Stereo Amp-In
  Control: name="Mic Jack Mode", index=0, device=0
    ControlAmp: chs=0, dir=In, idx=0, ofs=0
  Control: name="Mic Capture Volume", index=0, device=0
    ControlAmp: chs=3, dir=In, idx=0, ofs=0
  Control: name="Mic Jack", index=0, device=0
  Amp-In caps: N/A
  Amp-In vals:  [0x01 0x01]
  Pincap 0x0001173c: IN OUT HP EAPD Detect
    Vref caps: HIZ 50 GRD 80
  EAPD 0x2: EAPD
  Pin Default 0x03a11020: [Jack] Mic at Ext Left
    Conn = 1/8, Color = Black
    DefAssociation = 0x2, Sequence = 0x0
  Pin-ctls: 0x24: IN VREF_80
  Unsolicited: tag=03, enabled=1
  Power: setting=D0, actual=D0
  Connection: 3
     0x13* 0x14 0x1c

!!ALSA configuration files

!!------------------------

!!System wide config file (/etc/asound.conf)

#
# Place your global alsa-lib configuration here...
#

@hooks [
        {
                func load
                files [
                        "/etc/alsa/pulse-default.conf"
                ]
                errors false
        }
]

pcm.hdmi0 {
        type hw
        card 1
        device 3 }

pcm.hdmi1 {
        type hw
        card 1
        device 7 }

pcm.hdmi2 {
        type hw
        card 1
        device 8 }

!!Aplay/Arecord output
!!------------

APLAY

**** List of PLAYBACK Hardware Devices ****
card 0: PCH [HDA Intel PCH], device 0: STAC92xx Analog [STAC92xx Analog]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
card 1: NVidia [HDA NVidia], device 3: HDMI 0 [HDMI 0]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
card 1: NVidia [HDA NVidia], device 7: HDMI 1 [HDMI 1]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
card 1: NVidia [HDA NVidia], device 8: HDMI 2 [HDMI 2]
  Subdevices: 1/1
  Subdevice #0: subdevice #0

ARECORD

**** List of CAPTURE Hardware Devices ****
card 0: PCH [HDA Intel PCH], device 0: STAC92xx Analog [STAC92xx Analog]
  Subdevices: 1/1
  Subdevice #0: subdevice #0

!!Amixer output
!!-------------

!!-------Mixer controls for card 0 [PCH]

Card hw:0 'PCH'/'HDA Intel PCH at 0xe6e60000 irq 47'
  Mixer name    : 'IDT 92HD90BXX'
  Components    : 'HDA:111d76e7,10280494,00100102'
  Controls      : 19
  Simple ctrls  : 10
Simple mixer control 'Master',0
  Capabilities: pvolume pvolume-joined pswitch pswitch-joined penum
  Playback channels: Mono
  Limits: Playback 0 - 64
  Mono: Playback 62 [97%] [-1.50dB] [on]
Simple mixer control 'Headphone',0
  Capabilities: pvolume pswitch penum
  Playback channels: Front Left - Front Right
  Limits: Playback 0 - 64
  Mono:
  Front Left: Playback 64 [100%] [0.00dB] [on]
  Front Right: Playback 64 [100%] [0.00dB] [on]
Simple mixer control 'PCM',0
  Capabilities: pvolume penum
  Playback channels: Front Left - Front Right
  Limits: Playback 0 - 255
  Mono:
  Front Left: Playback 254 [100%] [0.20dB]
  Front Right: Playback 254 [100%] [0.20dB]
Simple mixer control 'Front',0
  Capabilities: pvolume pswitch penum
  Playback channels: Front Left - Front Right
  Limits: Playback 0 - 64
  Mono:
  Front Left: Playback 64 [100%] [0.00dB] [on]
  Front Right: Playback 64 [100%] [0.00dB] [on]
Simple mixer control 'Mic',0
  Capabilities: cvolume penum
  Capture channels: Front Left - Front Right
  Limits: Capture 0 - 3
  Front Left: Capture 1 [33%] [10.00dB]
  Front Right: Capture 1 [33%] [10.00dB]
Simple mixer control 'Mic Jack Mode',0
  Capabilities: enum
  Items: 'Mic In' 'Line In'
  Item0: 'Mic In'
Simple mixer control 'Beep',0
  Capabilities: pvolume pvolume-joined pswitch pswitch-joined penum
  Playback channels: Mono
  Limits: Playback 0 - 3
  Mono: Playback 1 [33%] [-12.00dB] [on]
Simple mixer control 'Capture',0
  Capabilities: cvolume cswitch penum
  Capture channels: Front Left - Front Right
  Limits: Capture 0 - 46
  Front Left: Capture 46 [100%] [30.00dB] [on]
  Front Right: Capture 46 [100%] [30.00dB] [on]
Simple mixer control 'Dock Mic',0
  Capabilities: cvolume penum
  Capture channels: Front Left - Front Right
  Limits: Capture 0 - 3
  Front Left: Capture 0 [0%] [0.00dB]
  Front Right: Capture 0 [0%] [0.00dB]
Simple mixer control 'Internal Mic',0
  Capabilities: cvolume penum
  Capture channels: Front Left - Front Right
  Limits: Capture 0 - 3
  Front Left: Capture 0 [0%] [0.00dB]
  Front Right: Capture 0 [0%] [0.00dB]

!!-------Mixer controls for card 1 [NVidia]

Card hw:1 'NVidia'/'HDA NVidia at 0xe5080000 irq 17'
  Mixer name    : 'Nvidia GPU 1c HDMI/DP'
  Components    : 'HDA:10de001c,10281494,00100100'
  Controls      : 18
  Simple ctrls  : 3
Simple mixer control 'IEC958',0
  Capabilities: pswitch pswitch-joined penum
  Playback channels: Mono
  Mono: Playback [on]
Simple mixer control 'IEC958',1
  Capabilities: pswitch pswitch-joined penum
  Playback channels: Mono
  Mono: Playback [off]
Simple mixer control 'IEC958',2
  Capabilities: pswitch pswitch-joined penum
  Playback channels: Mono
  Mono: Playback [off]

!!Alsactl output
!!-------------

--startcollapse--
state.PCH {
        control.1 {
                iface MIXER
                name 'Front Playback Volume'
                value.0 64
                value.1 64
                comment {
                        access 'read write'
                        type INTEGER
                        count 2
                        range '0 - 64'
                        dbmin -4800
                        dbmax 0
                        dbvalue.0 0
                        dbvalue.1 0
                }
        }
...

```

### 使用 ALSA 的应用程序

通过使用适当的命令行参数，许多应用程序可以直接使用 ALSA。

#### MPlayer

要使用 MPlayer 向 ALSA 设备播放文件，请使用如下代码:

```sh
mplayer -ao alsa:device=hw=1.0 -srate 48000  bryan.mp3

```

#### 可见光通讯

要使用 VLC 向 ALSA 设备播放文件，请使用如下代码:

```sh
vlc --aout alsa ...

```

#### 胆怯

要使用胆怯向 ALSA 设备播放文件，请使用如下代码:

```sh
timidity -Os ...

```

## 编程 ALSA

有几个关于编程 ALSA 的教程，包括保罗·戴维斯(他是杰克的领头人)的“使用 ALSA 音频 API 的教程”( [`http://equalarea.com/paul/alsa-audio.html`](http://equalarea.com/paul/alsa-audio.html) )。

你可以在 [`www.alsa-project.org/alsa-doc/alsa-lib/pcm.html`](http://www.alsa-project.org/alsa-doc/alsa-lib/pcm.html) 找到 API 的概述。杰夫·特兰特有一本《ALSA 声音编程入门》ALSA API 庞大而复杂，而且并不总是清楚它是如何组合在一起的，或者在哪里使用哪个部分。来自 ALSA 库 API ( [`www.alsa-project.org/main/index.php/ALSA_Library_API`](http://www.alsa-project.org/main/index.php/ALSA_Library_API) )。

目前设计的界面如下:

*   信息界面(`/proc/asound`)
*   控制界面(`/dev/snd/controlCX`)
*   ◆界面(`/dev/snd/mixerCXDX`)
*   PCM 接口(`/dev/snd/pcmCXDX`)
*   原始 MIDI 接口(`/dev/snd/midiCXDX`)
*   序列器接口(`/dev/snd/seq`)
*   定时器界面(`/dev/snd/timer`)

信息接口是 ALSA 用于设备信息和一些控制目的的接口。

控制接口用于调节声卡提供的音量和其他控制功能。

混音器接口允许应用程序以透明的方式共享音频设备的使用，是 ALSA 的主要功能之一。

PCM 接口允许通过配置机制定义虚拟和硬件设备。它是数字音频应用的常用接口。

raw MIDI 接口用于与 MIDI 设备进行低级交互，并直接处理 MIDI 事件。

音序器接口用于比原始 MIDI 接口更高级别的 MIDI 应用。

计时器接口旨在使用声音硬件中的内部计时器，并允许声音事件同步。

### 硬件设备信息

查找硬件卡和设备的信息是一个多步骤的操作。首先必须识别硬件卡。这是使用控制界面( [`www.alsa-project.org/alsa-doc/alsa-lib/group___control.html`](http://www.alsa-project.org/alsa-doc/alsa-lib/group___control.html) )功能完成的。使用的方法如下:

```sh
snd_card_next
snd_ctl_open
snd_ctl_pcm_next_device
snd_ctl_card_info_get_id
snd_ctl_card_info_get_name

```

卡片由 0 以上的整数标识。使用`snd_card_next`找到下一个卡号，使用种子值-1 找到第一张卡。然后用它的 ALSA 名字打开卡，比如`hw:0`、`hw:1`等等、`by snd_ctl_open`，其中填入一个`handle`值。反过来，该句柄用于使用`snd_ctl_card_info`填充卡片信息，并使用`snd_ctl_card_info_get_name`等函数从该句柄中提取字段。在接下来的程序中，这将提供如下信息:

```sh
card 0: PCH [HDA Intel PCH]

```

有关更多信息，您需要切换到该卡的 PCM 功能。链接控制和 PCM 接口的函数是`snd_ctl_pcm_info`，它用 PCM 相关信息填充类型为`snd_pcm_info_t`的结构。不幸的是，该功能在 ALSA 文档的控制接口和 PCM 接口部分都没有记载，而是在`control.c`下的文件部分。结构`snd_pcm_info_t`在 PCM 接口( [`www.alsa-project.org/alsa-doc/alsa-lib/group___p_c_m.html#g2226bdcc6e780543beaadc319332e37b`](http://www.alsa-project.org/alsa-doc/alsa-lib/group___p_c_m.html#g2226bdcc6e780543beaadc319332e37b) )部分中几乎没有记载，并且只有几个感兴趣的字段。(结构见本站: [`www.qnx.com/developers/docs/6.4.0/neutrino/audio/libs/snd_pcm_info_t.html`](http://www.qnx.com/developers/docs/6.4.0/neutrino/audio/libs/snd_pcm_info_t.html) )。)使用 PCM 功能`snd_pcm_info_get_id`和`snd_pcm_info_get_name`访问这些字段。

`snd_pcm_info_t`结构的主要价值在于它是 PCM 流( [`www.alsa-project.org/alsa-doc/alsa-lib/group___p_c_m___info.html`](http://www.alsa-project.org/alsa-doc/alsa-lib/group___p_c_m___info.html) )函数的主要参数。特别是，这允许您获得设备和子设备以及关于它们的信息。

查找和显示卡和硬件设备信息的程序是`aplay-l.c`，如下图所示:

```sh
/**
 * aplay-l.c
 *
 * Code from aplay.c
 *
 * does the same as aplay -l
 * http://alsa-utils.sourcearchive.com/documentation/1.0.15/aplay_8c-source.html
 */

/*
 * Original notice:
 *
 *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
 *  Based on vplay program by Michael Beck
 *
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <alsa/asoundlib.h>
#include <locale.h>

// used by gettext for i18n, not needed here
#define _(STR) STR

static void device_list(snd_pcm_stream_t stream)
{
      snd_ctl_t *handle;
      int card, err, dev, idx;
      snd_ctl_card_info_t *info;
      snd_pcm_info_t *pcminfo;
      snd_ctl_card_info_alloca(&info);
      snd_pcm_info_alloca(&pcminfo);

      card = -1;
      if (snd_card_next(&card) < 0 || card < 0) {
            error(_("no soundcards found..."));
            return;
      }
      printf(_("**** List of %s Hardware Devices ****\n"),
             snd_pcm_stream_name(stream));
      while (card >= 0) {
            char name[32];
            sprintf(name, "hw:%d", card);
            if ((err = snd_ctl_open(&handle, name, 0)) < 0) {
                  error("control open (%i): %s", card, snd_strerror(err));
                  goto next_card;
            }
            if ((err = snd_ctl_card_info(handle, info)) < 0) {
                  error("control hardware info (%i): %s", card, snd_strerror(err));
                  snd_ctl_close(handle);
                  goto next_card;
            }
            dev = -1;
            while (1) {
                  unsigned int count;
                  if (snd_ctl_pcm_next_device(handle, &dev)<0)
                        error("snd_ctl_pcm_next_device");
                  if (dev < 0)
                        break;
                  snd_pcm_info_set_device(pcminfo, dev);
                  snd_pcm_info_set_subdevice(pcminfo, 0);
                  snd_pcm_info_set_stream(pcminfo, stream);
                  if ((err = snd_ctl_pcm_info(handle, pcminfo)) < 0) {
                        if (err != -ENOENT)
                              error("control digital audio info (%i): %s", card, snd_strerror(err));
                        continue;
                  }
                  printf(_("card %i: [%s,%i] %s [%s], device %i: %s [%s]\n"),
                         card, name, dev, snd_ctl_card_info_get_id(info), snd_ctl_card_info_get_name(info),
                        dev,
                        snd_pcm_info_get_id(pcminfo),
                        snd_pcm_info_get_name(pcminfo));
                  count = snd_pcm_info_get_subdevices_count(pcminfo);
                  printf( _("  Subdevices: %i/%i\n"),
                        snd_pcm_info_get_subdevices_avail(pcminfo), count);
                  for (idx = 0; idx < (int)count; idx++) {
                        snd_pcm_info_set_subdevice(pcminfo, idx);
                        if ((err = snd_ctl_pcm_info(handle, pcminfo)) < 0) {
                              error("control digital audio playback info (%i): %s", card, snd_strerror(err));
                        } else {
                              printf(_("  Subdevice #%i: %s\n"),
                                    idx, snd_pcm_info_get_subdevice_name(pcminfo));
                        }
                  }
            }
            snd_ctl_close(handle);
      next_card:
            if (snd_card_next(&card) < 0) {
                  error("snd_card_next");
                  break;
            }
      }
}

main (int argc, char *argv[])
{
  device_list(SND_PCM_STREAM_CAPTURE);
  device_list(SND_PCM_STREAM_PLAYBACK);
}

```

以下是在我的系统上运行`aplay-l`的输出:

```sh
**** List of CAPTURE Hardware Devices ****
card 0: [hw:0,0] PCH [HDA Intel PCH], device 0: STAC92xx Analog [STAC92xx Analog]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
**** List of PLAYBACK Hardware Devices ****
card 0: [hw:0,0] PCH [HDA Intel PCH], device 0: STAC92xx Analog [STAC92xx Analog]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
card 1: [hw:1,3] NVidia [HDA NVidia], device 3: HDMI 0 [HDMI 0]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
card 1: [hw:1,7] NVidia [HDA NVidia], device 7: HDMI 1 [HDMI 1]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
card 1: [hw:1,8] NVidia [HDA NVidia], device 8: HDMI 2 [HDMI 2]
  Subdevices: 1/1
  Subdevice #0: subdevice #0

```

### PCM 设备信息

您可以使用`aplay -L`从设备获取 PCM 别名信息。这使用了来自设备 API 的“提示”机制。请注意，该程序负责释放由 ALSA 库分配的内存。这意味着，如果返回一个字符串或表，那么不仅要遍历字符串/表，还要保留一个指向字符串/表开头的指针，以便可以释放它。

这个的来源是`aplay-L.c`，如下图所示:

```sh
/**
 * aplay-L.c
 *
 * Code from aplay.c
 * does aplay -L
 * http://alsa-utils.sourcearchive.com/documentation/1.0.15/aplay_8c-source.html
 */

/*
 * Original notice:
 *
 *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
 *  Based on vplay program by Michael Beck
 *
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <alsa/asoundlib.h>
#include <locale.h>

#define _(STR) STR

static void pcm_list(snd_pcm_stream_t stream )
{
      void **hints, **n;
      char *name, *descr, *descr1, *io;
      const char *filter;

      if (snd_device_name_hint(-1, "pcm", &hints) < 0)
            return;
      n = hints;
      filter = stream == SND_PCM_STREAM_CAPTURE ? "Input" : "Output";
      while (*n != NULL) {
            name = snd_device_name_get_hint(*n, "NAME");
            descr = snd_device_name_get_hint(*n, "DESC");
            io = snd_device_name_get_hint(*n, "IOID");
            if (io != NULL && strcmp(io, filter) == 0)
                  goto __end;
            printf("%s\n", name);
            if ((descr1 = descr) != NULL) {
                  printf("    ");
                  while (*descr1) {
                        if (*descr1 == '\n')
                              printf("\n    ");
                        else
                              putchar(*descr1);
                        descr1++;
                  }
                  putchar('\n');
            }
            __end:
                  if (name != NULL)
                        free(name);
            if (descr != NULL)
                  free(descr);
            if (io != NULL)
                  free(io);
            n++;
      }
      snd_device_name_free_hint(hints);
}

main (int argc, char *argv[])
{
  printf("*********** CAPTURE ***********\n");
  pcm_list(SND_PCM_STREAM_CAPTURE);

  printf("\n\n*********** PLAYBACK ***********\n");
  pcm_list(SND_PCM_STREAM_PLAYBACK);
}

```

以下是在我的系统上运行`aplay-L`的输出:

```sh
*********** CAPTURE ***********
default
    Default
sysdefault:CARD=PCH
    HDA Intel PCH, STAC92xx Analog
    Default Audio Device
front:CARD=PCH,DEV=0
    HDA Intel PCH, STAC92xx Analog
    Front speakers
surround40:CARD=PCH,DEV=0
    HDA Intel PCH, STAC92xx Analog
    4.0 Surround output to Front and Rear speakers
surround41:CARD=PCH,DEV=0
    HDA Intel PCH, STAC92xx Analog
    4.1 Surround output to Front, Rear and Subwoofer speakers
surround50:CARD=PCH,DEV=0
    HDA Intel PCH, STAC92xx Analog
    5.0 Surround output to Front, Center and Rear speakers
surround51:CARD=PCH,DEV=0
    HDA Intel PCH, STAC92xx Analog
    5.1 Surround output to Front, Center, Rear and Subwoofer speakers
surround71:CARD=PCH,DEV=0
    HDA Intel PCH, STAC92xx Analog
    7.1 Surround output to Front, Center, Side, Rear and Woofer speakers
hdmi:CARD=NVidia,DEV=0
    HDA NVidia, HDMI 0
    HDMI Audio Output
hdmi:CARD=NVidia,DEV=1
    HDA NVidia, HDMI 1
    HDMI Audio Output
hdmi:CARD=NVidia,DEV=2
    HDA NVidia, HDMI 2
    HDMI Audio Output

*********** PLAYBACK ***********
null
    Discard all samples (playback) or generate zero samples (capture)
pulse
    PulseAudio Sound Server
default
    Default
sysdefault:CARD=PCH
    HDA Intel PCH, STAC92xx Analog
    Default Audio Device
front:CARD=PCH,DEV=0
    HDA Intel PCH, STAC92xx Analog
    Front speakers
surround40:CARD=PCH,DEV=0
    HDA Intel PCH, STAC92xx Analog
    4.0 Surround output to Front and Rear speakers
surround41:CARD=PCH,DEV=0
    HDA Intel PCH, STAC92xx Analog
    4.1 Surround output to Front, Rear and Subwoofer speakers
surround50:CARD=PCH,DEV=0
    HDA Intel PCH, STAC92xx Analog
    5.0 Surround output to Front, Center and Rear speakers
surround51:CARD=PCH,DEV=0
    HDA Intel PCH, STAC92xx Analog
    5.1 Surround output to Front, Center, Rear and Subwoofer speakers
surround71:CARD=PCH,DEV=0
    HDA Intel PCH, STAC92xx Analog
    7.1 Surround output to Front, Center, Side, Rear and Woofer speakers

```

请注意，这不包括“插头”设备，如`plughw:0`。似乎无法访问插头设备列表。

### 配置空间信息

除了一般特性之外，每个 PCM 器件都能够支持一系列参数，如通道数量、采样速率等。完整的参数集和范围构成了每个设备的“配置空间”。例如，一个设备可以支持两个到六个通道以及多种不同的采样速率。这两个参数形成一个二维空间。全套形成一个 n 维空间。

ALSA 具有查询该空间并在该空间内设置值的功能。空间由`snd_pcm_hw_params_any`初始化。求参数的可能值，有叫`snd_pcm_hw_params_get`之类的函数。

不同的参数如下:

通道

*   这是支持的声道数(零表示单声道，以此类推)。

速度

*   这是以赫兹为单位的采样率，即每秒采样数。典型地，CD 音频具有每通道 44，100Hz 的采样率，因此每个通道每秒具有 44，100 个样本。

框架

*   每个帧包含每个通道的一个样本。立体声音频在每帧中将包含两个样本。帧速率与采样速率相同。也就是说，假设立体声音频的采样率是 44，100Hz。那么每个通道每秒将有 44，100 个样本。但是也将是每秒 44，100 帧，因此两个通道的总密度将是每秒 88，200 个样本。

周期时间

*   这是刷新缓冲区的硬件中断之间的时间，以微秒计。

期间大小

*   这是每次硬件中断之间的帧数。这些以如下方式相关联:

    ```sh
    Period time = period size x time per frame
                = period size x time per sample
                = period size / sampling rate

    ```

例如，如果采样速率为 48000Hz 立体声，周期大小为 8，192 帧，则硬件中断之间的时间为 8192 / 48000 秒= 170.5 毫秒。

周期

*   这是每个缓冲区的周期数。

缓冲时间

*   这是一个缓冲的时间。

缓冲区大小

*   这是以帧为单位的缓冲区大小。还是那句话，有关系。

    ```sh
    Time of one buffer = buffer size in frames x time for one frame
                       = buffer size x number of channels x time for one sample
                       = buffer size x number of channels / sample rate

    ```

缓冲区大小应该是周期大小的倍数，通常是周期大小的两倍。

有关更多示例，请参见 FramesPeriods ( [`www.alsa-project.org/main/index.php/FramesPeriods`](http://www.alsa-project.org/main/index.php/FramesPeriods) )。

下面是从初始状态求各种参数的取值范围的程序；它叫做`device-info.c`:

```sh
/**
 * Jan Newmarch
 */

#include <stdio.h>
#include <stdlib.h>
#include <alsa/asoundlib.h>

void info(char *dev_name, snd_pcm_stream_t stream) {
  snd_pcm_hw_params_t *hw_params;
  int err;
  snd_pcm_t *handle;
  unsigned int max;
  unsigned int min;
  unsigned int val;
  unsigned int dir;
  snd_pcm_uframes_t frames;

  if ((err = snd_pcm_open (&handle, dev_name, stream, 0)) < 0) {
    fprintf (stderr, "cannot open audio device %s (%s)\n",
             dev_name,
             snd_strerror (err));
    return;
  }

  if ((err = snd_pcm_hw_params_malloc (&hw_params)) < 0) {
    fprintf (stderr, "cannot allocate hardware parameter structure (%s)\n",
             snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params_any (handle, hw_params)) < 0) {
    fprintf (stderr, "cannot initialize hardware parameter structure (%s)\n",
             snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params_get_channels_max(hw_params, &max)) < 0) {
    fprintf (stderr, "cannot  (%s)\n",
             snd_strerror (err));
    exit (1);
  }
  printf("max channels %d\n", max);

  if ((err = snd_pcm_hw_params_get_channels_min(hw_params, &min)) < 0) {
    fprintf (stderr, "cannot get channel info  (%s)\n",
             snd_strerror (err));
    exit (1);
  }
  printf("min channels %d\n", min);

  /*
  if ((err = snd_pcm_hw_params_get_sbits(hw_params)) < 0) {
      fprintf (stderr, "cannot get bits info  (%s)\n",
               snd_strerror (err));
      exit (1);
  }
  printf("bits %d\n", err);
  */

  if ((err = snd_pcm_hw_params_get_rate_min(hw_params, &val, &dir)) < 0) {
    fprintf (stderr, "cannot get min rate (%s)\n",
             snd_strerror (err));
    exit (1);
  }
  printf("min rate %d hz\n", val);

  if ((err = snd_pcm_hw_params_get_rate_max(hw_params, &val, &dir)) < 0) {
    fprintf (stderr, "cannot get max rate (%s)\n",
             snd_strerror (err));
    exit (1);
  }
  printf("max rate %d hz\n", val);

  if ((err = snd_pcm_hw_params_get_period_time_min(hw_params, &val, &dir)) < 0) {
    fprintf (stderr, "cannot get min period time  (%s)\n",
             snd_strerror (err));
    exit (1);
  }
  printf("min period time %d usecs\n", val);

  if ((err = snd_pcm_hw_params_get_period_time_max(hw_params, &val, &dir)) < 0) {
    fprintf (stderr, "cannot  get max period time  (%s)\n",
             snd_strerror (err));
    exit (1);
  }
  printf("max period time %d usecs\n", val);

  if ((err = snd_pcm_hw_params_get_period_size_min(hw_params, &frames, &dir)) < 0) {
    fprintf (stderr, "cannot  get min period size  (%s)\n",
             snd_strerror (err));
    exit (1);
  }
  printf("min period size in frames %d\n", frames);

  if ((err = snd_pcm_hw_params_get_period_size_max(hw_params, &frames, &dir)) < 0) {
    fprintf (stderr, "cannot  get max period size (%s)\n",
             snd_strerror (err));
    exit (1);
  }
  printf("max period size in frames %d\n", frames);

  if ((err = snd_pcm_hw_params_get_periods_min(hw_params, &val, &dir)) < 0) {
    fprintf (stderr, "cannot  get min periods  (%s)\n",
             snd_strerror (err));
    exit (1);
  }
  printf("min periods per buffer %d\n", val);

  if ((err = snd_pcm_hw_params_get_periods_max(hw_params, &val, &dir)) < 0) {
    fprintf (stderr, "cannot  get min periods (%s)\n",
             snd_strerror (err));
    exit (1);
  }
  printf("max periods per buffer %d\n", val);

  if ((err = snd_pcm_hw_params_get_buffer_time_min(hw_params, &val, &dir)) < 0) {
    fprintf (stderr, "cannot get min buffer time (%s)\n",
             snd_strerror (err));
    exit (1);
  }
  printf("min buffer time %d usecs\n", val);

  if ((err = snd_pcm_hw_params_get_buffer_time_max(hw_params, &val, &dir)) < 0) {
    fprintf (stderr, "cannot get max buffer time  (%s)\n",
             snd_strerror (err));
    exit (1);
  }
  printf("max buffer time %d usecs\n", val);

  if ((err = snd_pcm_hw_params_get_buffer_size_min(hw_params, &frames)) < 0) {
    fprintf (stderr, "cannot get min buffer size (%s)\n",
             snd_strerror (err));
    exit (1);
  }
  printf("min buffer size in frames %d\n", frames);

  if ((err = snd_pcm_hw_params_get_buffer_size_max(hw_params, &frames)) < 0) {
    fprintf (stderr, "cannot get max buffer size  (%s)\n",
             snd_strerror (err));
    exit (1);
  }
  printf("max buffer size in frames %d\n", frames);
}

main (int argc, char *argv[])
{
  int i;
  int err;
  int buf[128];
  FILE *fin;
  size_t nread;
  unsigned int rate = 44100;

  if (argc != 2) {
    fprintf(stderr, "Usage: %s card\n", argv[0]);
    exit(1);
  }

  printf("*********** CAPTURE ***********\n");
  info(argv[1], SND_PCM_STREAM_CAPTURE);

  printf("*********** PLAYBACK ***********\n");
  info(argv[1], SND_PCM_STREAM_PLAYBACK);

  exit (0);
}

```

以下是我的系统上`device-info hw:0`的输出:

```sh
*********** CAPTURE ***********
max channels 2
min channels 2
min rate 44100 hz
max rate 192000 hz
min period time 83 usecs
max period time 11888617 usecs
min period size in frames 16
max period size in frames 524288
min periods per buffer 2
max periods per buffer 32
min buffer time 166 usecs
max buffer time 23777234 usecs
min buffer size in frames 32
max buffer size in frames 1048576
*********** PLAYBACK ***********
max channels 2
min channels 2
min rate 44100 hz
max rate 192000 hz
min period time 83 usecs
max period time 11888617 usecs
min period size in frames 16
max period size in frames 524288
min periods per buffer 2
max periods per buffer 32
min buffer time 166 usecs
max buffer time 23777234 usecs
min buffer size in frames 32
max buffer size in frames 1048576

```

这个程序适用于任何 ALSA 设备，包括“插头”设备。以下来自`device-info plughw:0`的输出显示了软件包装器如何给出更大范围的可能值:

```sh
*********** CAPTURE ***********
max channels 10000
min channels 1
min rate 4000 hz
max rate -1 hz
min period time 83 usecs
max period time 11888617 usecs
min period size in frames 0
max period size in frames -1
min periods per buffer 0
max periods per buffer -1
min buffer time 1 usecs
max buffer time -1 usecs
min buffer size in frames 1
max buffer size in frames -2
*********** PLAYBACK ***********
max channels 10000
min channels 1
min rate 4000 hz
max rate -1 hz
min period time 83 usecs
max period time 11888617 usecs
min period size in frames 0
max period size in frames -1
min periods per buffer 0
max periods per buffer -1
min buffer time 1 usecs
max buffer time -1 usecs
min buffer size in frames 1
max buffer size in frames -2

```

也可以用别名设备运行，比如`device-info surround40`。

### ALSA 初始化

逐行分解在( [`http://soundprogramming.net/programming_apis/alsa_tutorial_1_initialization`](http://soundprogramming.net/programming_apis/alsa_tutorial_1_initialization) )。它解释了后面程序中的许多公共代码。

### 将音频捕获到文件中

以下程序摘自保罗·戴维斯的《ALSA 音频 API 使用教程》( [`http://equalarea.com/paul/alsa-audio.html`](http://equalarea.com/paul/alsa-audio.html) ):

```sh
/**
 * alsa_capture.c
 */

/* Copyright © 2002
 * Paul Davis
 * under the GPL license
 */

/**
 * Paul Davis
 * http://equalarea.com/paul/alsa-audio.html#howto
 */

/**
 * Jan Newmarch
 */

#include <stdio.h>
#include <stdlib.h>
#include <alsa/asoundlib.h>
#include <signal.h>

#define BUFSIZE 128
#define RATE 44100

FILE *fout = NULL;

/*
 * quit on ctrl-c
 */
void sigint(int sig) {
  if (fout != NULL) {
    fclose(fout);
  }
  exit(1);
}

main (int argc, char *argv[])
{
  int i;
  int err;
  short buf[BUFSIZE];
  snd_pcm_t *capture_handle;
  snd_pcm_hw_params_t *hw_params;
  snd_pcm_format_t rate = RATE;
  int nread;

  if (argc != 3) {
    fprintf(stderr, "Usage: %s cardname file\n", argv[0]);
    exit(1);
  }

  if ((fout = fopen(argv[2], "w")) == NULL) {
    fprintf(stderr, "Can't open %s for writing\n", argv[2]);
    exit(1);
  }

  signal(SIGINT, sigint);

  if ((err = snd_pcm_open (&capture_ha

ndle, argv[1], SND_PCM_STREAM_CAPTURE, 0)) < 0) {
    fprintf (stderr, "cannot open audio device %s (%s)\n",
             argv[1],
             snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params_malloc (&hw_params)) < 0) {
    fprintf (stderr, "cannot allocate hardware parameter structure (%s)\n",
             snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params_any (capture_handle, hw_params)) < 0) {
    fprintf (stderr, "cannot initialize hardware parameter structure (%s)\n",
             snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params_set_access (capture_handle, hw_params, SND_PCM_ACCESS_RW_INTERLEAVED)) < 0) {
    fprintf (stderr, "cannot set access type (%s)\n",
             snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params_set_format (capture_handle, hw_params, SND_PCM_FORMAT_S16_LE)) < 0) {
    fprintf (stderr, "cannot set sample format (%s)\n",
             snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params_set_rate_near (capture_handle, hw_params, &rate, 0)) < 0) {
    fprintf (stderr, "cannot set sample rate (%s)\n",
             snd_strerror (err));
    exit (1);
  }
  fprintf(stderr, "rate set to %d\n", rate);

  if ((err = snd_pcm_hw_params_set_channels (capture_handle, hw_params, 2)) < 0) {
    fprintf (stderr, "cannot set channel count (%s)\n",
             snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params (capture_handle, hw_params)) < 0) {
    fprintf (stderr, "cannot set parameters (%s)\n",
             snd_strerror (err));
    exit (1);
  }

  snd_pcm_hw_params_free (h

w_params);

  /*
  if ((err = snd_pcm_prepare (capture_handle)) < 0) {
    fprintf (stderr, "cannot prepare audio interface for use (%s)\n",
             snd_strerror (err));
    exit (1);
  }
  */

  while (1) {
    if ((nread = snd_pcm_readi (capture_handle, buf, BUFSIZE)) < 0) {
      fprintf (stderr, "read from audio interface failed (%s)\n",
               snd_strerror (err));
      /* recover */
      snd_pcm_prepare(capture_handle);
    } else {
      fwrite(buf, sizeof(short), nread, fout);
    }
  }

  snd_pcm_close (capture_handle);
  exit(0);
}

```

### 播放文件中的音频

要捕获或播放音频，必须像前面的示例一样先打开设备。然后创建一个配置空间，通过设置各种参数的值来缩小空间。访问类型决定了样本是否交错。格式决定了样本的大小以及它们是小端还是大端。如果无法设置请求的值，所有这些都将返回错误。

一些参数在设置时需要小心。例如，采样速率有一系列可能的值，但并非所有这些值都受支持。可以使用`snd_pcm_hw_params_set_rate`请求特定的价格。但是如果请求的速率是不可能的，那么将返回一个错误。有几种方法可以避免这种情况。

*   尝试多种速率，直到找到一种受支持的速率。
*   用`snd_pcm_hw_params_test_rate`测试是否支持某个速率。
*   用`snd_pcm_hw_params_set_rate_near`请求 ALSA 给出最接近的支持率。实际选择的速率在速率参数中设置。
*   不要使用硬件设备，如`hw:0`，使用插头设备，如`plughw:0`，它将通过重采样支持更多的值。

最后，一旦为配置空间设置了参数，受限空间就由`snd_pcm_hw_params`安装到设备上。

PCM 设备上的调用将导致设备中发生状态变化。打开后，设备处于`SND_PCM_STATE_OPEN`状态。设置硬件配置后，设备处于`SND_PCM_STATE_PREPARE`状态。应用程序可以使用`snd_pcm_start`调用来读写数据。如果发生超限运行或欠载运行，状态可能下降到`SND_PCM_STATE_XRUN`，然后需要调用`snd_pcm_prepare`将其恢复到`SND_PCM_STATE_PREPARE`。

调用`readi`读取交错数据。

以下程序摘自保罗·戴维斯的《ALSA 音频 API 使用教程》( [`http://equalarea.com/paul/alsa-audio.html`](http://equalarea.com/paul/alsa-audio.html) ):

```sh
/**
 * alsa_playback.c
 */

/*
 * Copyright © 2002
 * Paul Davis
 * under the GPL license
 */

/**
 * Paul Davis
 * http://equalarea.com/paul/alsa-audio.html#howto
 */

/**
 * Jan Newmarch
 */

#include <stdio.h>
#include <stdlib.h>
#include <alsa/asoundlib.h>

main (int argc, char *argv[])
{
  int i;
  int err;
  int buf[128];
  snd_pcm_t *playback_handle;
  snd_pcm_hw_params_t *hw_params;
  FILE *fin;
  size_t nread;
  unsigned int rate = 44100;

  if (argc != 3) {
    fprintf(stderr, "Usage: %s card file\n", argv[0]);
    exit(1);
  }

  if ((err = snd_pcm_open (&playback_handle, argv[1], SND_PCM_STREAM_PLAYBACK, 0)) < 0) {
    fprintf (stderr, "cannot open audio device %s (%s)\n",
             argv[1],
             snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params_malloc (&hw_params)) < 0) {
    fprintf (stderr, "cannot allocate hardware parameter structure (%s)\n",
             snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params_any (playback_handle, hw_params)) < 0) {
    fprintf (stderr, "cannot initialize hardware parameter structure (%s)\n",
             snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params_set_access (playback_handle, hw_params, SND_PCM_ACCESS_RW_INTERLEAVED)) < 0) {
    fprintf (stderr, "cannot set access type (%s)\n",
             snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params_set_format (playback_handle, hw_params, SND_PCM_FORMAT_S16_LE)) < 0) {
    fprintf (stderr, "cannot set sample format (%s)\n",
             snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params_set_rate_near (playback_handle, hw_params, &rate, 0)) < 0) {
    fprintf (stderr, "cannot set sample rate (%s)\n",
             snd_strerror (err));
    exit (1);
  }
  printf("Rate set to %d\n", rate);

  if ((err = snd_pcm_hw_params_set_channels (playback_handle, hw_params, 2)) < 0) {
    fprintf (stderr, "cannot set channel count (%s)\n",
             snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params (playback_handle, hw_params)) < 0) {
    fprintf (stderr, "cannot set parameters (%s)\n",
             snd_strerror (err));
    exit (1);
  }

  snd_pcm_hw_params_free (hw_params);

  /*
  if ((err = snd_pcm_prepare (playback_handle)) < 0) {
    fprintf (stderr, "cannot prepare audio interface for use (%s)\n",
             snd_strerror (err));
    exit (1);
  }
  */

  if ((fin = fopen(argv[2], "r")) == NULL) {
      fprintf(stderr, "Can't open %s for reading\n", argv[2]);
      exit(1);
  }

  while ((nread = fread(buf, sizeof(int), 128, fin)) > 0) {
    //printf("writing\n");
    if ((err = snd_pcm_writei w(playback_handle, buf, nread)) != nread) {
      fprintf (stderr, "write to audio interface failed (%s)\n",
               snd_strerror (err));
      snd_pcm_prepare(playback_handle);
    }
  }alsa_capture.c

  snd_pcm_drain(playback_handle);
  snd_pcm_close (playback_handle);
  exit (0);
}

```

使用`alsamixer`检查麦克风是否启用。通过执行以下操作进行记录:

```sh
alsa_capture hw:0 tmp.s16

```

通过执行以下操作进行回放:

```sh
sox -c 2 -r 44100 tmp.s16 tmp.wav
mplayer tmp.wav

```

或者使用下一个程序:

```sh
alsa_playback hw:0 tmp.s16

```

### 使用中断

以前的程序依靠 ALSA 来管理设备。调用`snd_pcm_writei`将被阻塞，直到所有帧都被播放或放入回放环形缓冲区。这对于许多用途来说是足够的。如果您想获得更好的控制，那么可以设置一个设备可以处理多少帧的阈值，然后等待达到该阈值。当达到阈值时，ALSA 将导致生成内核中断，此时等待将终止，程序可以继续运行。

说明这一点的程序在“关于使用 ALSA 音频 API 的教程”( [`http://equalarea.com/paul/alsa-audio.html`](http://equalarea.com/paul/alsa-audio.html) )中给出。

### 管理延迟

在 ALSA 源码中发布的是一个程序`/test/latency.c`。这可以使用各种参数来测试系统的延迟。警告:把你的音量调低，否则反馈会烧坏你的扬声器！例如，在低设置下，以下给出的延迟仅为 0.93 毫秒:

```sh
latency -m 128 -M 128

```

以下“差”延迟测试给出的延迟为 92.9 毫秒

```sh
latency -m 8192 -M 8192 -t 1 -p

```

获得低延迟是几件事情的组合。为了获得最佳结果，一个针对延迟进行调整的实时 Linux 内核是一个先决条件。关于这一点，参见“低延迟 how to”([`www.alsa-project.org/main/index.php/Low_latency_howto`](http://www.alsa-project.org/main/index.php/Low_latency_howto))。在 ALSA 中，您需要通过编程使用`snd_pcm_hw_params_set_buffer_size_near`和`snd_pcm_hw_params_set_period_size_near`来设置内部缓冲区和周期大小，正如在`latency.c`程序中所做的那样，通过将缓冲区设置为 128 字节来获得低延迟，通过将其设置为 8192 字节来获得更高的延迟。

### 回放捕获的声音

回放捕获的声音涉及两个句柄，可能用于不同的卡。不幸的是，在一个循环中直接组合这两种方法并不奏效。

```sh
while (1) {
    int nread;
    if ((nread = snd_pcm_readi (capture_handle, buf, BUF_SIZE)) != BUF_SIZE) {
      fprintf (stderr, "read from audio interface failed (%s)\n",
               snd_strerror (nread));
      snd_pcm_prepare(capture_handle);
      continue;
    }

    printf("copying %d\n", nread);

    if ((err = snd_pcm_writei (playback_handle, buf, nread)) != nread) {
      if (err < 0) {
        fprintf (stderr, "write to audio interface failed (%s)\n",
                 snd_strerror (err));
      } else {
        fprintf (stderr, "write to audio interface failed after %d frames\n", err);
      }
      snd_pcm_prepare(playback_handle);
    }
}

```

在我的电脑上，它抛出了各种错误，包括管道破裂、设备未准备好和设备不存在。

要直接回放捕获的声音，必须解决许多问题。第一个问题是每个声卡都有自己的时钟。这些时钟必须同步。这对于消费级卡来说很难维持，因为它们的时钟显然质量很低，会漂移或不稳定。然而，ALSA 将尝试使用函数`snd_pcm_link`来同步时钟，该函数将两个卡句柄作为参数。

下一个问题是，必须对缓冲区进行更精细的控制，以及 ALSA 将多久填补这些缓冲区一次。这由两个参数控制:缓冲区大小和周期大小(或缓冲时间和周期时间)。周期大小/时间控制发生中断以填充缓冲器的频率。通常，周期大小(时间)被设置为缓冲区大小(时间)的一半。相关功能有`snd_pcm_hw_params_set_buffer_size_near`和`snd_pcm_hw_params_set_period_size_near`。相应的`get`函数可以用来发现实际设置了什么值。

除了硬件参数，ALSA 还可以设置软件参数。这两者之间的区别对我来说不是很清楚，但是无论如何，一个“开始阈值”和一个“可用最小值”必须被设置为软件参数。我已经设法通过使用`snd_pcm_sw_params_set_start_threshold`和`snd_pcm_sw_params_set_avail_min`将这两者设置为周期大小来获得工作结果。设置软件参数类似于设置硬件参数:首先用`snd_pcm_sw_params_current`初始化一个数据结构，然后用 setter 调用限制软件空间，最后用`snd_pcm_sw_params`将数据设置到卡中。

ALSA 需要尽可能保持最高产量。否则，它将生成“写错误”我不知道为什么，但它似乎只有在试图从捕获设备读取和复制之前，将两个缓冲区写入回放设备时才有效。有时一个缓冲器就可以了，但不要超过两个。为了避免在回放开始时出现多余的噪声，两个静音缓冲器效果很好。

生成的程序是`playback-capture.c`，如下所示:

```sh
/**
 * Jan Newmarch
 */

#define PERIOD_SIZE 1024
#define BUF_SIZE (PERIOD_SIZE * 2)

#include <stdio.h>
#include <stdlib.h>
#include <alsa/asoundlib.h>

void print_pcm_state(snd_pcm_t *handle, char *name) {
  switch (snd_pcm_state(handle)) {
  case SND_PCM_STATE_OPEN:
    printf("state open %s\n", name);
    break;

  case SND_PCM_STATE_SETUP:
    printf("state setup %s\n", name);
    break;

  case SND_PCM_STATE_PREPARED:
    printf("state prepare %s\n", name);
    break;

  case SND_PCM_STATE_RUNNING:
    printf("state running %s\n", name);
    break;

  case SND_PCM_STATE_XRUN:
    printf("state xrun %s\n", name);
    break;

  default:
    printf("state other %s\n", name);
    break;

  }
}

int setparams(snd_pcm_t *handle, char *name) {
  snd_pcm_hw_params_t *hw_params;
  int err;

  if ((err = snd_pcm_hw_params_malloc (&hw_params)) < 0) {
    fprintf (stderr, "cannot allocate hardware parameter structure (%s)\n",
             snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params_an

y (handle, hw_params)) < 0) {
    fprintf (stderr, "cannot initialize hardware parameter structure (%s)\n",
             snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params_set_access (handle, hw_params, SND_PCM_ACCESS_RW_INTERLEAVED)) < 0) {
    fprintf (stderr, "cannot set access type (%s)\n",
             snd_strerror (err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params_set_format (handle, hw_params, SND_PCM_FORMAT_S16_LE)) < 0) {
    fprintf (stderr, "cannot set sample format (%s)\n",
             snd_strerror (err));
    exit (1);
  }

  unsigned int rate = 48000;
  if ((err = snd_pcm_hw_params_set_rate_near (handle, hw_params, &rate, 0)) < 0) {
    fprintf (stderr, "cannot set sample rate (%s)\n",
             snd_strerror (err));
    exit (1);
  }
  printf("Rate for %s is %d\n", name, rate);

  if ((err = snd_pcm_hw_params_set_channels (handle, hw_params, 2)) < 0) {
    fprintf (stderr, "cannot set ch

annel count (%s)\n",
             snd_strerror (err));
    exit (1);
  }

  snd_pcm_uframes_t buffersize = BUF_SIZE;
  if ((err = snd_pcm_hw_params_set_buffer_size_near(handle, hw_params, &buffersize)) < 0) {
    printf("Unable to set buffer size %li: %s\n", BUF_SIZE, snd_strerror(err));
    exit (1);;
  }

  snd_pcm_uframes_t periodsize = PERIOD_SIZE;
  fprintf(stderr, "period size now %d\n", periodsize);
  if ((err = snd_pcm_hw_params_set_period_size_near(handle, hw_params, &periodsize, 0)) < 0) {
    printf("Unable to set period size %li: %s\n", periodsize, snd_strerror(err));
    exit (1);
  }

  if ((err = snd_pcm_hw_params (handle, hw_params)) < 0) {
    fprintf (stderr, "cannot set parameters (%s)\n",
             snd_strerror (err));
    exit (1);
  }

  snd_pcm_uframes_t p_psize;
  snd_pcm_hw_params_get_period_size(hw_params, &p_psize, NULL);
  fprintf(stderr, "period size %d\n", p_psize);

  snd_pcm_hw_params_get_buffer_size(hw_params, &p_psize);
  fprintf(stderr, "buffer size %d\n", p_psize);

  snd_pcm_hw_params_free (hw_params);

  if ((err = snd_pcm_prepare (handle)) < 0) {
    fprintf (stderr, "cannot prepare audio interface for use (%s)\n",
             snd_strerror (err));
    exit (1);
  }

  return 0;
}

int set_sw_params(snd_pcm_t *handle, char *name) {
  snd_pcm_sw_params_t *swparams;
  int err;

  snd_pcm_sw_params_alloca(&swparams);

  err = snd_pcm_sw_params_current(handle, swparams);
  if (err < 0) {
    fprintf(stderr, "Broken configuration for this PCM: no configurations available\n");
    exit(1);
  }

  err = snd_pcm_sw_params_set_start_threshold(handle, swparams, PERIOD_SIZE);
  if (err < 0) {
    printf("Unable to set start threshold: %s\n", snd_strerror(err));
    return err;
  }
  err = snd_pcm_sw_params_set_avail_min(handle, swparams, PERIOD_SIZE);
  if (err < 0) {
    printf("Unable to set avail min: %s\n", snd_strerror(err));
    return err;
  }

  if (snd_pcm_sw_params(handle, swparams) < 0) {
    fprintf(stderr, "unable to install sw params:\n");
    exit(1);
  }

  return 0;
}

/************** some code from latency.c *****************/

main (int argc, char *argv[])
{
  int i;
  int err;
  int buf[BUF_SIZE];
  snd_pcm_t *playback_handle;
  snd_pcm_t *capture_handle;
  snd_pcm_hw_params_t *hw_params;
  FILE *fin;
  size_t nread;
  snd_pcm_format_t format = SND_PCM_FORMAT_S16_LE;
  if (argc != 3) {
    fprintf(stderr, "Usage: %s in-card out-card\n", argv[0]);
    exit(1);
  }

  /**** Out card *******/
  if ((err = snd_pcm_open (&playback_handle, argv[2], SND_PCM_STREAM_PLAYBACK, 0)) < 0) {
    fprintf (stderr, "cannot open audio device %s (%s)\n",
             argv[2],
             snd_strerror (err));
    exit (1);
  }

  setparams(playback_handle, "playback");
  set_sw_params(playback_handle, "playback");

  /*********** In card **********/

  if ((err = snd_pcm_open (&capture_handle, argv[1], SND_PCM_STREAM_CAPTURE, 0)) < 0) {
    fprintf (stderr, "cannot open audio device %s (%s)\n",
             argv[1],
             snd_strerror (err));
    exit (1);
  }

  setparams(capture_handle, "capture");
  set_sw_params(capture_handle, "capture");

  if ((err = snd_pcm_link(capture_handle, playback_handle)) < 0) {
    printf("Streams link error: %s\n", snd_strerror(err));
    exit(0);
  }

  if ((err = snd_pcm_prepare (playback_handle)) < 0) {
    fprintf (stderr, "cannot prepare playback audio interface for use (%s)\n",
             snd_strerror (err));
    exit (1);
  }

  /**************** stuff something into the playback buffer ****************/
  if (snd_pcm_format_set_silence(format, buf, 2*BUF_SIZE) < 0) {
    fprintf(stderr, "silence error\n");
    exit(1);
  }

  int n = 0;
  while (n++ < 2) {
    if (snd_pcm_writei (playback_handle, buf, BUF_SIZE) < 0) {
      fprintf(stderr, "write error\n");
      exit(1);
    }
  }

  /************* COPY ************/
  while (1) {
    int nread;
    if ((nread = snd_pcm_readi (capture_handle, buf, BUF_SIZE)) != BUF_SIZE) {
      if (nread < 0) {
        fprintf (stderr, "read from audio interface failed (%s)\n",
                 snd_strerror (nread));
      } else {
        fprintf (stderr, "read from audio interface failed after %d frames\n", nread);
      }
      snd_pcm_prepare(capture_handle);
      continue;
    }

    if ((err = snd_pcm_writei (playback_handle, buf, nread)) != nread) {
      if (err < 0) {
        fprintf (stderr, "write to audio interface failed (%s)\n",
                 snd_strerror (err));
      } else {
        fprintf (stderr, "write to audio interface failed after %d frames\n", err);
      }
      snd_pcm_prepare(playback_handle);
    }
  }

  snd_pcm_drain(playback_handle);
  snd_pcm_close (playback_handle);
  exit (0);
}

```

## 混合音频

如果一个以上的应用程序想写声卡，只有一个被允许这样做，或者信号必须混合在一起。有些声卡允许硬件混合，但有些不允许。在这种情况下，混合必须在软件中完成，而 ALSA 有这样的机制。

### 使用 dmix 混合

ALSA 包含一个名为`dmix`的插件，默认情况下是启用的。这在软件中将多个音频输入信号混合成一个输出信号。“Dmix how to”([`http://alsa.opensrc.org/Dmix`](http://alsa.opensrc.org/Dmix))中给出了对此的描述。基本上，每个想要向 ALSA 写入音频的应用程序都应该使用插件`plug:dmix`，而不是像`hw:0`这样的硬件设备。例如，前面讨论的`alsa_playback`程序可以被多次调用，并且将 ALSA 输入混合在一起，如下所示:

```sh
alsa_playback plug:dmix tmp1.s16 &
alsa_playback plug:dmix tmp2.s16 &
alsa_playback plug:dmix tmp3.s16

```

### 使用脉冲音频混合

PulseAudio 直到下一章才会涉及，因为它通常被认为是一个声音服务器，在 ALSA 之上的层中工作。但是，还有一个 ALSA 插件模块，PulseAudio 可以作为插件设备出现在 ALSA 下面！因此，ALSA 可以将输出写入 PulseAudio 插件，该插件可以使用 PulseAudio 的全部功能对其进行处理，然后将其反馈回 ALSA，以便在硬件设备上呈现。

其中一个功能是 PulseAudio 包含一个混音器。因此，两个(或更多)应用程序可以向 PulseAudio 插件发送音频，然后该插件将混合信号并将其发送回 ALSA。

PulseAudio 插件可以显示为 PCM 设备`pulse`或`default`。因此，以下三个输出将由 PulseAudio 混合，并由 ALSA 渲染:

```sh
alsa_playback default tmp1.s16 &
alsa_playback pulse tmp2.s16 &
alsa_playback default tmp3.s16

```

### 简单混音器 API:音量控制

ALSA 有一个单独的混音器模块的 API。其实有两个:异步混音器接口( [`www.alsa-project.org/alsa-doc/alsa-lib/group___mixer.html`](http://www.alsa-project.org/alsa-doc/alsa-lib/group___mixer.html) )和简单混音器接口( [`www.alsa-project.org/alsa-doc/alsa-lib/group___simple_mixer.html`](http://www.alsa-project.org/alsa-doc/alsa-lib/group___simple_mixer.html) )。我将只讨论简单的接口。

除了混音之外，ALSA 混音器没有太多的功能。基本上，它可以获取和设置频道或全局的音量。基于 [`http://stackoverflow.com/questions/6787318/set-alsa-master-volume-from-c-code`](http://stackoverflow.com/questions/6787318/set-alsa-master-volume-from-c-code) 的功能，通过以下程序说明音量设置:

```sh
#include <alsa/asoundlib.h>

#include <alsa/mixer.h>

#include <stdlib.h>

int main(int argc, char **argv) {

    snd_mixer_t *mixer;
    snd_mixer_selem_id_t *ident;
    snd_mixer_elem_t *elem;
    long min, max;
    long old_volume, volume;

    snd_mixer_open(&mixer, 0);
    snd_mixer_attach(mixer, "default");
    snd_mixer_selem_register(mixer, NULL, NULL);
    snd_mixer_load(mixer);

    snd_mixer_selem_id_alloca(&ident);
    snd_mixer_selem_id_set_index(ident, 0);
    snd_mixer_selem_id_set_name(ident, "Master");
    elem = snd_mixer_find_selem(mixer, ident);
    snd_mixer_selem_get_playback_volume_range(elem, &min, &max);
    snd_mixer_selem_get_playback_volume(elem, 0, &old_volume);
    printf("Min %ld max %ld current volume %ld\n", min, max, old_volume);

    if (argc < 2) {
        fprintf(stderr, "Usage: %s volume (%ld - %ld)\n", argv[0], min, max);
        exit(1);
    }
    volume = atol(argv[1]);
    snd_mixer_selem_set_playback_volume_all(elem, volume);
    printf("Volume reset to %ld\n", volume);

    exit(0);
}

```

## 编写 ALSA 设备驱动程序

如果你需要为一个新的声卡编写一个设备驱动，请参阅岩井隆的“编写一个 ALSA 驱动”( [`www.alsa-project.org/~tiwai/writing-an-alsa-driver.pdf`](http://www.alsa-project.org/%7Etiwai/writing-an-alsa-driver.pdf) )。

## 结论

ALSA 是目前 Linux 内核中包含的最低级别的音频栈。它为设备驱动程序提供了一个标准的 API 来访问不同的声音设备和声卡。有多种用户级工具可以访问和操作这些设备，这些工具都是使用这个 API 构建的。

本章介绍了用户级工具以及使用 API 构建自己的工具。有一个指针指向构建设备驱动程序。