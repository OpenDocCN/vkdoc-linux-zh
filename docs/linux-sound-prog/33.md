# 三十三、解码 Sonken 卡拉 DVD 上的 DKD 文件

这一章是关于从我的 Sonken 卡拉 DVD 中获取信息，这样我就可以开始编写播放歌曲的程序。在 Linux 下不直接参与播放声音，可以跳过。

## 介绍

我有两台Karaoke 机，一台 Sonken MD-388，一台 Malata MDVD-6619。在他们两个之间，他们拥有我认为我需要的Karaoke 播放器的所有特征，包括以下:

*   选曲和放曲子(当然！)
*   大量的中文和英文歌曲(我妻子是中国人，我是英国人)
*   中文歌曲有普通话和拼音，所以我也可以跟着唱
*   旋律的音符与歌手实际唱的音符一起显示
*   显示不同特征的评分系统

Malata 真的很好，因为它显示了旋律的音符，也显示了你正在唱的音符。但它的英文歌曲少得可怜，而且没有显示中文歌曲的拼音。Songen 在这两方面都有很好的选择，可以显示拼音，但不显示音符，并且有一个简单的评分系统。

所以，我想把歌曲从我的 Sonken DVD 上拿下来，在万利达或我的电脑上播放。在我的个人电脑上玩它们是首选，因为这样我就只受我能写的程序的限制，而不那么依赖于供应商的机器。所以，我的近期目标是把歌曲从 Sonken 的 DVD 上拿下来，开始用我想要的方式播放。

Sonken DVD 上的文件是 DKD 格式的。这是一种未记录的格式，可能代表数字Karaoke 光盘。很多人都致力于这种格式，在卡拉 Engineering 等论坛上也有很多讨论。其中包括“了解加州电子 DVD 上的热狗文件”( [`http://old.nabble.com/Understanding-the-HOTDOG-files-on-DVD-of-California-electronics-td11359745.html`](http://old.nabble.com/Understanding-the-HOTDOG-files-on-DVD-of-California-electronics-td11359745.html) )，“解码 JBK 6628 DVD Karaoke 碟片”( [`http://old.nabble.com/Decoding-JBK-6628-DVD-Karaoke-Disc-td12261269.html`](http://old.nabble.com/Decoding-JBK-6628-DVD-Karaoke-Disc-td12261269.html) )(不过这两个环节似乎不再有任何内容)，以及“Karaoke Huyndai 99”([`http://board.midibuddy.net/showpost.php?p=533722&postcount=31`](http://board.midibuddy.net/showpost.php?p=533722&postcount=31))。

当我开始看我的光盘时，我的方向与这些论坛上的许多海报不同。此外，正如所预料的那样，论坛的结果是以一种临时的、常常令人困惑的方式提出的。所以，我最终重新发明了很多已经被发现的东西，也想出了一些新的东西。

事后看来，如果我对论坛上的言论给予足够的重视，我本可以节省数周的工作时间。因此，这个附录是我试图以一种简单而有逻辑的方式展示结果，以便试图用自己的光盘做类似事情的人可以很容易地找出什么适用于他们的情况，什么是不同的。

本章将涵盖以下内容:

*   我的 DVD 上有什么文件
*   每个文件包含的内容(概述)
*   将歌曲标题与歌曲编号相匹配
*   查找光盘上的歌曲数据
*   提取歌曲数据
*   解码歌曲数据

这个附录并不完整，因为还有更多有待发现。

## 格式转换

拷贝你的 DVD 不是违法的吗？它不在澳洲，在适当的条件下(见 [`www.ag.gov.au/Copyright/Issuesandreviews/Pages/CopyrightAmendmentAct2006FAQs.aspx`](http://www.ag.gov.au/Copyright/Issuesandreviews/Pages/CopyrightAmendmentAct2006FAQs.aspx) 《版权修正法案 2006》常见问题)。

*   我能把我的音乐收藏复制到我的 iPod 上吗？是的。您可以将自己的音乐格式转换到 MP3 播放器、Xbox 360 或电脑等设备上。

我只是把我合法购买的 Sonken DVD 上的音乐拷贝到我的电脑上供个人使用。这是在澳大利亚版权修正法案的范围内。你应该检查你的国家是否允许同样的权利。不要从我的 DVD 上索取任何文件的副本。那是违法的，我不会这么做的。

## DVD 上的文件

我的 Sonken DVD 包含这些文件:

```sh
          BACK01.MPG
          DTSMUS00.DKD
          DTSMUS01.DKD
          DTSMUS02.DKD
          DTSMUS03.DKD
          DTSMUS04.DKD
          DTSMUS05.DKD
          DTSMUS06.DKD
          DTSMUS07.DKD
          DTSMUS10.DKD
          DTSMUS20.DKD

```

### BACK01。每加仑行驶英里数

这是在后台播放的 MP3 文件。

### dtsmus 00 . dkd 至 dtsmus 07 . dkd

这些是歌曲文件。这些的数量取决于 DVD 上有多少首歌曲。

### dtsmus 10 . dkd

还没有人知道这个文件是干什么用的。

### dtsmus 20 . dkd

该文件包含歌曲编号、歌曲标题和艺术家的列表，如歌曲书中所给。这个文件里的歌曲号比书里的歌曲号少一个。

## 解码 dtsmus 20 . dkd

我在 Linux 系统上，使用 Linux/Unix 实用程序和应用。Windows 和 Apple 等其他操作系统也有类似的版本。

### 歌曲信息

Unix 命令`strings`列出了一个文件中所有长度至少为四个字符的 ASCII 8 位编码字符串。在所有的 DVD 文件上运行这个命令会显示出`DTSMUS20.DKD`是唯一一个有很多英语字符串的文件，而这些字符串就是 DVD 上的歌曲标题。

简单的选择如下:

```sh
          Come To Me
          Come To Me Boy
          Condition Of My Heart
          Fly To The Sky
          Cool Love
          Count Down
          Cowboy
          Crazy

```

当然，光盘上显示的实际字符串取决于光盘上的歌曲。当然，你需要一些英文标题才能让它工作！

为了取得进一步的进展，您需要一个二进制编辑器。我使用的`bvi. emacs`也有二进制编辑模式。使用编辑器搜索光盘上已知的歌曲标题。例如，搜索甲壳虫乐队的“太阳来了”，会显示以下区块:

```sh
          000AA920  12 D3 88 48 65 72 65 20 43 6F 6D 65 73 20 54 68 ...Here Comes Th
          000AA930  65 20 52 61 69 6E 20 41 67 61 69 6E 00 45 75 72 e Rain Again.Eur
          000AA940  79 74 68 6D 69 63 73 00 1F 12 D3 89 48 65 72 65 ythmics.....Here
          000AA950  20 43 6F 6D 65 73 20 54 68 65 20 53 75 6E 00 42  Comes The Sun.B
          000AA960  65 61 74 6C 65 73 00 1B 12 D3 8A 48 65 72 65 20 eatles.....Here
          000AA970  46 6F 72 20 59 6F 75 00 46 69 72 65 68 6F 75 73 For You.Firehous

```

字符串“太阳来了”从 0xAA94C 开始，后跟一个空字节。接下来是以零结尾的“Beatles”紧接在这之前的是 4 个字节。这两个字符串(包括空字节)和 4 个字节的长度是 0x1F，这是前面四个字节的第一个。因此，该块由一个 4 字节的头、一个以空结尾的歌曲标题和一个以空结尾的艺术家组成。字节 1 是包括 4 字节标题的歌曲信息块的长度。

标题块的字节 2 是 0x12。jim75 在“解码 JBK 6628 DVD Karaoke 碟片”( [`http://old.nabble.com/Decoding-JBK-6628-DVD-Karaoke-Disc-td12261269.html`](http://old.nabble.com/Decoding-JBK-6628-DVD-Karaoke-Disc-td12261269.html) )发现了文件`JBK_Manual%5B1%5D.doc`。其中有一个国家代码列表，如下所示:

```sh
          00 : KOREAN
          01 : CHINESE( reserved )
          02 : CHINESE
          03 : TAIWANESE
          04 : JAPANESE
          05 : RUSSIAN
          06 : THAI
          07 : TAIWANESE( reserved )
          08 : CHINESE( reserved )
          09 : CANTONESE
          12 : ENGLISH
          13 : VIETNAMESE
          14 : PHILIPPINE
          15 : TURKEY
          16 : SPANISH
          17 : INDONESIAN
          18 : MALAYSIAN
          19 : PORTUGUESE
          20 : FRENCH
          21 : INDIAN
          22 : BRASIL

```

甲壳虫乐队的歌曲在头的字节 2 中有 0x12，这与表中的国家代码相匹配。通过查看其他语言文件可以确认这一点。

我后来发现 WMA 的档案有他们自己的密码。到目前为止，我看到了以下内容:

```sh
          83 : CHINESE WMA
          92 : ENGLISH WMA
          94 : PHILIPPINE WMA

```

我想你可以从早期的照片中看出一种模式！

头的字节 3 和 4 是 0xD389，十进制是 54153。这比书里的歌号(54154)少了一个。所以，字节 3 和 4 是一个 16 位的短整数，比书中的歌曲索引少 1。

这种模式在整个文件中重复出现，所以每个记录都是这种格式。

### 数据的开始/结束

文件开头附近有一长串字节:“01 01 01 01 ....”这在我的文件 0x9F23 处结束。通过比较索引号和我的歌曲簿中的索引号，我确认这是韩国歌曲的开始，也可能是所有歌曲的开始。我还没有找到任何表给我这个起始值。

检查了一些歌曲后，我得到了这个表格:

*   英文歌曲从 60x9562D 开始(歌曲 24452，类型 0x12)
*   粤语 0x8F5D2(宋 13701，3 型)
*   朝鲜语 at 0x9F23(歌曲 37847，类型 0)
*   印度尼西亚文 at 0x11F942(宋 42002，类型 0x17)
*   位于 0x134227 的印地语(歌曲 45058，类型 0x21)
*   菲律宾 at 0xD5D20(宋 62775，类型 0x14)
*   俄语 at 0x110428(歌曲 41012，类型 5)
*   0xF5145 处的西班牙语(歌曲 26487，类型 0x16)
*   0x413BE 处的普通话(1 个字符)(宋 1388，类型 3)

不过，我找不到越南歌曲。我的光盘上好像没有。我的歌本在说谎！我猜在某个地方有一些表格给出了这些起点，但是我还没有找到。这些都是看我的歌本然后在档案里找到的。

0x136C92 上的“FF FF FF FF …”序列表示模块结束。

但是在歌曲信息块之前和之后都有很多东西。我不知道这是什么意思。

### 中国歌曲

我书里的第一首英文歌是艾尔·维德的《阿甘正传》，歌曲编号 24452。在目录文件`DTSMUS20.DK`中，它位于 0x9562D (611885)。在此之前的条目是“20 03 3A 04 CE D2 B4 F2 C1 CB D2 BB CD A8 B2 BB CB B5 BB B0 B5 C4 B5 E7 BB B0 B8 F8 C4 E3 00 00。”歌曲代码是“3A 04”，换句话说就是 14852，也就是歌曲编号 14853(一个偏移量，记住！).当我在Karaoke 机上播放这首歌时，我很幸运:这首歌的第一个字符是我，我把它认作是汉字“我”(拼音:wo3)。它在文件中的编码是“CE D2”我在电脑上安装了中文输入法，所以我可以搜索这个汉字。

Google 搜索 Unicode 值为我向我显示以下内容:

```sh
          [RESOLVED] Converting Unicode Character Literal to Uint16 variable ...
          www.codeguru.com › ... › C++ (Non Visual C++ Issues)
          5 posts - 2 authors - 1 Jul 2011

          I've determined that the unicode character '我' has a hex value of
          0x6211 by looking it up on the "GNOME Character Map 2.32.1"
          and if I do this....

```

然后在 Unicode 搜索上查找 0x 6211([`www.khngai.com/chinese/tools/codeunicode.php`](http://www.khngai.com/chinese/tools/codeunicode.php))给出黄金。

```sh
          Unicode       6211 (25105)
          GB Code       CED2 (4650)
          Big 5 Code    A7DA
          CNS Code      1-4A3C

```

第二行中的 CED2 是 GB 代码。因此，字符集是 GB(可能是 EUC-CN 编码的 GB2312 ),代码为我作为 CED2。

只是为了确定，使用玛丽·安塞尔在 GB 代码表( [`www.ansell-uebersetzungen.com/gborder.html`](http://www.ansell-uebersetzungen.com/gborder.html) )中的表格，将字节“CE D2 B4 F2 C1 CB D2 BB CD A8 B2 BB CB B5 BB B0 B5 C4 B5 E7 BB B0 B8 F8 C4 E3”翻译成我 打 了 一 通…，确实是这首歌。

### 其他语言

我不熟悉其他语言编码，所以没有研究过泰语、越南语等等。韩国人好像是 EUC 人。

### 程序

其他人的早期研究已经产生了 C 或 C++程序。这些通常是独立的程序。我想建立一个可重用模块的集合，所以我选择 Java 作为实现语言。

#### Java 美食

Java 是一种很好的面向对象的语言，支持良好的设计。它包括一个 MIDI 播放器和 MIDI 类。它支持多种语言编码，所以很容易从 GB-2312 转换到 Unicode。它具有良好的跨平台 GUI 支持。

#### java 伙伴

Java 不支持无符号整数类型。这真的很糟糕，因为对于这些程序来说，很多数据类型都是无符号的。Java 中的偶数字节是有符号的。这里有一些窍门:

*   使所有类型的大小增加:byte 到 int，int 到 long，long 到 long。只希望不需要无符号长整型。
*   如果你需要一个无符号字节，你有一个 int，你需要它适合 8 位，转换成一个字节，希望它不要太大。
*   到处进行类型转换以使编译器满意，例如当需要从 int，`(byte) n`中取出一个字节时。
*   注意到处都是标志。如果要右移一个数字，运算符>>会保留符号扩展名，因此，例如，在二进制 1XYZ…中，会移至 1111XYZ…您需要使用>>>，结果为 0001XYZ。
*   如果你想把一个无符号的字节赋给一个 int，再看一下 signs。您可能需要以下内容:

    ```sh
                  n = b ≥ 0 ? b : 256 - b

    ```

*   要从两个无符号字节构建一个无符号 int，符号会再次填充你:n = (b1 << 8) + b2 会出错，如果 b1 或 b2 是-ve。而是用下面的:

    ```sh
                  n = ((b1 ≥ 0 ? b1 : 256 - b1) << 8) + (b2 ≥ 0 ? b2 : 256 - b2)

    ```

    (不开玩笑！)

#### 班级

歌曲类`SongInformation.java`包含关于一首歌曲的信息，如下所示:

```sh
public class SongInformation {

    // Public fields of each song record
    /**
     *  Song number in the file, one less than in songbook
     */
    public long number;

    /**
     * song title in Unicode
     */
    public String title;

    /**
     * artist in Unicode
     */
    public String artist;

    /**
     * integer value of language code
     */
    public int language;

    public static final int  KOREAN = 0;
    public static final int  CHINESE1 = 1;
    public static final int  CHINESE2 = 2;
    public static final int  TAIWANESE3 = 3 ;
    public static final int  JAPANESE = 4;
    public static final int  RUSSIAN = 5;
    public static final int  THAI = 6;
    public static final int  TAIWANESE7 = 7;
    public static final int  CHINESE8 = 8;
    public static final int  CANTONESE = 9;
    public static final int  ENGLISH = 0x12;
    public static final int  VIETNAMESE = 0x13;
    public static final int  PHILIPPINE = 0x14;
    public static final int  TURKEY = 0x15;
    public static final int  SPANISH = 0x16;
    public static final int  INDONESIAN = 0x17;
    public static final int  MALAYSIAN = 0x18;
    public static final int  PORTUGUESE = 0x19;
    public static final int  FRENCH = 0x20;
    public static final int  INDIAN = 0x21;
    public static final int  BRASIL = 0x22;
    public static final int  CHINESE131 = 131;
    public static final int  ENGLISH146 = 146;
    public static final int  PHILIPPINE148 = 148;

    public SongInformation(long number,
                           String title,
                           String artist,
                           int language) {
        this.number = number;
        this.title = title;
        this.artist = artist;
        this.language = language;
    }

    public String toString() {
        return "" + (number+1) + " (" + language + ") \"" + title + "\" " + artist;
    }

    public boolean titleMatch(String pattern) {
        // System.out.println("Pattern: " + pattern);
        return title.matches("(?i).*" + pattern + ".*");
    }

    public boolean artistMatch(String pattern) {
        return artist.matches("(?i).*" + pattern + ".*");
    }

    public boolean numberMatch(String pattern) {
        Long n;
        try {
            n = Long.parseLong(pattern) - 1;
            //System.out.println("Long is " + n);
        } catch(Exception e) {
            //System.out.println(e.toString());
            return false;
        }
        return number == n;
    }

    public boolean languageMatch(int lang) {
        return language == lang;
    }
}

```

歌曲表类`SongTable.java`保存了歌曲信息对象的列表。

```sh
import java.util.Vector;
import java.io.FileInputStream;
import java.io.*;
import java.nio.charset.Charset;

// public class SongTable implements java.util.Iterator {
// public class SongTable extends  Vector<SongInformation> {
public class SongTable {

    private static final String SONG_INFO_FILE = "/home/newmarch/Music/karaoke/sonken/DTSMUS20.DKD";
    private static final long INFO_START = 0x9F23;

    public static final int ENGLISH = 0x12;

    private static Vector<SongInformation> allSongs;

    private Vector<SongInformation> songs =
        new Vector<SongInformation>  ();

    public static long[] langCount = new long[0x23];

    public SongTable(Vector<SongInformation> songs) {
        this.songs = songs;
    }

    public SongTable() throws java.io.IOException,
                              java.io.FileNotFoundException {
        FileInputStream fstream = new FileInputStream(SONG_INFO_FILE);
        fstream.skip(INFO_START);
        while (true) {
            int len;
            int lang;
            long number;

            len = fstream.read();
            lang = fstream.read();
            number = readShort(fstream);
            if (len == 0xFF && lang == 0xFF && number == 0xFFFFL) {
                break;
            }
            byte[] bytes = new byte[len - 4];
            fstream.read(bytes);
            int endTitle;
            // find null at end of title
            for (endTitle = 0; bytes[endTitle] != 0; endTitle++)
                ;
            byte[] titleBytes = new byte[endTitle];
            byte[] artistBytes = new byte[len - endTitle - 6];

            System.arraycopy(bytes, 0, titleBytes, 0, titleBytes.length);
            System.arraycopy(bytes, endTitle + 1,
                             artistBytes, 0, artistBytes.length);
            String title = toUnicode(lang, titleBytes);
            String artist = toUnicode(lang, artistBytes);
            // System.out.printf("artist: %s, title: %s, lang: %d, number %d\n", artist, title, lang, number);
            SongInformation info = new SongInformation(number,
                                                       title,
                                                       artist,
                                                       lang);
            songs.add(info);

            if (lang > 0x22) {
                //System.out.println("Illegal lang value " + lang + " at song " + number);
            } else {
                langCount[lang]++;
            }
        }
        allSongs = songs;
    }

    public void dumpTable() {
        for (SongInformation song: songs) {
            System.out.println("" + (song.number+1) + " - " +
                               song.artist + " - " +
                               song.title);
        }
    }

    public java.util.Iterator<SongInformation> iterator() {
        return songs.iterator();
    }

    private int readShort(FileInputStream f)  throws java.io.IOException {
        int n1 = f.read();
        int n2 = f.read();
        return (n1 << 8) + n2;
    }

    private String toUnicode(int lang, byte[] bytes) {
        switch (lang) {
        case SongInformation.ENGLISH:
        case SongInformation.ENGLISH146:
        case SongInformation.PHILIPPINE:
        case SongInformation.PHILIPPINE148:
            // case SongInformation.HINDI:
        case SongInformation.INDONESIAN:
        case SongInformation.SPANISH:
            return new String(bytes);

        case SongInformation.CHINESE1:
        case SongInformation.CHINESE2:
        case SongInformation.CHINESE8:
        case SongInformation.CHINESE131:
        case SongInformation.TAIWANESE3:
        case SongInformation.TAIWANESE7:
        case SongInformation.CANTONESE:
            Charset charset = Charset.forName("gb2312");
            return new String(bytes, charset);

        case SongInformation.KOREAN:
            charset = Charset.forName("euckr");
            return new String(bytes, charset);

        default:
            return "";
        }
    }

    public SongInformation getNumber(long number) {
        for (SongInformation info: songs) {
            if (info.number == number) {
                return info;
            }
        }
        return null;
    }

    public SongTable titleMatches( String pattern) {
        Vector<SongInformation> matchSongs =
            new Vector<SongInformation>  ();

        for (SongInformation song: songs) {
            if (song.titleMatch(pattern)) {
                matchSongs.add(song);
            }
        }
        return new SongTable(matchSongs);
    }

     public SongTable artistMatches( String pattern) {
        Vector<SongInformation> matchSongs =
            new Vector<SongInformation>  ();

        for (SongInformation song: songs) {
            if (song.artistMatch(pattern)) {
                matchSongs.add(song);
            }
        }
        return new SongTable(matchSongs);
    }

      public SongTable numberMatches( String pattern) {
        Vector<SongInformation> matchSongs =
            new Vector<SongInformation>  ();

        for (SongInformation song: songs) {
            if (song.numberMatch(pattern)) {
                matchSongs.add(song);
            }
        }
        return new SongTable(matchSongs);
    }

    public String toString() {
        StringBuffer buf = new StringBuffer();
        for (SongInformation song: songs) {
            buf.append(song.toString() + "\n");
        }
        return buf.toString();
    }

    public static void main(String[] args) {
        // for testing
        SongTable songs = null;
        try {
            songs = new SongTable();
        } catch(Exception e) {
            System.err.println(e.toString());
            System.exit(1);
        }
        songs.dumpTable();
        System.exit(0);

        // Should print "54151 Help Yourself Tom Jones"
        System.out.println(songs.getNumber(54150).toString());

        // Should print "18062 伦巴(恋歌) 伦巴"
        System.out.println(songs.getNumber(18061).toString());

        System.out.println(songs.artistMatches("Tom Jones").toString());
        /* Prints
54151 Help Yourself Tom Jones
50213 Daughter Of Darkness Tom Jones
23914 DELILAH Tom Jones
52834 Funny Familiar Forgotten Feelings Tom Jones
54114 Green green grass of home Tom Jones
54151 Help Yourself Tom Jones
55365 I (WHO HAVE NOTHING) TOM JONES
52768 I Believe Tom Jones
55509 I WHO HAVE NOTHING TOM JONES
55594 I'll Never Fall Inlove Again Tom Jones
55609 I'm Coming Home Tom Jones
51435 It's Not Unusual Tom Jones
55817 KISS Tom Jones
52842 Little Green Apples Tom Jones
51439 Love Me Tonight Tom Jones
56212 My Elusive Dream TOM JONES
56386 ONE DAY SOON Tom Jones
22862 THAT WONDERFUL SOUND Tom Jones
57170 THE GREEN GREEN GRASS OF HOME TOM JONES
57294 The Wonderful Sound Tom Jones
23819 TILL Tom Jones
51759 What's New Pussycat Tom Jones
52862 With These Hands Tom Jones
57715 Without Love Tom Jones
57836 You're My World Tom Jones
        */

        for (int n = 1; n < langCount.length; n++) {
            if (langCount[n] != 0) {
                System.out.println("Count: " + langCount[n] + " of lang " + n);
            }
        }

        // Check Russian, etc
        System.out.println("Russian " + '\u0411');
        System.out.println("Korean " + '\u0411');
        System.exit(0);
    }
}

```

您可能需要调整基于文件的构造函数中的常量值，这样才能正常工作。

使用 Swing 来显示和搜索歌曲标题的 Java 程序是`SongTableSwing.java`。

```sh
import java.awt.*;
import java.awt.event.*;
import javax.swing.event.*;
import javax.swing.*;
import javax.swing.SwingUtilities;
import java.util.regex.*;
import java.io.*;

public class SongTableSwing extends JPanel {
   private DefaultListModel model = new DefaultListModel();
    private JList list;
    private static SongTable allSongs;

    private JTextField numberField;
    private JTextField langField;
    private JTextField titleField;
    private JTextField artistField;

    // This font displays Asian and European characters.
    // It should be in your distro.
    // Fonts displaying all Unicode are zysong.ttf and Cyberbit.ttf
    // See http://unicode.org/resources/fonts.html
    private Font font = new Font("WenQuanYi Zen Hei", Font.PLAIN, 16);
    // font = new Font("Bitstream Cyberbit", Font.PLAIN, 16);

    private int findIndex = -1;

    /**
     * Describe <code>main</code> method here.
     *
     * @param args a <code>String</code> value
     */
    public static final void main(final String[] args) {
        allSongs = null;
        try {
            allSongs = new SongTable();
        } catch(Exception e) {
            System.err.println(e.toString());
            System.exit(1);
        }

        JFrame frame = new JFrame();
        frame.setTitle("Song Table");
        frame.setSize(1000, 800);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        SongTableSwing panel = new SongTableSwing(allSongs);
        frame.getContentPane().add(panel);

        frame.setVisible(true);
    }

    public SongTableSwing(SongTable songs) {

        if (font == null) {
            System.err.println("Can't fnd font");
        }

        int n = 0;
        java.util.Iterator<SongInformation> iter = songs.iterator();
        while(iter.hasNext()) {
            model.add(n++, iter.next());
            // model.add(n++, iter.next().toString());
        }

        BorderLayout mgr = new BorderLayout();

        list = new JList(model);
        // list = new JList(songs);
        list.setFont(font);
        JScrollPane scrollPane = new JScrollPane(list);

        setLayout(mgr);
        add(scrollPane, BorderLayout.CENTER);

        JPanel bottomPanel = new JPanel();
        bottomPanel.setLayout(new GridLayout(2, 1));
        add(bottomPanel, BorderLayout.SOUTH);

        JPanel searchPanel = new JPanel();
        bottomPanel.add(searchPanel);
        searchPanel.setLayout(new FlowLayout());

        JLabel numberLabel = new JLabel("Number");
        numberField = new JTextField(5);

        JLabel langLabel = new JLabel("Language");
        langField = new JTextField(8);

        JLabel titleLabel = new JLabel("Title");
        titleField = new JTextField(20);
        titleField.setFont(font);

        JLabel artistLabel = new JLabel("Artist");
        artistField = new JTextField(10);
        artistField.setFont(font);

        searchPanel.add(numberLabel);
        searchPanel.add(numberField);
        // searchPanel.add(langLabel);
        // searchPanel.add(langField);
        searchPanel.add(titleLabel);
        searchPanel.add(titleField);
        searchPanel.add(artistLabel);
        searchPanel.add(artistField);

        titleField.getDocument().addDocumentListener(new DocumentListener() {
                public void changedUpdate(DocumentEvent e) {
                    // rest find to -1 to restart any find searches
                    findIndex = -1;
                    // System.out.println("reset find index");
                }
                public void insertUpdate(DocumentEvent e) {
                    findIndex = -1;
                    // System.out.println("reset insert find index");
                }
                public void removeUpdate(DocumentEvent e) {
                    findIndex = -1;
                    // System.out.println("reset remove find index");
                }
            }
            );
        artistField.getDocument().addDocumentListener(new DocumentListener() {
                public void changedUpdate(DocumentEvent e) {
                    // rest find to -1 to restart any find searches
                    findIndex = -1;
                    // System.out.println("reset insert find index");
                }
                public void insertUpdate(DocumentEvent e) {
                    findIndex = -1;
                    // System.out.println("reset insert find index");
                }
                public void removeUpdate(DocumentEvent e) {
                    findIndex = -1;
                    // System.out.println("reset insert find index");
                }
            }
            );

        titleField.addActionListener(new ActionListener(){
                public void actionPerformed(ActionEvent e){
                    filterSongs();
                }});
        artistField.addActionListener(new ActionListener(){
                public void actionPerformed(ActionEvent e){
                    filterSongs();
                }});
        numberField.addActionListener(new ActionListener(){
                public void actionPerformed(ActionEvent e){
                    filterSongs();
                }});

        JPanel buttonPanel = new JPanel();
        bottomPanel.add(buttonPanel);
        buttonPanel.setLayout(new FlowLayout());

        JButton find = new JButton("Find");
        JButton filter = new JButton("Filter");
        JButton reset = new JButton("Reset");
        JButton play = new JButton("Play");
        buttonPanel.add(find);
        buttonPanel.add(filter);
        buttonPanel.add(reset);
        buttonPanel.add(play);

        find.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    findSong();
                }
            });

        filter.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    filterSongs();
                }
            });

        reset.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    resetSongs();
                }
            });

        play.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    playSong();
                }
            });

     }

    public void findSong() {
        String number = numberField.getText();
        String language = langField.getText();
        String title = titleField.getText();
        String artist = artistField.getText();

        if (number.length() != 0) {
            try {

                long num = Integer.parseInt(number) - 1;
                for (int n = 0; n < model.getSize(); n++) {
                    SongInformation info = (SongInformation) model.getElementAt(n);
                    if (info.number == num) {
                        list.setSelectedIndex(n);
                        list.ensureIndexIsVisible(n);
                        return;
                    }
                }
            } catch(Exception e) {
                System.err.println("Not a number");
                numberField.setText("");
            }

            return;
        }

        /*
        System.out.println("Title " + title + title.length() +
                           "artist " + artist + artist.length() +
                           " find start " + findIndex +
                           " model size " + model.getSize());
        if (title.length() == 0 && artist.length() == 0) {
            System.err.println("no search terms");
            return;
        }
        */

        //System.out.println("Search " + searchStr + " from index " + findIndex);
        for (int n = findIndex + 1; n < model.getSize(); n++) {
            SongInformation info = (SongInformation) model.getElementAt(n);
            //System.out.println(info.toString());

            if ((title.length() != 0) && (artist.length() != 0)) {
                if (info.titleMatch(title) && info.artistMatch(artist)) {
                    // System.out.println("Found " + info.toString());
                        findIndex = n;
                        list.setSelectedIndex(n);
                        list.ensureIndexIsVisible(n);
                        break;
                }
            } else {
                if ((title.length() != 0) && info.titleMatch(title)) {
                    // System.out.println("Found " + info.toString());
                    findIndex = n;
                    list.setSelectedIndex(n);
                    list.ensureIndexIsVisible(n);
                    break;
                } else if ((artist.length() != 0) && info.artistMatch(artist)) {
                    // System.out.println("Found " + info.toString());
                    findIndex = n;
                    list.setSelectedIndex(n);
                    list.ensureIndexIsVisible(n);
                    break;

                }
            }

        }
    }

    public void filterSongs() {
        String title = titleField.getText();
        String artist = artistField.getText();
        String number = numberField.getText();
        SongTable filteredSongs = allSongs;

        if (allSongs == null) {
            // System.err.println("Songs is null");
            return;
        }

        if (title.length() != 0) {
            filteredSongs = filteredSongs.titleMatches(title);
        }
        if (artist.length() != 0) {
            filteredSongs = filteredSongs.artistMatches(artist);
        }
        if (number.length() != 0) {
            filteredSongs = filteredSongs.numberMatches(number);
        }

        model.clear();
        int n = 0;
        java.util.Iterator<SongInformation> iter = filteredSongs.iterator();
        while(iter.hasNext()) {
            model.add(n++, iter.next());
        }
    }

    public void resetSongs() {
        artistField.setText("");
        titleField.setText("");
        numberField.setText("");
        model.clear();
        int n = 0;
        java.util.Iterator<SongInformation> iter = allSongs.iterator();
        while(iter.hasNext()) {
            model.add(n++, iter.next());
        }
    }
    /**
     * "play" a song by printing its id to standard out.
     * Can be used in a pipeline this way
     */
    public void playSong() {
        SongInformation song = (SongInformation) list.getSelectedValue();
        if (song == null) {
            return;
        }
        long number = song.number + 1;

        System.out.println("" + number);
    }

    class SongInformationRenderer extends JLabel implements ListCellRenderer {

        public Component getListCellRendererComponent(
                                                      JList list,
                                                      Object value,
                                                      int index,
                                                      boolean isSelected,
                                                      boolean cellHasFocus) {
            setText(value.toString());
            return this;
        }
    }
}

```

当选择 Play 时，它会将歌曲 ID 打印到标准输出，以便在管道中使用。

## 数据文件

以下部分将介绍数据文件。

### 一般

文件`DTSMUS00.DKD`到`DTSMUS07.DKD`包含音乐文件。音乐有两种格式:微软 WMA 文件和 MIDI 文件。在我的歌本里，有些歌是标注有歌手的。这些是 WMA 的档案。没有歌手的是 MIDI 文件。

WMA 的文件就是这样。MIDI 文件被略微压缩，在播放之前必须解码。

每个歌曲块在开头都有一个包含歌词的部分。这些是压缩的，必须解码。

一首歌曲的数据形成一个连续字节的记录。这些记录被收集成块，也是连续的。这两块是分开的。有一个指向这些块的指针“超级块”。歌曲号的一部分是超级块的索引，选择该块。歌曲号的其余部分是块中记录的索引。

### 我的路线

我回到了这一点，并在一段时间后才理解了其他人的成就。所以，为了帮助其他人，这是我的路线。

我用 Unix 命令`strings`发现了`DTSMUS10.DKD`中的歌曲信息。在其他文件中，它似乎没有产生太多。但是这些文件中有 ASCII 字符串，有些是重复的。所以，我写了一个 shell 管道来对这些字符串进行排序和计数。一个文件的管道如下:

```sh
          strings DTSMUS05.DKD | sort |uniq -c | sort -n -r |less

```

这产生了以下结果:

```sh
          1229 :^y|
          1018 j?wK
          843 ]/<
          756  Seh
          747  Ser
          747 _\D+P
          674 :^yt
          234 IRI$

```

结果并不令人鼓舞。但是，当我查看文件内部以查看“Ser”出现的位置时，我还看到了以下内容:

```sh
          q03C3E230  F6 01 00 00 00 02 00 16 00 57 00 69 00 6E 00 64 .........W.i.n.d
          03C3E240  00 6F 00 77 00 73 00 20 00 4D 00 65 00 64 00 69 .o.w.s. .M.e.d.i
          03C3E250  00 61 00 20 00 41 00 75 00 64 00 69 00 6F 00 20 .a. .A.u.d.i.o.
          03C3E260  00 39 00 00 00 24 00 20 00 34 00 38 00 20 00 6B .9...$. .4.8\. .k
          03C3E270  00 62 00 70 00 73 00 2C 00 20 00 34 00 34 00 20 .b.p.s.,. .4.4.
          03C3E280  00 6B 00 48 00 7A 00 2C 00 20 00 73 00 74 00 65 .k.H.z.,. .s.t.e
          03C3E290  00 72 00 65 00 6F 00 20 00 31 00 2D 00 70 00 61 .r.e.o. .1.-.p.a
          03C3E2A0  00 73 00 73 00 20 00 43 00 42 00 52 00 00 00 02 .s.s. .C.B.R....
          03C3E2B0  00 61 01 91 07 DC B7 B7 A9 CF 11 8E E6 00 C0 0C .a..............
          03C3E2C0  20 53 65 72 00 00 00 00 00 00 00 40 9E 69 F8 4D  Ser.......@.i.M

```

哇哦！双字节字符！

`strings`命令有选项可以查看，例如，2 字节的大端字符串。命令

```sh
          strings -e b DTSMUS05.DKD

```

发现了这个:

```sh
          IsVBR
          DeviceConformanceTemplate
          WM/WMADRCPeakReference
          WM/WMADRCAverageReference
          WMFSDKVersion
          9.00.00.2980
          WMFSDKNeeded
          0.0.0.0000

```

这些都是 WMA 格式的一部分。

根据加里·凯斯勒的文件签名表( [`www.garykessler.net/library/file_sigs.html`](http://www.garykessler.net/library/file_sigs.html) )，WMA 文件的签名由下面所示的标题给出:

```sh
          30 26 B2 75 8E 66 CF 11
          A6 D9 00 AA 00 62 CE 6C

```

这种模式确实会出现，之前的字符串会在一段时间后出现。

ASF/WMA 文件格式的规范在 [`www.microsoft.com/download/en/details.aspx?displaylang=en&id=14995`](http://www.microsoft.com/download/en/details.aspx?displaylang=en&id=14995) ，尽管建议你不要阅读它，以防你想对这样的文件做任何开源的事情。

因此，在此基础上，我可以确定 WMA 文件的开始。每个 WMA 文件前面的四个字节是文件的长度。从那里我可以找到文件的结尾，它原来是下一个包含一些内容的记录的开始，然后是下一个 WMA 文件。

在这些记录中，我可以看到我无法理解的模式，但从字节 36 开始，我可以看到类似这样的字符串:

```sh
          AIN'T IT FUNNY HOW TIME SLIPS AWAY, Str length: 34

          00000000  10 50 41 10 50 49 10 50 4E 10 50 27 10 50 54 10 .PA.PI.PN.P'.PT.
          00000010  50 20 11 F1 25 12 71 05 04 61 05 05 51 21 13 01 P ..%.q..a..Q!..
          00000020  02 05 91 2B 10 20 48 10 50 4F 10 50 57 13 40 00 ...+. H.PO.PW.@.
          00000030  12 61 02 12 01 02 04 D1 05 04 51 3B 05 31 05 04 .a........Q;.1..
          00000040  C1 29 10 20 50 10 51 45 10 21 28 10 21 1E 10 21 .). P.QE.!(.!..!
          00000050  3A 14 F1 05 13 31 02 10 C1 0E 11 A1 58 15 A0 00 :....1......X...
          00000060  15 70 00 13 A0 A9                               .p....

```

能看到`AIN'T`(作为`.PA.PI.PN.P'.PT`)吗？

但是我不知道编码是什么，也不知道如何找到歌曲开始的表格。那时，我准备看看早期的东西，并了解它如何适用于我。(参见《了解加州电子 DVD 上的热狗文件》( [`http://old.nabble.com/Understanding-the-HOTDOG-files-on-DVD-of-California-electronics-td11359745.html`](http://old.nabble.com/Understanding-the-HOTDOG-files-on-DVD-of-California-electronics-td11359745.html) )、《解码 JBK 6628 DVD Karaoke 碟》( [`http://old.nabble.com/Decoding-JBK-6628-DVD-Karaoke-Disc-td12261269.html`](http://old.nabble.com/Decoding-JBK-6628-DVD-Karaoke-Disc-td12261269.html) )、《Karaoke Huyndai 99》([`http://board.midibuddy.net/showpost.php?p=533722&postcount=31`](http://board.midibuddy.net/showpost.php?p=533722&postcount=31))。

### 超级街区

文件`DTSMUS00.DKD`以一串空值开始。在 0x200 处，它开始输入数据。这被认为是“表的表”的开始，换句话说，是一个超级块。这个超级块中的每个条目都是一个 4 字节的整数，它是数据文件中表的索引。超级块由一系列空值终止(对我来说是 0x5F4)，表中的索引少于 256 个。

这些超级块条目的值似乎在不同的版本中发生了变化。在 JBK 光盘和我的光盘中，这些值必须乘以 0x800 才能在数据文件中给出一个“虚拟偏移量”。

为了说明这一点，在我的光盘 0x200 上有以下内容:

```sh
          00000200  00 00 00 01 00 00 08 6C 00 00 0F C1 00 00 17 7A
          00000210  00 00 1E 81 00 00 25 21 00 00 2B 8D 00 00 32 B7

```

因此，表值为 0x1、0x86C、0xFC1、0x177A、....“虚拟地址”是 0x800、0x436000 (0x86C * 0x800)等等。如果你去这些地址，你会看到地址前是一堆空值，在那个地址是数据。

我称它们为虚拟地址，因为在我的 DVD 上有八个数据文件，并且大多数地址比任何一个文件都大。我这里的文件(除了最后一个)都是 1065353216L 字节。“显而易见”的解决方案是可行的:文件号是地址/文件大小，文件中的偏移量是地址百分比文件大小。您可以通过查找每个块地址前的空值来检查这一点。

### 歌曲开始表

从超级块索引的每个表都是歌曲索引表。每个表包含 4 字节的索引。每个表最多有 0x100 个条目，或者以零索引结束。每个索引是从歌曲条目开始的表格开始的偏移。

### 从歌曲编号定位歌曲条目

给定一个歌曲编号，比如 54154，“太阳来了”，您现在可以找到歌曲条目。将歌曲编号减少 1 至 54153。它是一个 16 位的数字。最高 8 位是超级块中歌曲索引表的索引。底部的 8 位是歌曲索引表中歌曲条目的索引。

下面是伪代码:

```sh
          songNumber = get number for song from DTSMUS20.DKD
          superBlockIdx = songNumber >>
          indexTableIdx = songNumber & 0xFF

          seek(DTSMUS00.DKD, superBlockIdx)
          superBlockValue = read 4-byte int from DTSMUS00.DKD

          locationIndexTable = superBlockValue * 0x800
          fileNumber = locationIndexTable / fileSize
          indexTableStart = locationIndexTable % fileSize
          entryLocation = indexTableStart + indexTableIdx

          seek(fileNumber, entryLocation)
          read song entry

```

### 歌曲条目

每个歌曲条目都有一个标题，后面是两个块，我称之为信息块和歌曲数据块。每个标题块有一个 2 字节的类型码和一个 2 字节的整数长度。类型代码为 0x0800 或 0x0000。代码表示歌曲数据的编码:0x0800 是 WMA 文件，而 0x0000 是 MIDI 文件。

如果类型码是 0x0 比如披头士的“救命！”(歌曲号 51765)，则信息块具有标题块中的长度，并从 12 个字节开始。歌曲数据块紧随其后。

如果类型代码是 0x8000，则信息块从 4 个字节开始，长度为报头中给定的长度。歌曲块从信息块末尾的下一个 16 字节边界开始。

歌曲块以一个 4 字节的头开始，这是所有类型的歌曲数据的长度。

### 歌曲数据

如果歌曲类型是 0x8000，则歌曲数据是 WMA 文件。所有歌曲都有一个歌手包含在这个文件中。

如果歌曲类型是 0x0，那么(从书中)在所查看的歌曲中没有歌手。该文件被编码和解码为 MIDI 文件。

## 解码 MIDI 文件

所有文件都有一个歌词块，后跟一个音乐块。歌词块被压缩，并且已经发现这是 LZW 压缩。这会解压缩成一组 4 字节的块。前两个字节是歌词的字符。对于 1 字节编码，如英语或越南语，第一个字节是一个字符，第二个字节是零或另一个字符(两个字节，如`\r\n`)。对于双字节编码，如 GB-2312，两个字节构成一个字符。

接下来的两个字节是字符串播放的时间长度。

### 歌词块

每个歌词块都以`""#0001 @@00@12 @Help Yourself @ @@Tom Jones"`这样的字符串开头。这里的语言代码是`@00@NN`中的`NN`。歌名，作词人，歌手都很清楚。(注意:这些字符都是相隔 4 个字节的！)对于英语，是 12 等等。

每个块的字节 0 和 1 是歌词中的一个字符。字节 2 和 3 是每个字符的持续时间。要将它们转换成 MIDI 数据，必须将持续时间转换成每个字符的开始/停止。

我做这个的 Java 程序是`SongExtracter.java`。

```sh
import java.io.*;
import javax.sound.midi.*;
import java.nio.charset.Charset;

public class SongExtracter {
    private static final boolean DEBUG = false;

    private String[] dataFiles = new String[] {
        "DTSMUS00.DKD", "DTSMUS01.DKD", "DTSMUS02.DKD",
        "DTSMUS03.DKD", "DTSMUS04.DKD", "DTSMUS05.DKD",
        "DTSMUS06.DKD", "DTSMUS07.DKD"};
    private String superBlockFileName = dataFiles[0];
    private static final String DATADIR = "/home/newmarch/Music/karaoke/sonken/";
    private static final String SONGDIR ="/home/newmarch/Music/karaoke/sonken/songs/";
    //private static final String SONGDIR ="/server/KARAOKE/KARAOKE/Sonken/";
    private static final long SUPERBLOCK_OFFSET = 0x200;
    private static final long BLOCK_MULTIPLIER = 0x800;
    private static final long FILE_SIZE = 0x3F800000L;

    private static final int SIZE_UINT = 4;

    private static final int SIZE_USHORT = 2;

    private static final int ENGLISH = 12;

    public RawSong getRawSong(int songNumber)
        throws java.io.IOException,
               java.io.FileNotFoundException {
        if (songNumber < 1) {
            throw new FileNotFoundException();
        }

        // song number in files is one less than song number in books, so
        songNumber--;

        long locationIndexTable = getTableIndexFromSuperblock(songNumber);
        debug("Index table at %X\n", locationIndexTable);

        long locationSongDataBlock = getSongIndex(songNumber, locationIndexTable);

        // Now we are at the start of the data block
        return readRawSongData(locationSongDataBlock);

        //debug("Data block at %X\n", songStart);
    }

    private long getTableIndexFromSuperblock(int songNumber)
        throws java.io.IOException,
               java.io.FileNotFoundException {
        // index into superblock of table of song offsets
        int superBlockIdx = songNumber >> 8;

        debug("Superblock index %X\n", superBlockIdx);

        File superBlockFile = new File(DATADIR + superBlockFileName);

        FileInputStream fstream = new FileInputStream(superBlockFile);

        fstream.skip(SUPERBLOCK_OFFSET + superBlockIdx * SIZE_UINT);
        debug("Skipping to %X\n", SUPERBLOCK_OFFSET + superBlockIdx*4);
        long superBlockValue = readUInt(fstream);

        // virtual address of the index table for this song
        long locationIndexTable = superBlockValue * BLOCK_MULTIPLIER;

        return locationIndexTable;
    }

    /*
     * Virtual address of song data block
     */
    private long getSongIndex(int songNumber, long locationIndexTable)
        throws java.io.IOException,
               java.io.FileNotFoundException {
        // index of song into table of song ofsets
        int indexTableIdx = songNumber & 0xFF;
        debug("Index into index table %X\n", indexTableIdx);

        // translate virtual address to physical address
        int whichFile = (int) (locationIndexTable / FILE_SIZE);
        long indexTableStart =  locationIndexTable % FILE_SIZE;
        debug("Which file %d index into file %X\n", whichFile, indexTableStart);

        File songDataFile = new File(DATADIR + dataFiles[whichFile]);
        FileInputStream dataStream = new FileInputStream(songDataFile);
        dataStream.skip(indexTableStart + indexTableIdx * SIZE_UINT);
        debug("Song data index is at %X\n", indexTableStart + indexTableIdx*SIZE_UINT);

        long songStart = readUInt(dataStream) + indexTableStart;

        return songStart + whichFile * FILE_SIZE;
    }

    private RawSong readRawSongData(long locationSongDataBlock)
        throws java.io.IOException {
        int whichFile = (int) (locationSongDataBlock / FILE_SIZE);
        long dataStart =  locationSongDataBlock % FILE_SIZE;
        debug("Which song file %d  into file %X\n", whichFile, dataStart);

        File songDataFile = new File(DATADIR + dataFiles[whichFile]);
        FileInputStream dataStream = new FileInputStream(songDataFile);
        dataStream.skip(dataStart);

        RawSong rs = new RawSong();
        rs.type = readUShort(dataStream);
        rs.compressedLyricLength = readUShort(dataStream);
        // discard next short
        readUShort(dataStream);
        rs.uncompressedLyricLength = readUShort(dataStream);
        debug("Type %X, cLength %X uLength %X\n", rs.type, rs.compressedLyricLength, rs.uncompressedLyricLength);

        // don't know what the next word is for, skip it
        //dataStream.skip(4);
        readUInt(dataStream);

        // get the compressed lyric
        rs.lyric = new byte[rs.compressedLyricLength];
        dataStream.read(rs.lyric);

        long toBoundary = 0;
        long songLength = 0;
        long uncompressedSongLength = 0;

        // get the song data

        if (rs.type == 0) {
            // Midi file starts in 4 bytes time
            songLength = readUInt(dataStream);
            uncompressedSongLength = readUInt(dataStream);
            System.out.printf("Song data length %d, uncompressed %d\n",
                              songLength, uncompressedSongLength);
            rs.uncompressedSongLength = uncompressedSongLength;

            // next word is language again?
            //toBoundary = 4;
            //dataStream.skip(toBoundary);
            readUInt(dataStream);
        } else {
            // WMA starts on next 16-byte boundary
            if( (dataStart + rs.compressedLyricLength + 12) % 16 != 0) {
                // dataStart already on 16-byte boundary, so just need extra since then
                toBoundary = 16 - ((rs.compressedLyricLength + 12) % 16);
                debug("Read lyric data to %X\n", dataStart + rs.compressedLyricLength + 12);
                debug("Length %X to boundary %X\n", rs.compressedLyricLength, toBoundary);
                dataStream.skip(toBoundary);
            }
            songLength = readUInt(dataStream);
        }

        rs.music = new byte[(int) songLength];
        dataStream.read(rs.music);

        return rs;
    }

    private long readUInt(InputStream is) throws IOException {
        long val = 0;
        for (int n = 0; n < SIZE_UINT; n++) {
            int c = is.read();
            val = (val << 8) + c;
        }
        debug("ReadUInt %X\n", val);

        return val;
    }

    private int readUShort(InputStream is) throws IOException {
        int val = 0;
        for (int n = 0; n < SIZE_USHORT; n++) {
            int c = is.read();
            val = (val << 8) + c;
        }
        debug("ReadUShort %X\n", val);
        return val;
    }

    void debug(String f, Object ...args) {
        if (DEBUG) {
            System.out.printf("Debug: " + f, args);
        }
    }

    public Song getSong(RawSong rs) {
        Song song;
        if (rs.type == 0x8000) {
            song = new WMASong(rs);
        } else {
            song = new MidiSong(rs);
        }
        return song;
    }

    public static void main(String[] args) {
        if (args.length != 1) {
            System.err.println("Usage: java SongExtractor <song numnber>");
            System.exit(1);
        }

        SongExtracter se = new SongExtracter();
        try {
            RawSong rs = se.getRawSong(Integer.parseInt(args[0]));

            rs.dumpToFile(args[0]);

            Song song = se.getSong(rs);
            song.dumpToFile(args[0]);
            song.dumpLyric();
        } catch(Exception e) {
            e.printStackTrace();
        }
    }

    private class RawSong {
        /**
         * type == 0x0 is Midi
         * type == 0x8000 is WMA
         */
        public int type;
        public int compressedLyricLength;
        public int uncompressedLyricLength;
        public long uncompressedSongLength; // only needed for compressed Midi
        public byte[] lyric;
        public byte[] music;

        public void dumpToFile(String fileName) throws IOException {
            FileOutputStream fout = new FileOutputStream(SONGDIR + fileName + ".lyric");
            fout.write(lyric);
            fout.close();

            fout = new FileOutputStream(SONGDIR + fileName + ".music");
            fout.write(music);
            fout.close();
        }
    }

    private class Song {
        public int type;
        public byte[] lyric;
        public byte[] music;
        protected Sequence sequence;
        protected int language = -1;

        public Song(RawSong rs) {

            type = rs.type;
            lyric = decodeLyric(rs.lyric,
                                rs.uncompressedLyricLength);
        }

        /**
         * Raw lyric is LZW compressed. Decompress it
         */
        public byte[] decodeLyric(byte[] compressedLyric, long uncompressedLength) {
            // uclen is short by at least 2 - other code adds 10 so we do too
            // TODO: change LZW to use a Vector to build result so we don't have to guess at length
            byte[] result = new byte[(int) uncompressedLength + 10];
            LZW lzw = new LZW();
            int len = lzw.expand(compressedLyric, compressedLyric.length, result);
            System.out.printf("uncompressedLength %d, actual %d\n", uncompressedLength, len);
            lyric = new byte[len];
            System.arraycopy(result, 0, lyric, 0, (int) uncompressedLength);
            return lyric;
        }

        public void dumpToFile(String fileName) throws IOException {
            FileOutputStream fout = new FileOutputStream(SONGDIR + fileName + ".decodedlyric");
            fout.write(lyric);
            fout.close();

            fout = new FileOutputStream(SONGDIR + fileName + ".decodedmusic");
            fout.write(music);

            fout.close();

            fout = new FileOutputStream(SONGDIR + fileName + ".mid");
            if (sequence == null)  {
                System.out.println("Seq is null");
            } else {
                // type is MIDI type 0
                MidiSystem.write(sequence, 0, fout);
            }
        }

        public void dumpLyric() {
            for (int n = 0; n < lyric.length; n += 4) {
                if (lyric[n] == '\r') {
                    System.out.println();
                } else {
                    System.out.printf("%c", lyric[n] & 0xFF);
                }
            }
            System.out.println();
            System.out.printf("Language is %X\n", getLanguageCode());
        }

        /**
         * Lyric contains the language code as string @00@NN in header section
         */
        public int getLanguageCode() {
            int lang = 0;

            // Look for @00@NN and return NN
            for (int n = 0; n < lyric.length-20; n += 4) {
                if (lyric[n] == (byte) '@' &&
                    lyric[n+4] == (byte) '0' &&
                    lyric[n+8] == (byte) '0' &&
                    lyric[n+12] == (byte) '@') {
                    lang = ((lyric[n+16]-'0') << 4) + lyric[n+20]-'0';
                    break;

                }
            }
            return lang;
        }

        /**
         * Lyric is in a language specific encoding. Translate to Unicode UTF-8.
         * Not all languages are handled because I don't have a full set of examples
         */
        public byte[] lyricToUnicode(byte[] bytes) {
            if (language == -1) {
                language = getLanguageCode();
            }
            switch (language) {
            case SongInformation.ENGLISH:
                return bytes;

            case SongInformation.KOREAN: {
                Charset charset = Charset.forName("gb2312");
                String str = new String(bytes, charset);
                bytes = str.getBytes();
                System.out.println(str);
                return bytes;
            }

            case SongInformation.CHINESE1:
            case SongInformation.CHINESE2:
            case SongInformation.CHINESE8:
            case SongInformation.CHINESE131:
            case SongInformation.TAIWANESE3:
            case SongInformation.TAIWANESE7:
            case SongInformation.CANTONESE:
                Charset charset = Charset.forName("gb2312");
                String str = new String(bytes, charset);
                bytes = str.getBytes();
                System.out.println(str);
                return bytes;
            }
            // language not handled
            return bytes;

        }

        public void durationToOnOff() {

        }

        public Track createSequence() {
            Track track;

            try {
                sequence = new Sequence(Sequence.PPQ, 30);
            } catch(InvalidMidiDataException e) {
                // help!!!
            }
            track = sequence.createTrack();
            addLyricToTrack(track);
            return track;
        }

        public void addMsgToTrack(MidiMessage msg, Track track, long tick) {
            MidiEvent midiEvent = new MidiEvent(msg, tick);

            // No need to sort or delay insertion. From the Java API
            // "The list of events is kept in time order, meaning that this
            // event inserted at the appropriate place in the list"
            track.add(midiEvent);
        }

        /**
         * return byte as int, converting to unsigned if needed
         */
        protected int ub2i(byte b) {
            return  b >= 0 ? b : 256 + b;
        }

        public void addLyricToTrack(Track track) {
            long lastDelay = 0;
            int offset = 0;

            int data0;
            int data1;
            final int LYRIC = 0x05;
            MetaMessage msg;

            while (offset < lyric.length-4) {
                int data3 = ub2i(lyric[offset+3]);
                int data2 = ub2i(lyric[offset+2]);
                data0 = ub2i(lyric[offset]);
                data1 = ub2i(lyric[offset+1]);

                long delay = (data3 << 8) + data2;

                offset += 4;
                byte[] data;
                int len;
                long tick;

                //System.out.printf("Lyric offset %X char %X after %d with delay %d made of %d %d\n", offset, data0, lastDelay, delay, lyric[offset-1], lyric[offset-2]);

                if (data1 == 0) {
                    data = new byte[] {(byte) data0}; //, (byte) MetaMessage.META};
                } else {
                    data = new byte[] {(byte) data0, (byte) data1}; // , (byte) MetaMessage.META};
                }
                data = lyricToUnicode(data);

                msg = new MetaMessage();

                if (delay > 0) {
                    tick = delay;
                    lastDelay = delay;
                } else {
                    tick = lastDelay;
                }

                try {
                    msg.setMessage(LYRIC, data, data.length);
                } catch(InvalidMidiDataException e) {
                    e.printStackTrace();
                    continue;

                }
                addMsgToTrack(msg, track, tick);
            }
        }

    }

    private class WMASong extends Song {

        public WMASong(RawSong rs) {
            // We want to decode the lyric, but just copy the music data
            super(rs);
            music = rs.music;
            createSequence();
        }

        public void dumpToFile(String fileName) throws IOException {
            System.out.println("Dumping WMA to " + fileName + ".wma");
            super.dumpToFile(fileName);
            FileOutputStream fout = new FileOutputStream(fileName + ".wma");
            fout.write(music);
            fout.close();
        }

    }

    private class MidiSong extends Song {

        private String[] keyNames = {"C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"};

        public MidiSong(RawSong rs) {
            // We want the decoded lyric plus also need to decode the music
            // and then turn it into a Midi sequence
            super(rs);
            decodeMusic(rs);
            createSequence();

        }

        public void dumpToFile(String fileName) throws IOException {
            System.out.println("Dumping Midi to " + fileName);
            super.dumpToFile(fileName);
        }

        public String getKeyName(int nKeyNumber)
        {
            if (nKeyNumber > 127)
                {
                    return "illegal value";
                }
            else
                {
                    int     nNote = nKeyNumber % 12;
                    int     nOctave = nKeyNumber / 12;
                    return keyNames[nNote] + (nOctave - 1);
                }
        }

        public byte[] decodeMusic(RawSong rs) {
            byte[]  compressedMusic = rs.music;
            long uncompressedSongLength = rs.uncompressedSongLength;

            // TODO: change LZW to use a Vector to build result so we don't have to guess at length
            byte[] expanded = new byte[(int) uncompressedSongLength + 20];
            LZW lzw = new LZW();
            int len = lzw.expand(compressedMusic, compressedMusic.length, expanded);
            System.out.printf("Uncompressed %d, Actual %d\n", compressedMusic.length, len);
            music = new byte[len];
            System.arraycopy(expanded, 0, music, 0, (int) len);

            return music;

        }

        public Track createSequence() {
            Track track = super.createSequence();
            addMusicToTrack(track);
            return track;
        }

        public void addMusicToTrack(Track track) {
            int timeLine = 0;
            int offset = 0;
            int midiChannelNumber = 1;

            /* From http://board.midibuddy.net/showpost.php?p=533722&postcount=31
               Block of 5 bytes :
               xx xx xx xx xx
               1st byte = Delay Time
               2nd byte = Delay Time when the velocity will be 0,
               this one will generate another midi event
               with velocity 0 (see above).
               3nd byte = Event, for example 9x : Note On for channel x+1,
               cx for PrCh, bx for Par, ex for Pitch Bend....
               4th byte = Note
               5th byte = Velocity
            */
            System.out.println("Adding music to track");
            while (offset < music.length - 5) {

                int startDelayTime = ub2i(music[offset++]);
                int endDelayTime = ub2i(music[offset++]);
                int event = ub2i(music[offset++]);
                int data1 = ub2i(music[offset++]);
                int data2 = ub2i(music[offset++]);

                int tick = timeLine + startDelayTime;
                System.out.printf("Offset %X event %X timeline %d\n", offset, event & 0xFF, tick);

                ShortMessage msg = new ShortMessage();
                ShortMessage msg2 = null;

                try {
                    // For Midi event types see http://www.midi.org/techspecs/midimessages.php
                    switch (event & 0xF0) {
                    case ShortMessage.CONTROL_CHANGE:  // Control Change 0xB0
                    case ShortMessage.PITCH_BEND:  // Pitch Wheel Change 0xE0
                        msg.setMessage(event, data1, data2);
                        /*
                          writeChannel(midiChannelNumber, chunk[2], false);
                          writeChannel(midiChannelNumber, chunk[3], false);
                          writeChannel(midiChannelNumber, chunk[4], false);
                        */
                        break;

                    case ShortMessage.PROGRAM_CHANGE: // Program Change 0xC0
                    case ShortMessage.CHANNEL_PRESSURE: // Channel Pressure (After-touch) 0xD0
                        msg.setMessage(event, data1, 0);
                        break;

                    case 0x00:
                        // case 0x90:
                        // Note on
                        int note = data1;
                        int velocity = data2;

                        /* We have to generate a pair of note on/note off.
                           The C code manages getting the order of events

                           done correctly by keeping a list of note off events
                           and sticking them into the Midi sequence when appropriate.
                           The Java add() looks after timing for us, so we'll
                           generate a note off first and add it, and then do the note on
                        */
                        System.out.printf("Note on %s at %d, off at %d at offset %X channel %d\n",
                                          getKeyName(note),
                                          tick, tick + endDelayTime, offset, (event &0xF)+1);
                        // ON
                        msg.setMessage(ShortMessage.NOTE_ON | (event & 0xF),
                                       note, velocity);

                        // OFF
                        msg2 = new ShortMessage();
                        msg2.setMessage(ShortMessage.NOTE_OFF  | (event & 0xF),
                                        note, velocity);

                        break;

                    case 0xF0: // System Exclusive
                        // We'll write the data as is to the buffer
                        offset -= 3;
                        // msg = SysexMessage();
                        while (music[offset] != (byte) 0xF7) // bytes only go upto 127 GRRRR!!!
                            {
                                //writeChannel(midiChannelNumber, midiData[midiOffset], false);
                                System.out.printf("sysex: %x\n", music[offset]);
                                offset++;
                                if (offset >= music.length) {
                                    System.err.println("Run off end of array while processing Sysex");
                                    break;
                                }

                            }
                        //writeChannel(midiChannelNumber, midiData[midiOffset], false);
                        offset++;
                        System.out.printf("Ignoring sysex %02X\n", event);

                        // ignore the message for now
                        continue;
                        // break;

                    default:
                        System.out.printf("Unrecognized code %02X\n", event);
                        continue;
                    }
                } catch(InvalidMidiDataException e) {
                    e.printStackTrace();
                }

                addMsgToTrack(msg, track, tick);
                if (msg2 != null ) {
                    if (endDelayTime <= 0) System.out.println("Start and end at same time");
                    addMsgToTrack(msg2, track, tick + endDelayTime);
                    msg2 = null;
                }

                timeLine = tick;
            }
        }
    }
}

```

支持类在`LZW.java`里。

```sh
/**
 * Based on code by Mark Nelson
 * http://marknelson.us/1989/10/01/lzw-data-compression/
 */

public class LZW {

    private final int BITS = 12;                   /* Setting the number of bits to 12, 13*/
    private final int HASHING_SHIFT = (BITS-8);    /* or 14 affects several constants.    */
    private final int MAX_VALUE = (1 << BITS) - 1; /* Note that MS-DOS machines need to   */
    private final int MAX_CODE = MAX_VALUE - 1;    /* compile their code in large model if*/
    /* 14 bits are selected.               */

    private final int TABLE_SIZE = 5021;           /* The string table size needs to be a */
    /* prime number that is somewhat larger*/
    /* than 2**BITS.                       */
    private final int NEXT_CODE = 257;

    private long[] prefix_code = new long[TABLE_SIZE];;        /* This array holds the prefix codes   */
    private int[] append_character = new int[TABLE_SIZE];      /* This array holds the appended chars */
    private int[] decode_stack; /* This array holds the decoded string */

    private int input_bit_count=0;
    private long input_bit_buffer=0; // must be 32 bits
    private int offset = 0;

    /*
    ** This routine simply decodes a string from the string table, storing
    ** it in a buffer.  The buffer can then be output in reverse order by
    ** the expansion program.
    */
    /* JN: returns size of buffer used
     */
    private int decode_string(int idx, long code)
    {
        int i;

        i=0;
        while (code > (NEXT_CODE - 1))
            {
                decode_stack[idx++] = append_character[(int) code];
                code=prefix_code[(int) code];
                if (i++>=MAX_CODE)
                    {
                        System.err.printf("Fatal error during code expansion.\n");
                        return 0;
                    }
            }

        decode_stack[idx]= (int) code;

        return idx;
    }

    /*
    ** The following two routines are used to output variable length
    ** codes.  They are written strictly for clarity, and are not
    ** particularyl efficient.
    */

    long input_code(byte[] inputBuffer, int inputLength, int dummy_offset, boolean firstTime)
    {
        long return_value;

        //int pOffsetIdx = 0;
        if (firstTime)

            {
                input_bit_count = 0;
                input_bit_buffer = 0;
            }

        while (input_bit_count <= 24 && offset < inputLength)
            {
                /*
                input_bit_buffer |= (long) inputBuffer[offset++] << (24 - input_bit_count);
                input_bit_buffer &= 0xFFFFFFFFL;
                System.out.printf("input buffer %d\n", (long) inputBuffer[offset]);
                */
                // Java doesn't have unsigned types. Have to play stupid games when mixing
                // shifts and type coercions
                long val = inputBuffer[offset++];
                if (val < 0) {
                    val = 256 + val;
                }
                // System.out.printf("input buffer: %d\n", val);
                //if ( ((long) inpu) < 0) System.out.println("Byte is -ve???");
                input_bit_buffer |= (((long) val) << (24 - input_bit_count)) & 0xFFFFFFFFL;
                //input_bit_buffer &= 0xFFFFFFFFL;
                // System.out.printf("input bit buffer %d\n", input_bit_buffer);

                /*
                if (input_bit_buffer < 0) {
                    System.err.println("Negative!!!");
                }
                */

                input_bit_count  += 8;
            }

        if (offset >= inputLength && input_bit_count < 12)
            return MAX_VALUE;

        return_value       = input_bit_buffer >>> (32 - BITS);
        input_bit_buffer <<= BITS;
        input_bit_buffer &= 0xFFFFFFFFL;
        input_bit_count   -= BITS;

        return return_value;
    }

    void dumpLyric(int data)
    {
        System.out.printf("LZW: %d\n", data);
        if (data == 0xd)
            System.out.printf("\n");
    }

    /*
    **  This is the expansion routine.  It takes an LZW format file, and expands
    **  it to an output file.  The code here should be a fairly close match to
    **  the algorithm in the accompanying article.
    */

    public int expand(byte[] intputBuffer, int inputBufferSize, byte[] outBuffer)
    {
        long next_code = NEXT_CODE;/* This is the next available code to define */
        long new_code;
        long old_code;
        int character;
        int string_idx;

        int offsetOut = 0;

        prefix_code      = new long[TABLE_SIZE];
        append_character = new int[TABLE_SIZE];
        decode_stack     = new int[4000];

        old_code= input_code(intputBuffer, inputBufferSize, offset, true);  /* Read in the first code, initialize the */
        character = (int) old_code;          /* character variable, and send the first */
        outBuffer[offsetOut++] = (byte) old_code;       /* code to the output file                */
        //outTest(output, old_code);
        // dumpLyric((int) old_code);

        /*
        **  This is the main expansion loop.  It reads in characters from the LZW file
        **  until it sees the special code used to inidicate the end of the data.
        */
        while ((new_code=input_code(intputBuffer, inputBufferSize, offset, false)) != (MAX_VALUE))
            {
                // dumpLyric((int)new_code);
                /*
                ** This code checks for the special STRING+CHARACTER+STRING+CHARACTER+STRING
                ** case which generates an undefined code.  It handles it by decoding
                ** the last code, and adding a single character to the end of the decode string.
                */

                if (new_code>=next_code)
                    {
                        if (new_code > next_code)
                            {
                                System.err.printf("Invalid code: offset:%X new:%X next:%X\n", offset, new_code, next_code);
                                break;
                            }

                        decode_stack[0]= (int) character;
                        string_idx=decode_string(1, old_code);
                    }
                else
                    {
                        /*
                        ** Otherwise we do a straight decode of the new code.
                        */

                        string_idx=decode_string(0,new_code);
                    }

                /*
                ** Now we output the decoded string in reverse order.
                */
                character=decode_stack[string_idx];
                while (string_idx >= 0)
                    {
                        int data = decode_stack[string_idx--];
                        outBuffer[offsetOut] = (byte) data;
                        //outTest(output, *string--);

                        if (offsetOut % 4 == 0) {
                            //dumpLyric(data);
                        }

                        offsetOut++;
                    }

                /*
                ** Finally, if possible, add a new code to the string table.
                */
                if (next_code > 0xfff)
                    {
                        next_code = NEXT_CODE;
                        System.err.printf("*");
                    }

                // test code
                if (next_code > 0xff0 || next_code < 0x10f)
                    {
                        Debug.printf("%02X ", new_code);
                    }

                prefix_code[(int) next_code]=old_code;
                append_character[(int) next_code] = (int) character;
                next_code++;

                old_code=new_code;
            }
        Debug.printf("offset out is %d\n", offsetOut);
        return offsetOut;

    }
}

```

这里是`SongInformation.java`:

```sh
public class SongInformation {

    // Public fields of each song record
    /**
     *  Song number in the file, one less than in songbook
     */
    public long number;

    /**
     * song title in Unicode
     */
    public String title;

    /**
     * artist in Unicode
     */
    public String artist;

    /**
     * integer value of language code
     */
    public int language;

    public static final int  KOREAN = 0;
    public static final int  CHINESE1 = 1;
    public static final int  CHINESE2 = 2;
    public static final int  TAIWANESE3 = 3 ;
    public static final int  JAPANESE = 4;
    public static final int  RUSSIAN = 5;
    public static final int  THAI = 6;
    public static final int  TAIWANESE7 = 7;
    public static final int  CHINESE8 = 8;
    public static final int  CANTONESE = 9;
    public static final int  ENGLISH = 0x12;
    public static final int  VIETNAMESE = 0x13;
    public static final int  PHILIPPINE = 0x14;
    public static final int  TURKEY = 0x15;
    public static final int  SPANISH = 0x16;
    public static final int  INDONESIAN = 0x17;
    public static final int  MALAYSIAN = 0x18;
    public static final int  PORTUGUESE = 0x19;
    public static final int  FRENCH = 0x20;
    public static final int  INDIAN = 0x21;
    public static final int  BRASIL = 0x22;
    public static final int  CHINESE131 = 131;
    public static final int  ENGLISH146 = 146;
    public static final int  PHILIPPINE148 = 148;

    public SongInformation(long number,
                           String title,
                           String artist,
                           int language) {
        this.number = number;
        this.title = title;
        this.artist = artist;
        this.language = language;
    }

    public String toString() {
        return "" + (number+1) + " (" + language + ") \"" + title + "\" " + artist;
    }

    public boolean titleMatch(String pattern) {
        // System.out.println("Pattern: " + pattern);
        return title.matches("(?i).*" + pattern + ".*");
    }

    public boolean artistMatch(String pattern) {
        return artist.matches("(?i).*" + pattern + ".*");
    }

    public boolean numberMatch(String pattern) {
        Long n;
        try {
            n = Long.parseLong(pattern) - 1;
            //System.out.println("Long is " + n);
        } catch(Exception e) {
            //System.out.println(e.toString());
            return false;
        }
        return number == n;
    }

    public boolean languageMatch(int lang) {
        return language == lang;
    }
}

```

这里是`Debug.java`:

```sh
public class Debug {

    public static final boolean DEBUG = false;

    public static void println(String str) {
        if (DEBUG) {
            System.out.println(str);
        }
    }

    public static void printf(String format, Object... args) {
        if (DEBUG) {
            System.out.printf(format, args);
        }
    }
}

```

要编译这些代码，请运行以下命令:

```sh
    javac SongExtracter.java LZW.java Debug.java SongInformation.java

```

使用以下命令运行:

```sh
java SongExtracter <song number >

```

把这些 MIDI 文件转换成卡拉 KAR 文件的程序是`KARConverter.java`。

```sh
      /*
 * KARConverter.java
 *
 * The output from decodnig the Sonken data is not in
 * the format required by the KAR "standard".
 * e.g. we need @T for the title,
 * and LYRIC events need to be changed to TEXT events
 * Tempo has to be changed too
 *
 */

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

import javax.sound.midi.MidiSystem;
import javax.sound.midi.InvalidMidiDataException;
import javax.sound.midi.Sequence;
import javax.sound.midi.Track;
import javax.sound.midi.MidiEvent;
import javax.sound.midi.MidiMessage;
import javax.sound.midi.ShortMessage;
import javax.sound.midi.MetaMessage;
import javax.sound.midi.SysexMessage;
import javax.sound.midi.Receiver;

public class KARConverter {
    private static int LYRIC = 5;
    private static int TEXT = 1;

    private static boolean firstLyricEvent = true;

    public static void main(String[] args) {
        if (args.length != 1) {
            out("KARConverter: usage:");
            out("\tjava KARConverter <file>");
            System.exit(1);
        }
        /*
         *      args[0] is the common prefix of the two files
         */
        File    inFile = new File(args[0] + ".mid");
        File    outFile = new File(args[0] + ".kar");

        /*
         *      We try to get a Sequence object, which the content
         *      of the MIDI file.
         */
        Sequence        inSequence = null;
        Sequence        outSequence = null;
        try {
            inSequence = MidiSystem.getSequence(inFile);
        } catch (InvalidMidiDataException e) {
            e.printStackTrace();
            System.exit(1);
        } catch (IOException e) {

            e.printStackTrace();
            System.exit(1);
        }

        if (inSequence == null) {
            out("Cannot retrieve Sequence.");
        } else {
            try {
                outSequence = new Sequence(inSequence.getDivisionType(),
                                           inSequence.getResolution());
            } catch(InvalidMidiDataException e) {
                e.printStackTrace();
                System.exit(1);
            }

            createFirstTrack(outSequence);
            Track[]     tracks = inSequence.getTracks();
            fixTrack(tracks[0], outSequence);
        }
        FileOutputStream outStream = null;
        try {
            outStream = new FileOutputStream(outFile);
            MidiSystem.write(outSequence, 1, outStream);
        } catch(Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    public static void fixTrack(Track oldTrack, Sequence seq) {
        Track lyricTrack = seq.createTrack();
        Track dataTrack = seq.createTrack();

        int nEvent = fixHeader(oldTrack, lyricTrack);
        System.out.println("nEvent " + nEvent);
        for ( ; nEvent < oldTrack.size(); nEvent++) {
            MidiEvent event = oldTrack.get(nEvent);
            if (isLyricEvent(event)) {
                event = convertLyricToText(event);
                lyricTrack.add(event);
            } else {
                dataTrack.add(event);
            }
        }

    }

    public static int fixHeader(Track oldTrack, Track lyricTrack) {
        int nEvent;

        // events at 0-10 are meaningless
        // events at 11, 12 should be the language code,
        // but maybe at 12, 13
        nEvent = 11;
        MetaMessage lang1 = (MetaMessage) (oldTrack.get(nEvent).getMessage());
        String val = new String(lang1.getData());
        if (val.equals("@")) {
            // try 12
            lang1 = (MetaMessage) (oldTrack.get(++nEvent).getMessage());
        }
        MetaMessage lang2 = (MetaMessage) (oldTrack.get(++nEvent).getMessage());
        String lang = new String(lang1.getData()) +
            new String(lang2.getData());
        System.out.println("Lang " + lang);
        byte[] karLang = getKARLang(lang);

        MetaMessage msg = new MetaMessage();
        try {
            msg.setMessage(TEXT, karLang, karLang.length);
            MidiEvent evt = new MidiEvent(msg, 0L);
            lyricTrack.add(evt);
        } catch(InvalidMidiDataException e) {
        }

        // song title is next
        StringBuffer titleBuff = new StringBuffer();
        for (nEvent = 15; nEvent < oldTrack.size(); nEvent++) {
            MidiEvent event = oldTrack.get(nEvent);
            msg = (MetaMessage) (event.getMessage());
            String contents = new String(msg.getData());
            if (contents.equals("@")) {
                break;

            }
            if (contents.equals("\r\n")) {
                continue;
            }
            titleBuff.append(contents);
        }
        String title = "@T" + titleBuff.toString();
        System.out.println("Title '" + title +"'");
        byte[] titleBytes = title.getBytes();

        msg = new MetaMessage();
        try {
            msg.setMessage(TEXT, titleBytes, titleBytes.length);
            MidiEvent evt = new MidiEvent(msg, 0L);
            lyricTrack.add(evt);
        } catch(InvalidMidiDataException e) {
        }

        // skip the next 2 @'s
        for (int skip = 0; skip < 2; skip++) {
            for (++nEvent; nEvent < oldTrack.size(); nEvent++) {
                MidiEvent event = oldTrack.get(nEvent);
                msg = (MetaMessage) (event.getMessage());
                String contents = new String(msg.getData());
                if (contents.equals("@")) {
                    break;
                }
            }
        }

        // then the singer
        StringBuffer singerBuff = new StringBuffer();
        for (++nEvent; nEvent < oldTrack.size(); nEvent++) {
            MidiEvent event = oldTrack.get(nEvent);
            if (event.getTick() != 0) {
                break;
            }
            if (! isLyricEvent(event)) {
                break;

            }

            msg = (MetaMessage) (event.getMessage());
            String contents = new String(msg.getData());
            if (contents.equals("\r\n")) {
                continue;
            }
            singerBuff.append(contents);
        }
        String singer = "@T" + singerBuff.toString();
        System.out.println("Singer '" + singer +"'");

        byte[] singerBytes = singer.getBytes();

        msg = new MetaMessage();
        try {
            msg.setMessage(1, singerBytes, singerBytes.length);
            MidiEvent evt = new MidiEvent(msg, 0L);
            lyricTrack.add(evt);
        } catch(InvalidMidiDataException e) {
        }

        return nEvent;
    }

    public static boolean isLyricEvent(MidiEvent event) {
        if (event.getMessage() instanceof MetaMessage) {
            MetaMessage msg = (MetaMessage) (event.getMessage());
            if (msg.getType() == LYRIC) {
                return true;
            }
        }
        return false;
    }

    public static MidiEvent convertLyricToText(MidiEvent event) {
        if (event.getMessage() instanceof MetaMessage) {
            MetaMessage msg = (MetaMessage) (event.getMessage());

            if (msg.getType() == LYRIC) {
                byte[] newMsgData = null;
                if (firstLyricEvent) {
                    // need to stick a \ at the front
                    newMsgData = new byte[msg.getData().length + 1];
                    System.arraycopy(msg.getData(), 0, newMsgData, 1, msg.getData().length);
                    newMsgData[0] = '\\';
                    firstLyricEvent = false;
                } else {
                    newMsgData = msg.getData();
                    if ((new String(newMsgData)).equals("\r\n")) {
                        newMsgData = "\\".getBytes();
                    }
                }
                try {
                    /*
                    msg.setMessage(TEXT,
                                   msg.getData(),
                                   msg.getData().length);
                    */
                    msg.setMessage(TEXT,
                                   newMsgData,
                                   newMsgData.length);
                } catch(InvalidMidiDataException e) {
                    e.printStackTrace();
                }
            }
        }
        return event;
    }

    public static byte[] getKARLang(String lang) {
        System.out.println("lang is " + lang);
        if (lang.equals("12")) {
            return "@LENG".getBytes();
        }

        // don't know any other language specs, so guess
        if (lang.equals("01")) {
            return "@LCHI".getBytes();
        }
        if (lang.equals("02")) {
            return "@LCHI".getBytes();
        }
        if (lang.equals("08")) {
            return "@LCHI".getBytes();
        }
        if (lang.equals("09")) {
            return "@LCHI".getBytes();
        }
        if (lang.equals("07")) {
            return "@LCHI".getBytes();
        }
        if (lang.equals("")) {
            return "@L".getBytes();
        }
        if (lang.equals("")) {
            return "@LENG".getBytes();
        }
        if (lang.equals("")) {
            return "@LENG".getBytes();
        }
        if (lang.equals("")) {
            return "@LENG".getBytes();
        }
        if (lang.equals("")) {
            return "@LENG".getBytes();
        }
        if (lang.equals("")) {
            return "@LENG".getBytes();
        }

        return ("@L" + lang).getBytes();
    }

    public static void copyNotesTrack(Track oldTrack, Sequence seq) {
        Track newTrack = seq.createTrack();

        for (int nEvent = 0; nEvent < oldTrack.size(); nEvent++)
            {
                MidiEvent event = oldTrack.get(nEvent);

                newTrack.add(event);
            }

    }

    public static void createFirstTrack(Sequence sequence) {
        Track track = sequence.createTrack();
        MetaMessage msg1 = new MetaMessage();
        MetaMessage msg2 = new MetaMessage();

        byte data[] = "Soft Karaoke".getBytes();
        try {
            msg1.setMessage(3, data, data.length);
        } catch(InvalidMidiDataException e) {
            e.printStackTrace();
            return;
        }
        MidiEvent event = new MidiEvent(msg1, 0L);
        track.add(event);

        data = "@KMIDI KARAOKE FILE".getBytes();
        try {
            msg2.setMessage(1, data, data.length);
        } catch(InvalidMidiDataException e) {
            e.printStackTrace();
            return;
        }
        MidiEvent event2 = new MidiEvent(msg2, 0L);
        track.add(event2);
    }

    public static void output(MidiEvent event)
    {
        MidiMessage     message = event.getMessage();
        long            lTicks = event.getTick();
    }

    private static void out(String strMessage)
    {
        System.out.println(strMessage);
    }

}

/*** KARConverter.java ***/

```

## 播放 MIDI 文件

从光盘中提取的 MIDI 文件可以使用标准的 MIDI 播放器播放，例如 Timothy。歌词包括在内，旋律线在 MIDI 通道 1。我已经用 Swing 和 Java Sound framework 编写了一批 Java 程序，它们可以播放 MIDI 文件并对其进行处理。在播放 MIDI 文件的同时，我还可以做一些很酷的Karaoke 的事情比如显示歌词，显示应该播放的音符，通过歌词显示进度。

## 播放 WMA 文件

WMA 档案是“邪恶的”它们基于两种微软专有格式。第一种是高级系统格式(ASF)文件格式，它描述了音乐数据的“容器”。第二个是 Windows Media Audio 9 编解码器。

ASF 是首要问题。微软有一个公开的规范( [`www.microsoft.com/en-us/download/details.aspx?id=14995`](http://www.microsoft.com/en-us/download/details.aspx?id=14995) )，强烈反对任何开源的东西。许可证规定，如果您基于该规范构建一个实现，那么您:

*   无法分发源代码
*   只能分发目标代码
*   除非作为“解决方案”的一部分，否则不能分发目标代码(换句话说，库似乎是被禁止的)
*   不能免费分发您的目标代码
*   无法将您的许可证设置为允许衍生作品

更何况 2012 年 1 月 1 日之后不允许你开始任何新的执行，而且已经是 2017 年 1 月了！

只是说的更难听一点，微软有专利 6041345，“用于容纳多个媒体流的活动流格式”( [`www.google.com/patents/US6041345`](http://www.google.com/patents/US6041345) )，是 1997 年申请的。该专利似乎覆盖了与当时存在的许多其他格式相同的领域，因此该专利的地位(如果受到质疑)尚不清楚。但是，它已经被用来阻止 GPL 授权的项目 VirtualDub ( [`www.advogato.org/article/101.html`](http://www.advogato.org/article/101.html) )支持 ASF。无论如何，文件格式的专利状态有点可疑，但在 Oracle 赢得或失去 Java API 的专利声明后，可能会变得更加清晰。

尽管如此，FFmpeg 项目( [`http://ffmpeg.org/`](http://ffmpeg.org/) )还是完成了 ASF 的净室实现，对文件格式进行逆向工程，并且根本不使用 ASF 规范。它还逆向工程 WMA 编解码器。这使得像 MPlayer 和 VLC 这样的播放器可以播放 ASF/WMA 文件。FFmpeg 本身也可以从 ASF/WMA 转换成更好的格式，比如 Ogg Vorbis。

没有用于 WMA 文件的 Java 处理程序，考虑到许可，除非它是基于 FFmpeg 的，否则不太可能有。

我从 DVD 中提取的 WMA 文件具有以下特征:

*   每个文件有两个通道。
*   每个声道传送一个单声道信号。
*   右声道承载所有乐器、伴唱以及主唱。
*   左声道承载所有乐器和伴唱，但不承载主唱。

如果没有人对着麦克风唱歌，Sonken player 会播放右声道，但一旦有人对着麦克风唱歌，就会切换到左声道(有效地静音主唱)。简单有效。

歌词仍然作为 MIDI 存在于音轨数据中，并且可以像以前一样被提取。它们可以由 MIDI 播放器播放。我还不知道如何同步播放 MIDI 和 WMA 文件。

## KAR 格式

生成的 MIDI 文件不是 KAR 格式。这意味着 pykaraoke 等Karaoke 播放器可能会在播放它们时出现问题。将文件转换成这种格式并不太难:在序列中循环，适当地编写或修改 MIDI 事件。这个程序不是很令人兴奋，但是可以作为 KARConverter 下载。

## 与 pykar 一起播放歌曲

播放卡拉 MIDI 文件最简单的方法之一是使用 pykar ( [`www.kibosh.org/pykaraoke/`](http://www.kibosh.org/pykaraoke/) )。遗憾的是，从 Sonken 光盘中翻录的歌曲无法正常播放。这是因为 pykar 中的错误和未提供的所需特性的混合。问题及其解决方案如下。

### 拍子

许多 MIDI 文件会使用元事件设定速度 0x51 来明确设定速度。这些文件通常不会。pykar 希望 MIDI 文件包含此事件，否则默认为每分钟零拍的速度。正如所料，这将丢弃 pykar 执行的所有计时计算。

正如 Sonic Spot ( [`www.sonicspot.com/guide/midifiles.html`](http://www.sonicspot.com/guide/midifiles.html) )解释的那样，“如果没有设定的速度事件，则假定每分钟 120 拍。”它给出了一个计算合适的速度值的公式，即 60000000/120。

这需要对一个 pykaraoke 文件进行一次更改:将`pykar.py`的第 190 行更改如下:

```sh
sele.Tempo = [(0, 0)]

```

对此:

```sh
self.Tempo = [(0, 500000)]

```

### 语言编码

文件`pykdb.py`声称`cp1252`是Karaoke 文件的默认字符编码，并使用一种叫做`DejaVuSans.t`的字体，这种字体适合显示这样的字符。除了标准 ASCII 之外，这种编码还在一个字节的前 128 位中添加了各种欧洲符号，例如“”。

我不确定 pykaraoke 是从哪里得到这些信息的，但它肯定不适用于中国的Karaoke。我不知道中文、日文、韩文等使用什么编码，但是我的代码将它们作为 Unicode UTF-8 转储。适合 Unicode 的字体是`Cyberbit.ttf`。(参见我在 [`http://jan.newmarch.name/i18n/`](http://jan.newmarch.name/i18n/) 的全球软件讲义中的“字体”一章)。)

文件`pykdb.py`需要以下几行:

```sh
        self.KarEncoding = 'cp1252'  # Default text encoding in karaoke files
        self.KarFont = FontData("DejaVuSans.ttf")

```

更改为以下内容:

```sh
        self.KarEncoding = 'utf-8'  # Default text encoding in karaoke files
        self.KarFont = FontData("Cyberbit.ttf")

```

并将`Cyberbit.tt`的副本复制到目录`/usr/share/pykaraoke/fonts/`中。

### 没有音符的歌曲

光盘上的一些歌曲没有 MIDI 音符，因为这些都在 WMA 文件中。MIDI 文件只有歌词。pykaraoke 只弹到最后一个音，也就是零音！所以，不放歌词。

## 结论

本章主要讨论了一个取证问题:当文件格式未知时，如何从 DVD 中获取信息。它与播放声音没有任何直接关系，尽管它确实给了我一个已经付费的文件的大来源。