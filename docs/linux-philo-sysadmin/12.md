# 12.使用常识命名

我在本书的几个地方提到过，打字不是我的强项，懒惰的系统管理员会尽一切可能减少打字。我对此很认真。这个原则对此进行了扩展，但是它不仅仅是减少我需要做的打字量。这也是关于脚本的可读性和命名的事情，以便他们更容易理解。

最初的 Unix 哲学原则之一——尽管是较次要的原则之一——是始终使用小写字母并保持名称简短。这是一个令人钦佩的目标，但在系统管理员的世界里却不那么容易实现。在许多方面，我自己的信条似乎是对原文的彻底驳斥。但是，最初的版本面向不同的受众，而这一版本面向具有不同需求的系统管理员。

我认为最终的目标是创建易读易懂的脚本，以便于维护。然后使用其他简单的脚本和 cron 作业来自动运行这些脚本。保持脚本名称的合理简短还可以减少从命令行执行这些脚本时的输入，但是当从另一个脚本或作为 cron 作业启动它们时，这几乎没有关系。

## 脚本和程序名称

dbu 这个程序名对你有什么意义吗？在你成为 Linux 极客之前，dd 这个程序名字对你来说有什么意义吗？这两个问题的答案可能都是否定的。虽然 dd 是一个常见的 GNU 实用程序“磁盘转储”，但 dbu 是我自己创建的一个 shell 脚本。这个名字对你来说毫无意义，但对我来说，它意味着大卫的备份。它很容易输入，一旦你知道它的意思，你就会记住它。

如果你研究了所有最初的 GNU 核心工具，你会发现它们的名字都很短——很多都是两三个字母。这很好，但是总共有成千上万的 Linux 命令，只有这么多有意义的简短组合。任何名称的一个属性应该是它与程序或脚本的目的有某种有意义的联系。

我们在第 [11](11.html) 章中为脚本使用的名称 mymotd 稍长一些，但也比使用较短名称的情况更有意义。我们可以使用 davesmotd、dmotd、mmotd、davesMOTD、dMOTD 或任何其他相对有意义的名称。一些名字中的大写字母确实有助于更容易辨别脚本的功能，但是它们确实使在命令行上键入名字有点困难。

和我的“dbu”程序一样，仍然有一些空间用于非常短的名字。例如，有一个名为“mtr”的非常好的程序，它是旧的 traceroute 程序的交互式替代程序。mtr 程序维护一个活动的、连续的 traceroute，动态显示每一跳丢失的数据包数量，如果数据包由于某种原因被重新路由，还可以显示多条路由。非常有趣和有用。

mtr 计划最初被命名是因为一个叫 Matt Kimball 的人编写并维护了它。因此，这是“马特的跟踪路线。”马特停止支持后，罗杰·沃尔夫接手。它仍被命名为 mtr，但现在代表“我的追踪路线”

用非常短的名字命名脚本可能是一个挑战，因为许多现有的短字母组合已经被采用。在给一个脚本命名时，我总是试图做一些研究，以确保它不会对我电脑上已经安装的可执行文件造成问题。我通常用`which`命令做一个快速检查，如实验 12-1 所示。

### 实验 12-1

因为我们没有将 mymotd 脚本复制到任何标准的可执行路径位置，所以当我们使用下面的命令时，它应该不会出现。

```sh
[root@david ~]# which mymotd
/usr/bin/which: no mymotd in (/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin)

```

`which`命令显示它在试图定位指定的可执行文件时搜索的路径。

不管它的完成状态如何，将 mymotd 脚本复制到/usr/local/bin，这是 Linux FHS 中存储本地创建的可执行文件的正确位置。然后再次运行`which`命令。

```sh
[root@testvm1 student]# cp mymotd /usr/local/bin
[root@testvm1 student]# which mymotd
/usr/local/bin/mymotd

```

我们已经确定当前没有安装可能导致我们为文件选择的名称出现问题的可执行文件，然后我们将可执行文件复制到适当的位置。

不是所有的冲突都会在你第一次写新剧本的时候出现。检查完安装的程序后，我还会进行谷歌搜索。我试图找到任何与我的程序有命名冲突的信息。较长的名字冲突的可能性要小得多，但是它们真的不需要太长。

我曾经遇到过这样一种情况，问题出现得很晚。我试图用`yum,`安装一个新程序，和它的继任者`dnf`一样，它是`rpm`命令的包装器。我收到一个错误，指出需要从新的 RPM 包中安装的一个文件与另一个包中同名的文件冲突。

这不是我的一个脚本，而是另一对冲突的 rpm。我能够通过删除已经安装的 RPM 来消除冲突，因为不再需要它了。

这种类型的冲突应该非常罕见。即使文件具有相同的名称(这首先是不太可能的),只要它们位于不同的目录中，它们在安装过程中就不会冲突。但是，如果它们都是可执行文件，并且位于$PATH 的不同目录中，则位于$PATH 中列出的第一个目录中的文件将由命令运行。要运行另一个，您需要使用完全限定的路径名来确保运行正确的程序。

像这样的潜在冲突，命名脚本可能有点棘手。我喜欢使用稍微长一点的脚本名，比如 4 到 8 个或 10 个字符，是为了防止命名冲突。我有时会在我的脚本名称中添加一个大写字母，以帮助它脱颖而出，并在一个长列表中帮助澄清名称。

这里的底线是名称应该容易记忆和有意义——对您和其他系统管理员来说，容易键入，并且容易在列表中找到。这些是我个人的标准。你可以有其他的，这是非常好的。请记住，其他系统管理员可能有一天需要与您的脚本所在的主机一起工作。

## 变量

当我在 1981 年购买我的第一台 IBM 个人电脑时，我订购了最大 64KB 的主板 <sup>[1](#Fn1)</sup> ，而最便宜的型号只有 16K。这不是一个很大的工作空间。BASIC 包含在 PC 的一个板载 ROM 中，是当时许多学习编程的人的一个很好的选择。

因为空间有限，所以在用 BASIC 编写程序时节约内存是很重要的。我没有把它做得看起来很像缩进循环和子程序，因为每个制表符或空格占用了一个字节的内存，而这个内存可能是一些重要的东西所需要的。我尽可能保持变量名的简短。我通常使用单字母或双字符变量名，包括一个字母和一个数字，比如 A7。如果我们编写相当大的程序，注释是不存在的，因为没有空间容纳它们。我做这些都是为了节省内存。但是这使得我的程序很难阅读。

我希望我保存了一些我自己写的或者我不得不修改的由别人写的非常糟糕的代码。两者都有很多。

### 命名变量

我倾向于让我的脚本变量足够长，以表示它们的内容，就像你在第 [11](11.html) 章的项目中看到的那样。这些变量名的长度从相当短到适中不等。所有这些都是为了让我自己和未来的脚本维护者更容易阅读和理解代码。

我的脚本中的变量名倾向于反映它们的内容。因此，您应该能够推断出名为$CPUArch 的变量可能包含有关 CPU 架构的信息。您可能不知道数据的确切类型，但是在查看该变量的内容时，您应该有一个大致的概念。对于该变量的值，您可能会看到类似“X86_64”或“64”的内容。至少在我的剧本里，是这样的。

需要记住的是，变量名只在编写和维护脚本时输入。该脚本可以根据需要运行多次，我永远不需要输入任何变量名。

### 让一切都成为变量

这是一个非常常见的最佳实践。即使您需要使用像圆周率、欧拉常数或与特定领域相关的常数这样的“常数”,也应该将它们声明为变量，然后在计算中使用该变量。当然，bash 本身只做整数运算，但是还有其他类型的变量。

我喜欢在脚本中使用变量作为路径和文件名。我还为将要打印的数据使用了变量，比如上一章中的 mymotd 脚本。正如我们在脚本中所做的那样，使用$Date、$host、$MachineType、$MotherboardModel 等变量可以更容易地阅读和理解功能。当我看到类似图 [12-1](#Fig1) 中的语句时，我立刻明白了代码应该完成什么——即使它与这里的上下文无关。我们期望找到的分配给变量的类型值是清楚的。

![../images/462716_1_En_12_Chapter/462716_1_En_12_Fig1_HTML.png](../images/462716_1_En_12_Chapter/462716_1_En_12_Fig1_HTML.png)

图 12-1

从变量名可以明显看出变量的期望内容

您应该能够从变量名中推断出一点代码是如何工作的。显然，dmidecode 实用程序用于获取有关主板的信息，而“type”2 是主板信息。它还告诉我们包含字符串“Name”的输出行包含我们正在寻找的特定信息。剩下的代码是提取包含模型信息的数据字符串，并清理它以供我们的脚本使用。

所以我们来试试这个小实验来说明。

### 实验 12-2

在一行中输入以下故意不正确的命令行程序。

```sh
[root@david ~]# MotherboardModel=`dmidecode -t 2 | grep Version | awk -F: '{print $2}' | sed -e "s/^ //"`;echo $MotherboardModel
Rev 1.xx

```

变量值显然是错误的，因为数据与变量名的预期值不匹配。这显然不是主板的型号，而是修订版号。

现在使用下面更正的代码。又是一行。

```sh
[root@david ~]# MotherboardModel=`dmidecode -t 2 | grep Name | awk -F: '{print $2}' | sed -e "s/^ //"`;echo $MotherboardModel
TUF X299 MARK 2

```

即使我们在运行代码之前不知道主板的确切型号，结果显然更适合变量。

即使变量在赋值后只使用一次，这样做也是有意义的。我多次发现，在后来的脚本维护中，我添加了更多也使用该变量的代码。这节省了我在脚本中第二次或第三次输入长路径名的时间。

例如，如果我的脚本中有客户发票的路径名，~/Documents/business/Customer/Invoices，那么很容易设置一个变量，比如$Invoices，并在我的脚本中使用它，而不是完整的路径。这使得在脚本中的其他地方引用该变量也很容易。通过不必再次键入长路径名，我还防止了路径名中可能的键入错误，这将导致执行期间的错误。

很多时候，我从多个变量构建路径名，因为我需要额外的灵活性，这也减少了输入。例如，我的 rsbu 备份程序每天为一组新的备份使用一个新的目录。这棵树的结构是这样的。

```sh
/-
 |
 \-path to backup media
     |
     \Backups
         |
         |--host1
         |   |--2018-01-01
         |   |      \--data
         |   |--2018-01-02
         |   |      \--data
         |   |--2018-01-03
         |   |      \--data
         |   etc
         --host2
         |   |--2018-01-01
         |   |      \--data
         |   |--2018-01-02
         |   |      \--data
         |   |--2018-01-03
         |   |      \--data
        etc etc

```

每天为每个主机添加一个新的日期子目录。因此，我们需要创建一系列变量，用在可以生成这个目录结构的代码中。实验 12-3 给出了实现这一点的一种方法。

### 实验 12-3

我们不需要为这个实验创建脚本。输入以下命令开始安装。这些变量一旦在命令行定义，就一直是环境的一部分，直到使用`unset`命令取消设置或设置为 null。

```sh
[student@testvm1 ~]$ BasePath="/media/Backup-Drive/Backups"
[student@testvm1 ~]$ BackupDate=`date +%Y-%m-%d`
[student@testvm1 ~]$ YesterdaysDate=`date -d "now-1days" "+%Y-%m-%d"`

```

现在验证我们刚刚设置的变量的值。

```sh
[student@testvm1 ~]$ echo $BasePath;echo $BackupDate;echo $YesterdaysDate;echo $HOSTNAME
/media/Backup-Drive/Backups
2018-01-22
2018-01-21
testvm1

```

注意$HOSTNAME 变量是一个 BASH 内置变量，所以我们不需要设置它。现在，为该主机设置主备份路径。我使用这个程序来备份多台主机，所以我将每台主机的备份保存在一个单独的目录中。这对远程主机不起作用，但在本实验中这是一个很好的快捷方式。

```sh
[student@testvm1 ~]$ BackupPath="$BasePath/$HOSTNAME/"
[student@testvm1 ~]$ echo $BackupPath
/media/Backup-Drive/Backups/testvm1/

```

要完成当前备份路径，只需添加今天的日期。

```sh
[student@testvm1 ~]$ TodaysBackupPath="$BackupPath$BackupDate"
[student@testvm1 ~]$ echo $TodaysBackupPath
/media/Backup-Drive/Backups/testvm1/2018-01-22

```

但是因为我使用 rsync 和它的一些最有趣的特性， <sup>[2](#Fn2)</sup> ，我还需要为昨天的备份生成路径。

```sh
[student@testvm1 ~]$ YesterdaysBackupPath="$BackupPath$YesterdaysDate"
[student@testvm1 ~]$ echo $YesterdaysBackupPath
/media/Backup-Drive/Backups/testvm1/2018-01-21

```

我已经为昨天的备份生成了路径，这样 rsync 就可以简单地创建从昨天的备份文件到今天的目录的硬链接，并且只对已经更改的文件执行备份。

我在脚本的不同部分使用了这一系列包含路径元素的变量，以便为多台主机生成多条路径。对$BasePath 变量的修改也可以用来挂载我用于备份的外部硬盘驱动器。

尽管变量名相当长，但在脚本中输入它们相当容易。这些名字便于理解每个变量的功能以及它们如何融入整体。毫无疑问，这些名字可以变得更短，仍然可以理解，但我喜欢这样。

当然，有一些边缘情况，这些代码没有直接处理，但是我在脚本中有更复杂的代码来处理这些情况。我不想用边缘情况来混淆基础知识，例如没有以前的备份时会发生什么，以及如何处理以前的备份存在但不是昨天备份的可能性。实验 12-3 中定义的许多变量也被用来帮助处理那些边缘情况。

## 程序

Bash 是一种命令行语言，支持过程的使用。脚本中的过程就像变量一样需要名字。我们在第 [11](11.html) 章中创建的脚本包含几个过程，命名这些过程是为了提供对其功能的深入了解。

例如，Help()过程显然是为了打印帮助信息，而 GPL()过程打印 GPL 许可证声明。kb2gb()过程有点晦涩，但是只要稍微考虑一下，就应该清楚它是将千字节转换成千兆字节的。

## 主机

是的，主机——网络上的计算机——需要命名。大多数组织都有某种命名主机的惯例。我认识的大多数系统管理员都已经建立了某种约定，即使他们的组织并没有强制实施。

我工作过的一个地方使用主要的希腊和罗马神来命名他们的 Linux 服务器，而他们的 Unix 和 Linux 工作站接收次要神和神话人物的名字。其他地方用《星际迷航》或《T2》或《星球大战》中的名字来称呼他们的东道主。

大多数系统管理员都有家庭网络，我们都有自己使用的某种命名约定。无论是基于游戏，神话中的神和人物，孩子和孙子，鸟，宠物，船，电影，国家，矿物，亚原子粒子，化学物质，科学家的名字，还是其他什么，我都见过许多不同的约定。本·科顿，我的技术评论员，使用了他追逐风暴的地方的城镇名称。

我用埃塞克斯级航空母舰的名字称呼我家庭网络中的大多数主机，以此向我的父亲致敬，二战期间他在太平洋上的邦克山号上。对于这样一个两个单词的名字，我只是把这些单词放在一起创造了“bunkerhill”按照惯例，主机名总是小写。稍加测试就会发现，互联网 DNS 系统在执行查找时会忽略大小写，但我确实喜欢按照惯例来处理这类事情。

## 组织命名

许多组织都有定义良好的命名约定，而其他组织则将这些细节留给系统管理员。

我工作过的一些组织有命名主机、其他网络节点、程序和脚本的惯例。我认为这有点矫枉过正，但是有一个广泛的、有良好文档记录的约定总比没有好。

我工作过的大多数地方都有网络主机和节点的命名约定，但是大多数低级别的命名(比如脚本)都留给了系统管理员。这是我喜欢的情况。大多数组织不需要如此详细地处理命名约定。

无论您在系统管理员级别有什么约定，都应该被很好地记录下来。

## 摘要

对于系统管理员来说，与 Linux 哲学的其他原则一样，在为文件、过程、脚本、变量和其他任何东西创建名称时，没有一种特定的“正确”方法。这真的是关于什么最适合你。除了对你来说有意义和有意义的东西之外，你不应该感到有任何压力。

命名的常识是这里真正的关键。我使用的主要标准是，“几年后当脚本需要维护时，这个名称对我或另一个系统管理员有意义吗？”

系统管理员在命名事物时使用常识有助于我们成为懒惰的系统管理员。易于阅读的代码比不易于阅读的代码需要更少的维护时间。在完全重写之前，必须维护写得很差的难以理解的代码，这耗费了大量的时间和精力，这些时间和精力本可以更好地用在其他地方。

<aside class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

通过直接插入系统总线的附加板，可以为 PC 增加更多的内存。我后来添加了一个 256KB 的内存适配器，这是我用零件构建的。

  [2](#Fn2_source)

下面是我写的一篇关于使用 rsync 进行备份的文章的链接: [`https://opensource.com/article/17/1/rsync-backup-linux`](https://opensource.com/article/17/1/rsync-backup-linux)

 </aside>