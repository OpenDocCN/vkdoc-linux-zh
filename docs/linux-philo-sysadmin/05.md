# 5.一切都是一个文件

这是使 Linux 特别灵活和强大的最重要的概念之一:一切都是文件。也就是说，一切都可以是数据流的源，数据流的目标，或者在许多情况下两者都是。在这一章中，你将探索“一切都是一个文件”的真正含义，并学习作为一名系统管理员如何利用它。

> “一切都是一个文件”的全部意义在于……你可以使用普通的工具来操作不同的东西。
> 
> —电子邮件中的莱纳斯·托瓦尔兹

## 什么是文件？

这是给你的一个难题。下列哪些是文件？

*   目录

*   外壳脚本

*   运行终端模拟器

*   文档库

*   串行端口

*   内核数据结构

*   内核调整参数

*   硬盘-/开发/sda

*   /dev/null

*   分区- /dev/sda1

*   逻辑卷(LVM)-/开发/映射器/卷 1-tmp

*   打印机

*   套接字

对 Unix 和 Linux 来说，它们都是文件，这是计算史上最惊人的概念之一。它使一些非常简单但功能强大的方法成为可能，这些方法用于执行许多管理任务，否则这些任务可能极其困难或不可能。

Linux 几乎把所有东西都当作文件来处理。这有一些有趣和惊人的含义。这个概念使得复制整个硬盘成为可能，包括引导记录，因为整个硬盘是一个文件，就像单独的分区一样。

“一切都是一个文件”是可能的，因为所有的设备都是由 Linux 实现的，这些东西被称为设备文件。设备文件不是设备驱动程序；相反，它们是暴露给用户的设备的网关。

## 设备文件

设备文件在技术上被称为设备专用文件。 <sup>[1](#Fn1)</sup> 设备文件被用来提供操作系统，更重要的是，在开放的操作系统中，提供给用户一个到他们所代表的设备的接口。所有 Linux 设备文件都位于/dev 目录中，该目录是根(/)文件系统不可或缺的一部分，因为它们必须在引导过程的早期阶段(在挂载其他文件系统之前)对操作系统可用。

### 设备文件创建

udev 守护进程旨在简化/dev 目录中充斥着大量几乎不需要的设备的混乱局面。理解 udev 如何工作是处理设备，尤其是热插拔设备以及如何管理它们的关键。

/dev/目录一直是所有 Unix 和 Linux 操作系统中设备文件的位置。过去，设备文件是在创建操作系统时创建的。这意味着所有可能在系统中使用的设备都需要提前创建。事实上，需要创建成千上万的设备文件来处理所有的可能性。很难确定哪个设备文件实际上与特定的物理设备相关，或者某个设备是否丢失。

## udev 简化

udev 旨在通过在/dev 中只为那些在引导时实际存在或者很可能实际存在于主机上的设备创建条目来简化这个问题。这大大减少了所需设备文件的总数。

此外，udev 会在设备插入系统时为其指定名称，例如 USB 存储器和打印机，以及其他非 USB 类型的设备。事实上，udev 将所有设备都视为即插即用，或者像有些人喜欢说的那样，即插即用，甚至在启动时也是如此。这使得在任何时候处理设备都是一致的，无论是在引导时还是以后热插拔时。

让我们用一个实验来看看这是如何工作的。

### 实验 5-1

以 root 用户身份执行此实验。

插上之前准备好的 u 盘。如果您使用的是虚拟机，您可能还必须使该设备对虚拟机可用。

输入这些命令。

```sh
[root@testvm1 dev]# cd /dev ; ls -l sd*
brw-rw---- 1 root disk 8,  0 Nov 22 03:50 sda
brw-rw---- 1 root disk 8,  1 Nov 22 03:50 sda1
brw-rw---- 1 root disk 8,  2 Nov 22 03:50 sda2
brw-rw---- 1 root disk 8, 16 Nov 28 14:02 sdb
brw-rw---- 1 root disk 8, 17 Nov 28 14:02 sdb1

```

查看 USB 设备上的日期和时间，在我的主机中分别是/dev/sdb 和/dev/sdb1。USB 驱动器和该驱动器上分区的设备文件的创建日期和时间应该正好是设备插入 USB 端口的时间，并且不同于其他设备上在引导时创建的时间戳。你看到的具体结果会和我的不一样。

作为系统管理员，我们不需要为要创建的设备文件做任何其他事情。Linux 内核负责一切。只有在创建了设备文件/dev/sdb1 之后，才能挂载分区以访问其内容。

udev 的创始人之一 Greg Kroah-Hartman 写了一篇论文 <sup>[2](#Fn2)</sup> ，提供了一些关于 udev 的细节以及它应该如何工作的见解。请注意，自从本文撰写以来，udev 已经变得更加成熟，一些东西也发生了变化，比如 udev 规则的位置和结构。无论如何，本文对 udev 和当前的设备命名策略提供了一些深刻而重要的见解。

### 命名规则

在 Fedora 和 CentOS 的现代版本中，udev 将其默认命名规则存储在/usr/lib/udev/rules.d 目录中的文件中，将其本地规则和配置文件存储在/etc/udev/rules.d 目录中。每个文件包含一组特定设备类型的规则。CentOS 6 和更早版本将全局规则存储在/lib/udev/rules.d/中。udev 规则文件的位置在您的发行版中可能会有所不同。

在 udev 的早期版本中，创建了许多本地规则集，包括一组网络接口卡(NIC)命名规则。由于每个网卡都是由内核发现并由 udev 第一次重命名的，因此在规则集中为网络设备类型添加了一条规则。最初这样做是为了在名称从“ethX”更改为更一致的名称之前确保一致性。

### 规则改变蓝调

使用 udev 进行持久即插即用命名的一个主要结果是，对于普通的非技术用户来说，事情变得容易多了。从长远来看，这是一件好事；然而，存在迁移问题，许多系统管理员过去和现在都不喜欢这些变化。

随着时间的推移，规则发生了变化，网络接口卡至少有三种明显不同的命名约定。这种命名上的差异造成了大量的混乱，在这些变化期间，许多配置文件和脚本不得不被多次重写。

例如，最初为 eth0 的 NIC 名称将从 eth 0 更改为 em1 或 p1p2，最后更改为 eno1。我在我的技术网站上写了一篇文章 <sup>[3](#Fn3)</sup> ，详细介绍了这些命名方案及其背后的原因。

现在 udev 有了多个一致的默认规则来确定设备名，尤其是对于 NIC，不再需要在本地配置文件中存储每个设备的特定规则来保持一致性。

## 设备数据流

让我们看一下典型命令的数据流，以直观地了解设备专用文件是如何工作的。图 [5-1](#Fig1) 显示了一个简单命令的简化数据流。从诸如 Konsole 或 xterm 之类的 GUI 终端仿真器发出`cat` `/etc` `/resolv.conf`命令会导致从磁盘读取 resolv.conf 文件，同时磁盘设备驱动程序处理设备特定的功能，例如在硬盘上定位文件并读取它。数据通过设备文件传递，然后从命令传递到伪终端 6 的设备文件和设备驱动程序，并在终端会话中显示。

![../images/462716_1_En_5_Chapter/462716_1_En_5_Fig1_HTML.jpg](../images/462716_1_En_5_Chapter/462716_1_En_5_Fig1_HTML.jpg)

图 5-1

使用设备专用文件简化数据流

当然，`cat`命令的输出可以通过下面的方式重定向到一个文件，`cat` `/etc` `/resolv.conf > /etc/resolv.bak`以创建该文件的备份。在这种情况下，图 [5-1](#Fig1) 左侧的数据流将保持不变，而右侧的数据流将通过/dev/sda2 设备文件、硬盘设备驱动程序，然后作为新文件 resolv.bak 返回到硬盘的/etc 目录中

这些设备专用文件使得使用标准流(STDIO)和重定向来访问 Linux 或 Unix 计算机上的任何设备变得非常容易。它们为每台设备提供一致且易于访问的界面。只需将数据流定向到设备文件，即可将数据发送到该设备。

关于这些设备专用文件，需要记住的最重要的一点是，它们不是设备驱动程序。它们被最准确地描述为设备驱动程序的入口或网关。数据从应用程序或操作系统传递到设备文件，然后设备文件将数据传递到设备驱动程序，设备驱动程序再将数据发送到物理设备。

通过使用这些独立于设备驱动程序的设备文件，用户和程序可以对主机上的每个设备拥有一致的接口。正如 Linus 所说，这就是如何使用通用工具对不同的事物进行操作。

设备驱动程序仍然负责处理每个物理设备的独特需求。然而，这超出了本书的范围。

## 设备文件分类

设备文件至少有两种分类方式。第一种也是最常用的分类是通常与设备相关的数据流类型。例如，tty 和串行设备被认为是基于字符的，因为数据流一次传输和处理一个字符或一个字节。硬盘等块类型设备以块为单位传输数据，通常是 256 字节的倍数。

让我们看看/dev/目录和其中的一些设备。

### 实验 5-2

这个实验应该以用户学生的身份进行。

打开一个终端会话，显示一长串/dev/目录。

```sh
[student@f26vm ~]$ ls -l /dev | less
<snip>
brw-rw----   1 root disk        8,   0 Nov  7 07:06 sda
brw-rw----   1 root disk        8,   1 Nov  7 07:06 sda1
brw-rw----   1 root disk        8,  16 Nov  7 07:06 sdb
brw-rw----   1 root disk        8,  17 Nov  7 07:06 sdb1
brw-rw----   1 root disk        8,  18 Nov  7 07:06 sdb2
<snip>
crw--w----   1 root tty         4,   0 Nov  7 07:06 tty0
crw--w----   1 root tty         4,   1 Nov  7 07:06 tty1
crw--w----   1 root tty         4,  10 Nov  7 07:06 tty10
crw--w----   1 root tty         4,  11 Nov  7 07:06 tty11
<snip>

```

此命令的结果太长，无法在此完整显示，但是您将看到一个设备文件列表，其中包含它们的文件权限以及它们的主要和次要标识号。

`ls` `-l`命令的大量输出通过`less` transformer 实用程序传输，让您可以翻阅结果；使用向上翻页、向下翻页和上下箭头键移动。键入 **q** 退出并退出`less`显示。

实验 5-1 中显示的设备文件的删减列表只是我的 Fedora 工作站上/dev/目录中的几个。它们代表磁盘和 tty 类型的设备。注意输出中每行最左边的字符。带有“b”的是块类型设备，以“c”开头的是字符设备。

识别设备文件的更详细、更明确的方法是使用设备主设备号和次设备号。磁盘设备的主编号为 8，表示它们是 SCSI 块设备。请注意，所有 PATA 和 SATA 硬盘都由 SCSI 子系统管理，因为旧的 ATA 子系统由于其代码质量差，多年前就被认为是不可维护的。因此，以前被指定为“hd[a-z]”的硬盘现在被称为“sd[a-z]”。

在上面显示的小样本中，您大概可以推断出磁盘驱动器次要编号的模式。次要编号 0、16、32 等等直到 240 都是完整的磁盘编号。因此，major/minor 8/16 表示整个磁盘/dev/sdb，8/17 是第一个分区/dev/sdb1 的设备文件。数字 8/34 应该是/dev/sdc2。

上面列表中的 tty 设备文件的编号从 tty0 到 tty63 稍微简单一些。我发现 tty 设备的数量有点不协调，因为新 udev 系统的要点是只为那些实际存在的设备创建设备文件；我不知道为什么要这样做。然而，您也可以从图 [5-2](#Fig2) 中的列表中看到，所有这些设备文件都是在 11 月 7 日 07:06 创建的，也就是主机启动的时间。主机上的设备文件也应该有一个与上次引导时间相同的时间戳。

位于 Kernel.org 的 Linux 分配设备 <sup>[4](#Fn4)</sup> 文件是设备类型和主要及次要编号分配的官方注册表。它可以帮助您了解所有当前定义的设备的主要/次要编号。

## 设备文件的乐趣

现在，让我们花几分钟时间来研究一下这些设备文件。我们将进行几个有趣的实验，展示 Linux 设备文件的强大功能和灵活性。

大多数 Linux 发行版都有多个虚拟控制台，从 1 到 7，可以用来通过 shell 界面登录到本地控制台会话。可以使用 Ctrl-Alt-F1 组合键访问控制台 1，Ctrl-Alt-F2 组合键访问控制台 2，依此类推。

### 实验 5-3

在这个实验中，我们将展示简单的命令可以用来在设备之间发送数据，在这个例子中，不同的控制台和终端设备。以学生用户的身份执行此实验。

按下 **Ctrl-Alt-F2** 切换到控制台 2。在某些发行版中，登录信息包括与此控制台相关的 tty (Teletype)设备，但许多发行版没有。应该是 tty2，因为你在控制台 2。如果使用虚拟机的本地实例，您可能需要使用不同的组合键。

以学生身份登录控制台 2。然后使用`who am i`命令——是的，就像这样，用空格——来确定哪个 tty 设备连接到这个控制台。

```sh
[student@f26vm ~]$ who am i
student  tty2        2017-10-05 13:12

```

此命令还显示控制台上的用户登录的日期和时间。

在我们进一步进行这个实验之前，让我们看看/dev 中的 tty2 和 tty3 设备列表。我们通过使用一个集合[23]来做到这一点，以便只列出这两个设备。

```sh
[student@f26vm ~]$ ls -l /dev/tty[23]
crw--w---- 1 root tty 4, 2 Oct  5 08:50 /dev/tty2
crw--w---- 1 root tty 4, 3 Oct  5 08:50 /dev/tty3

```

在引导时定义了大量的 tty 设备，但是在这个实验中我们并不关心它们中的大多数，只关心 tty2 和 tty3 设备。作为设备文件，它们没有什么特别的，它们只是简单的字符型设备；请注意结果第一列中的“c”。我们将在这个实验中使用这两台 TTY 设备。tty2 设备连接到虚拟控制台 2，tty3 设备连接到虚拟控制台 3。

按下 **Ctrl-Alt-F3** 切换到控制台 3，再次以学生用户身份登录。再次使用`who am i`命令验证您确实在控制台 3 上，然后输入 echo 命令。

```sh
[student@f26vm ~]$ who am i
student  tty3        2017-10-05 13:18
[student@f26vm ~]$ echo "Hello world" > 
/dev

/tty2

```

按下 **Ctrl-Alt-F2** 返回控制台 2。控制台 2 上应该显示字符串“Hello world”(不带引号)。

这个实验也可以用 GUI 桌面上的终端模拟器来执行。桌面上的终端会话使用/dev 树中的伪终端设备，例如/dev/pts/1，其中 pts 代表“伪终端会话”。

使用 Konsole、Tilix、Xterm 或您喜欢的其他图形终端模拟器，在 GUI 桌面上打开至少两个终端会话。如果你愿意，你可以打开几个。使用**我是谁**命令确定它们连接到哪个伪终端设备文件，然后选择一对终端仿真器用于本实验。使用 echo 命令将消息发送给另一个。

```sh
[student@f26vm ~]$ who am i
student  pts/9        2017-10-19 13:21 (192.168.0.1)
[student@f26vm ~]$ w
13:23:06 up 14 days,  4:32,  9 users,  load average: 0.03, 0.08, 0.09
USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT
student  pts/1     05Oct17  4:48m  0.04s  0.04s -bash
student  pts/2     06Oct17  2:16   2.08s  2.01s screen
student  pts/3     07Oct17 12days  0.04s  0.00s less
student  pts/4     07Oct17  2:16   0.10s  0.10s /bin/bash
root     pts/5     08:35    4:08m  0.05s  0.05s /bin/bash
root     pts/6     08:35    4:47m  1:19   1:19  htop
root     pts/7     08:35    4:40m  0.05s  0.05s /bin/bash
root     pts/8     08:50    4:32m  0.03s  0.03s /bin/bash
student  pts/9     13:21    0.00s  0.04s  0.00s w
[student@f26vm ~]$ echo "Hello world" > 
/dev

/pts/4

```

在我的测试主机上，我将文本“Hello world”从/dev/pts/9 发送到/dev/pts/4。您的终端设备将与我在测试虚拟机上使用的不同。请确保在您的环境中使用正确的设备进行本实验。

另一个有趣的实验是使用 cat 命令将文件直接打印到打印机上。

### 实验 5-4

这个实验应该以学生用户的身份进行。

您可能需要确定哪个设备是您的打印机。如果你的打印机是 USB 打印机，现在几乎都是，在/dev/usb 目录中查找 lp0，它通常是默认的打印机。您也可以在该目录中找到其他打印机设备文件。

我用 LibreOffice Writer 创建了一个简短的文档，然后导出为 PDF 文件，test.pdf。任何 Linux 文字处理器都可以，只要它能导出到 PDF 格式。

我们将假设您的打印机设备是/dev/usb/lp0，并且您的打印机可以直接打印 PDF 文件，大多数打印机都可以。请务必使用 PDF 文件，并将命令中的名称 test.pdf 改为您自己的文件名。

```sh
[student@f26vm ~]$ cat test.pdf > 
/dev

/usb/lp0

```

此命令应该在您的打印机上打印 PDF 文件 test.pdf。

/dev 目录包含一些非常有趣的设备文件，这些文件是硬件的入口，人们通常不认为这些硬件是硬盘或显示器之类的设备。例如，系统内存——RAM——通常不被认为是“设备”,但是/dev/mem 是设备专用文件，通过它可以实现对内存的直接访问。

### 实验 5-5

这个实验必须以 root 用户的身份运行。因为你只是在读取内存的内容，所以这个实验没有什么危险。

注意一些测试人员报告说这个实验对他们不起作用。我没有在几个物理和虚拟主机上发现任何问题。请注意，这个实验可能会产生一个权限错误，而不是期望的输出。

如果根终端会话尚不可用，请打开终端模拟器会话，并以 root 用户身份登录。下一个命令将把第一个 200K 的 RAM 转储到 STDOUT。

```sh
[root@f26vm ~]# dd if=/dev/mem bs=2048 count=100

```

它可能看起来不像那么多，你所看到的将是难以理解的。为了使它更容易理解——至少以专家可以理解的适当格式显示数据——通过 **od** 实用程序传输前面命令的输出。

```sh
[root@f26vm ~]# dd if=/dev/mem bs=2048 count=100 | od -c

```

Root 用户比非 root 用户有更多的读取内存的权限，但是大多数内存是受保护的，不会被任何用户写入，包括 root 用户。

与简单地使用`cat`命令转储所有内存相比,`dd`命令提供了更多的控制，我也尝试过这样做。`dd`命令提供了指定从/dev/mem 中读取多少数据的能力，也允许我指定从内存中读取数据的起始点。尽管使用`cat`命令读取了一些内存，但内核最终还是响应了图 [5-2](#Fig2) 中的错误。

您也可以以非 root 用户学生的身份登录，并尝试此命令。您将得到一条错误消息，因为您试图访问的内存不属于您的用户。这是 Linux 的一个内存保护特性，可以防止其他用户读取或写入不属于他们的内存。

![../images/462716_1_En_5_Chapter/462716_1_En_5_Fig2_HTML.jpg](../images/462716_1_En_5_Chapter/462716_1_En_5_Fig2_HTML.jpg)

图 5-2

当 **cat** 命令试图将受保护的内存转储到 STDOUT 时，最后一行显示错误

这些内存错误意味着内核正在通过保护属于其他进程的内存来完成它的工作，这正是它应该如何工作。因此，尽管您可以使用/dev/mem 来显示存储在 RAM 内存中的数据，但是对大多数内存空间的访问是受保护的，并且会导致错误。只有内核内存管理器分配给运行`dd`命令的 bash shell 的虚拟内存应该是可访问的，而不会导致错误。抱歉，你不能窥探不属于你的内存，除非你发现一个漏洞利用。

许多类型的恶意软件依靠特权提升来允许它们读取它们通常无法访问的内存内容。这使得恶意软件能够找到并窃取个人数据，如账号、用户 ID 和存储的密码。幸运的是，Linux 可以防止非根用户访问内存。它还可以防止特权升级。

但是即使是 Linux 安全也不是完美的。安装安全补丁来防止允许权限提升的漏洞是很重要的。你还应该意识到人为因素，比如人们写下密码的倾向，但那都是另一回事了。 <sup>[5](#Fn5)</sup>

现在，您可以看到内存也被视为一个文件，并且可以使用内存设备文件来处理它。

## 随机性、零等等

/dev 中还有一些其他非常有趣的设备文件。设备专用文件 null、zero、random 和 urandom 不与任何物理设备相关联。这些设备文件提供了零、空值和随机数的来源。

空设备/dev/null 可以用作重定向 shell 命令或程序输出的目标，这样它们就不会显示在终端上。

### 实验 5-6

我经常在我的 bash 脚本中使用/dev/null 来防止用户看到可能让他们感到困惑的输出。输入以下命令，将输出重定向到空设备。终端上不会显示任何内容。数据只是被转储到天空中的大比特桶中。

```sh
[student@f26vm ~]$ echo "Hello world" > /dev/null

```

将/dev/null 作为“空”字符的来源。

```sh
[student@testvm1 ~]$ cat /dev/null
[student@testvm1 ~]$ dd if=/dev/null
0+0 records in
0+0 records out
0 bytes copied, 5.2305e-05 s, 0.0 kB/s

```

/dev/null 实际上没有可见的输出，因为 null 设备只是返回一个文件结束(EOF)字符。请注意，字节计数为零。空设备作为一个重定向不需要的输出以便将其从数据流中删除的地方要有用得多。

/dev/random 和/dev/urandom 设备都是有用的数据流源。顾名思义，它们都产生随机输出——不仅仅是数字，而是任何和所有的字节组合。/dev/urandom 设备产生确定性的 <sup>[6](#Fn6)</sup> 随机输出，速度非常快。

### 实验 5-7

使用此命令查看/dev/urandom 的典型输出。可以用 Ctrl-c 突围。

```sh
[student@f26vm ~]$ cat /dev/urandom
,3••VwM
N•g•/•l•ۑ•!••'۩'•:••|R••[•t••Z••F.:H•7•,••
••z/••|•7q•Sp•"•(l_c••π••-•••••••ś•Y•••D^5•i8••"%•••&ŋ|C9!y•••f•5bPp;••C
••x••1•••U••3~•••
<snip>

```

我只展示了该命令的一部分数据流，但是它应该会让您对您的系统有所了解。

您还可以通过`od`命令来传输实验 5-6 的输出，使其更易于阅读。这对大多数现实世界的应用程序来说没有什么意义，因为它毕竟是随机数据。

`od`的手册页显示，它可以用来直接从文件中获取数据，以及指定要读取的数据量。

### 实验 5-8

在这种情况下，我使用-N 128 将输出限制为 128 字节。

```sh
[student@f26vm ~]$ od /dev/urandom -N 128
0000000 043514 022412 112660 052071 161447 057027 114243 061412
0000020 154627 105675 154470 110352 135013 127206 103057 136555
0000040 033417 011054 014334 040457 157056 165542 027255 121710
0000060 125334 065600 165447 165245 020756 101514 042377 132156
0000100 116024 027770 000537 014743 170561 011122 173454 102163
0000120 074301 104771 123476 054643 105211 151753 166617 154313
0000140 103720 147660 012644 037363 077661 076453 104161 033220
0000160 056501 001771 113557 075046 102700 043405 132046 045263
0000200

```

`dd`命令也可用于指定从[u]个随机设备获取的数据量的限制，但它不能直接格式化数据。

/dev/random 设备文件产生不确定的 <sup>[7](#Fn7)</sup> 随机输出，但它产生输出的速度较慢。该输出不是由仅依赖于先前生成的数字的算法确定的，而是响应于击键和鼠标移动而生成的。这种方法使得复制一系列特定的随机数更加困难。使用 cat 命令查看/dev/random 设备文件的一些输出。尝试移动鼠标，看看它如何影响输出。

从/dev/random 和/dev/urandom 生成的随机数据，不管是如何从这些设备中读取的，通常都被重定向到某个存储介质上的文件或另一个程序的 STDIN。系统管理员、开发人员或最终用户很少需要查看随机数据。但它确实为这个实验做了一个很好的示范。

顾名思义,/dev/zero 设备文件产生一个无休止的零字符串作为输出。请注意，这些是八进制零，而不是 ASCII 字符零(0)。

### 实验 5-9

使用`dd`命令查看/dev/zero 设备文件的一些输出。请注意，该命令的字节数不为零。

```sh
[student@f26vm ~]$ dd if=/dev/zero  bs=512 count=500 | od -c
0000000  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
*
500+0 records in
500+0 records out
256000 bytes (256 kB, 250 KiB) copied, 0.00126996 s, 202 MB/s
0764000

```

## 备份主引导记录

例如，考虑对硬盘驱动器的主引导记录(MBR)进行备份的简单任务。有时，我需要恢复或重新创建我的 MBR，尤其是分区表。从头开始重新创建它是非常困难的。从保存的文件中恢复它很容易。所以我们备份一下硬盘的开机记录。

请注意，本节中的所有实验都必须以 root 用户身份执行。

### 实验 5-10

我们将为您的主引导记录(MBR)创建一个备份，但不会尝试恢复它。

`dd`命令必须以 root 身份运行，因为出于安全原因，非 root 用户不能访问/dev 目录中的硬盘设备文件。bs 值不是你可能想的那样；它代表块大小。Count 是从源文件中读取的块数。

```sh
[root@f26vm ~]# dd if=/dev/sda of=/tmp/myMBR.bak bs=512 count=1

```

这个命令在/tmp 目录中创建一个文件 myMBR.bak。该文件大小为 512 字节，包含 MBR 的内容，包括引导代码和分区表。

现在看看您刚刚创建的文件的内容。

```sh
[root@testvm1 ~]# cat /tmp/myMBR.bak
•c•••••••••|••••!••8u
Z••••••}•f••d•@f•D•••••••@•••••f•f•`|fL••uNf•\|f1•f•4••1•f•t;}7•••0••••Z••p••1••r••`•••1••••••a•&Z|••}•••}•4••}•.•••GRUB GeomHard DiskRead Error
••••<u••}•••• !••( •)•••• ••U•[root@testvm1 ~]#

```

因为在引导扇区的结尾没有行尾字符，所以命令提示符与引导记录的结尾在同一行。

如果 MBR 损坏了，就需要启动到一个救援盘，并使用代码示例 5-1 中的命令来执行与上面的命令相反的操作。请注意，不需要像第一个命令那样指定块大小和块数，因为 dd 命令只是将备份文件复制到硬盘驱动器的第一个扇区，并在到达源文件末尾时停止。

### 代码示例 5-1

以下代码将备份主引导记录还原到硬盘上的第一个扇区。

```sh
[root@testvm1 ~]#  dd if=/tmp/myMBR.bak of=/dev/sda

```

不要运行此代码，因为如果输入不正确，它可能会损坏您的系统。

现在，您已经备份了硬盘的引导记录并验证了该备份的内容，让我们转移到一个更安全的环境，销毁引导记录，然后恢复它。

### 实验 5-11

这是一个相当长的实验，必须以 root 用户身份执行。您将为 USB 设备备份 MBR，损坏设备上的 MBR，尝试读取设备，然后恢复 MBR。不要安装 USB 驱动器。

确保 USB 驱动器已插入您的计算机，并验证设备文件名。在我的例子中，它仍然是/dev/sdb。

首先我们用`fdisk`看分区表，为后面的对比提供依据，然后我们备份 USB 设备的 MBR，验证备份文件的内容。与之前的类似实验一样，警告消息是 MBR 内容的一部分。

```sh
[root@testvm1 ~]# fdisk -l /dev/sdb
Disk /dev/sdb: 62.5 MiB, 65536000 bytes, 128000 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x73696420

Device     Boot Start    End Sectors  Size Id Type
/dev/sdb1        2048 127999  125952 61.5M  c W95 FAT32 (LBA)

[root@f26vm ~]# dd if=/dev/sdb of=/tmp/myMBR.bak bs=512 count=1
1+0 records in
1+0 records out
512 bytes copied, 0.012374 s, 41.4 kB/s
[root@f26vm ~]# cat /tmp/myMBR.bak
•>•MSWIN4.1P•} •••)L•0NO NAME    FAT16   •}•3•••{•x•vVU•"•~•N•
•••|•E••F•E••8f$|•r<•F••fFVF•PR•F•V•• •v••^
•H••F•N•ZX••••rG8-t• V•v>•^tJNt
••F•V••S••[r•?MZu•••BJu••pPRQ••3••v••vB•••v••V$•••••••t<•t    •••••}••}••3••^••D•••}•}••r••HH•N ••YZXr   @uB^
            •••'
Invalid system disk•
Disk I/O error•
Replace the disk,!••U•

```

现在有趣的部分来了，我们用一个 512 字节的随机数据块覆盖 USB 设备的 MBR，然后查看 MBR 的新内容以验证更改。请注意，警告消息不再存在，因为它们已被覆盖。

```sh
[root@f26vm ~]# dd if=/dev/urandom of=/dev/sdb bs=512 count=1
1+0 records in
1+0 records out
512 bytes copied, 0.0195473 s, 26.2 kB/s
[root@f26vm ~]# dd if=/dev/sdb bs=512 count=1
6••••%•w••pI!8k•••••$••Q••¯••••gO••\••AT••KQ••••• ••"5•oW-•••;•••••ٹr3••oiP•d•q••••a••%••••N••#••&F•_•••y••?•\•••)••K••?•fa••+.••••F•'F••~•H•••XbS•••BA•V•^••z[S•jy••••••=aPs:••N_[ڶ••••b••#%•;/•••,4•}9
0••7•••ٯF85••L•g••\•R4••••q••Kn|M••cy••ʗ••m•\••••yi{_o^•i•j K•nry2MMSeA•••p•^E•n•v•u2•/•A•Zb•••1••Ì•K5•3•x•K•ia•K?•Iw••••^•1f•••{3•p&E•••M••rbɠ••••••••• p••K•1+0 records in
1+0 records out
512 bytes copied, 0.0137811 s, 37.2 kB/s

```

在我们继续恢复这个 MBR 之前，让我们再做一些事情来测试这种状态。首先，我们使用`fdisk`来验证 USB 驱动器不再有分区表，这意味着 MBR 已经被覆盖。

```sh
[root@f26vm ~]# fdisk -l /dev/sdb
Disk /dev/sdb: 62.5 MiB, 65536000 bytes, 128000 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

```

尝试挂载原始分区将会失败。错误消息表明特殊设备不存在。这表明大多数特殊设备文件都是根据需要按需创建和删除的。

```sh
[root@f26vm ~]# mount /dev/sdb1 /mnt
mount: /mnt: special device /dev/sdb1 does not exist.

```

是时候恢复您之前备份的启动记录了。因为您使用 dd 命令小心地用随机数据只覆盖了包含驱动器分区表的 MBR，所以所有其他数据都保持不变。恢复 MBR 将使其再次可用。恢复 MBR，在设备上查看 MBR，然后挂载分区并列出内容。

```sh
[root@f26vm ~]# dd if=/tmp/myMBR.bak of=/dev/sdb
1+0 records in
1+0 records out
512 bytes copied, 0.0738375 s, 6.9 kB/s

[root@testvm1 ~]# fdisk -l /dev/sdb
Disk /dev/sdb: 62.5 MiB, 65536000 bytes, 128000 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x73696420

Device     Boot Start    End Sectors  Size Id Type
/dev/sdb1        2048 127999  125952 61.5M  c W95 FAT32 (LBA)

[root@f26vm ~]# mount /dev/sdb1 /mnt
[root@f26vm ~]# ls -l /mnt
total 380
-rwxr-xr-x 1 root root 37001 Nov  7 08:23 file0.txt
-rwxr-xr-x 1 root root 37001 Nov  7 08:23 file1.txt
-rwxr-xr-x 1 root root 37001 Nov  7 08:23 file2.txt
-rwxr-xr-x 1 root root 37001 Nov  7 08:23 file3.txt
-rwxr-xr-x 1 root root 37001 Nov  7 08:23 file4.txt
-rwxr-xr-x 1 root root 37001 Nov  7 08:23 file5.txt
-rwxr-xr-x 1 root root 37001 Nov  7 08:23 file6.txt
-rwxr-xr-x 1 root root 37001 Nov  7 08:23 file7.txt
-rwxr-xr-x 1 root root 37001 Nov  7 08:23 file8.txt
-rwxr-xr-x 1 root root 37001 Nov  7 08:23 file9.txt

```

哇——太酷了！这一系列实验旨在说明，您可以利用所有设备都可以被视为文件这一事实，从而以一些非常有趣的方式使用一些非常常见但功能强大的 CLI 工具。

没有必要用 sb=和 count=参数指定要复制的数据量，因为 dd 命令只复制可用的数据量，在本例中是一个 512 字节的扇区。

卸载 USB 设备，因为我们现在已经完成了。

## 一切都是一个文件的含义

“一切都是一个文件”的含义是深远的，比这里所能列出的要大得多。在前面的实验中，您已经看到了一些例子。但是这里有一个简短的列表，包含了这些以及更多。

*   克隆硬盘。

*   备份分区。

*   备份主引导记录(MBR)。

*   将 ISO 映像安装到 USB 拇指驱动器上。

*   与其他终端上的用户进行交流。

*   将文件打印到打印机。

*   更改/proc 伪文件系统中某些文件的内容，以修改正在运行的内核的配置参数。

*   用随机数据或零覆盖文件、分区或整个硬盘。

*   将不需要的命令输出重定向到一个空设备，在那里它将永远消失。

*   等等。等。等。

这里有太多的可能性，任何列表都只能触及表面。我确信你已经——或者将要——想出许多方法来更有创造性地运用这一哲学原则，远比我在这里讨论的要多得多。

## 摘要

它是文件系统的一部分。Linux 计算机上的一切都可以作为文件系统空间中的一个文件来访问。这样做的全部目的是能够使用通用工具来操作不同的东西——通用工具，如标准的 GNU/Linux 实用程序和对文件起作用的命令也将在设备上起作用——因为在 Linux 中，它们是文件。

<aside class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

维基百科，设备文件， [`https://en.wikipedia.org/wiki/Device_file`](https://en.wikipedia.org/wiki/Device_file)

  [2](#Fn2_source)

Greg Kroah-Hartman，Linux Journal，内核科尔纳–udev–用户空间中的持久命名， [`http://www.linuxjournal.com/article/7316`](http://www.linuxjournal.com/article/7316)

  [3](#Fn3_source)

大卫既，网卡名称赋值， [`http://www.linux-databook.info/?page_id=4243`](http://www.linux-databook.info/?page_id=4243)

  [4](#Fn4_source)

[T2`https://www.kernel.org/doc/html/v4.11/admin-guide/devices.html`](https://www.kernel.org/doc/html/v4.11/admin-guide/devices.html)

  [5](#Fn5_source)

Apress 在 [`https://www.apress.com/us/security`](https://www.apress.com/us/security) 有很多关于安全的好书

  [6](#Fn6_source)

确定性意味着输出由已知算法确定，并使用种子字符串作为起点。每个输出单元都依赖于前一个输出和算法，因此如果您知道种子和算法，就可以复制整个数据流。因此，如果原始种子是已知的，黑客就有可能(尽管很难)复制输出。

  [7](#Fn7_source)

非确定性结果不依赖于随机数据流中的先前数据。因此，它们比确定性的更具有真正的随机性。

 </aside>