# 9.自动化一切

我的问题是，“计算机的功能是什么？”正确的答案是，“将日常任务自动化，以便让我们人类能够专注于计算机还不能完成的任务。”对于系统管理员，也就是我们这些最密切地运行和管理计算机的人来说，我们可以直接使用工具来帮助我们更有效地工作。我们应该最大限度地利用这些工具。

在这一章中，我们将探索如何使用自动化来使我们作为系统管理员的生活变得更加轻松。

## 我为什么使用脚本

在第 8 章“做一个懒惰的系统管理员”中，我说，“一个系统管理员在思考的时候最有效率——思考如何解决现有的问题和如何避免未来的问题；思考如何监控 Linux 计算机，以便找到预测和预示未来问题的线索；思考如何让她的工作更有效率；思考如何自动化所有需要每天或每年执行一次的任务。”

当创建外壳程序时，系统管理员是下一个最有效率的，这些外壳程序将他们设想的解决方案自动化，而看起来却没有效率。我们的自动化程度越高，我们就有越多的时间来解决出现的实际问题，并考虑如何实现比我们现有的自动化程度更高的自动化。

我认识到，至少对我来说，编写 shell 程序——也称为脚本——提供了利用我的时间的最佳策略。一旦编写了一个 shell 程序，就可以根据需要多次重新运行。

我可以根据需要更新我的 shell 脚本，以补偿从一个 Linux 版本到下一个版本的变化。可能需要进行这些更改的其他因素包括安装新的硬件和软件、更改我希望或需要用脚本完成的内容、添加新功能、删除不再需要的功能，以及修复脚本中不常见的错误。对于任何类型的代码来说，这些变化只是维护周期的一部分。

在终端会话中，通过键盘输入和执行 shell 命令来执行的每项任务都可以而且应该是自动化的。系统管理员应该自动化我们被要求做的或者我们自己决定需要做的所有事情。很多时候，我发现预先做好自动化工作可以节省时间。

一个 bash 脚本可以包含几个到几千个命令。事实上，我编写的 bash 脚本中只有一两个命令。我写的另一个脚本包含 2700 多行，其中一半以上是注释。

## 我是如何来到这里的

我是如何走到“自动化一切”这一步的？

您是否曾经在命令行执行一个漫长而复杂的任务时想，“很高兴完成了——我再也不用担心它了。”？我有——非常频繁。我最终发现，几乎所有我需要在电脑上做的事情，无论是我的，还是属于我的雇主或我的一个咨询客户的，都需要在未来的某个时候再做一次。

当然，我总是认为我会记得我是如何完成这个任务的。但是下一次我需要去做的时候已经很遥远了，以至于我有时甚至忘记了我曾经做过这件事，更不用说如何去做了。对于我以前做的一些任务，我开始在一张纸上写下需要的步骤。我想，“我真笨！”于是我把这些涂鸦转移到我电脑上的一个简单的记事本类型的应用程序中。突然有一天我又想:“我真笨！”如果我要将这些数据存储在我的计算机上，我不妨创建一个 shell 脚本并将其存储在一个标准位置，这样我只需键入 shell 程序的名称，它就可以完成我以前手动完成的所有任务。

我个人认为一切自动化的主要原因是，任何必须执行一次的任务肯定需要重新执行。通过将执行任务所需的命令收集到一个文件中用作 shell 程序，以后运行完全相同的命令集就变得容易了。

对我来说，自动化还意味着我不必为了再次做这件事而去记忆或重新创建我是如何完成这项任务的细节。记住如何做事情需要时间，输入所有命令也需要时间。对于需要键入大量长命令的任务来说，这可能会成为一个很大的时间陷阱。通过创建 shell 脚本来实现任务自动化减少了执行日常任务所需的输入。

Shell 程序对于新的系统管理员来说也是一个重要的帮助，使他们能够在高级系统管理员外出度假或生病时保持工作。因为 shell 程序天生就对查看和更改开放，所以对于经验较少的系统管理员来说，当他们需要负责这些任务时，它们可以成为学习如何执行这些任务的细节的重要工具。

## 编写重复性任务的脚本

我总是同时拥有几台计算机，有时多达 14 或 15 台，尽管我目前只剩下 8 或 9 台，以及类似数量的虚拟机用于测试。我也在客户系统上安装 Linux。因此，我经常安装 Linux。有时一天好几个。这导致需要进行快速、可重复的安装。

例如，我有一组最喜欢的配置，比如 Midnight Commander (mc)，一个具有文本模式用户界面的强大文件管理器，以及其他可配置工具。我也有一些我喜欢安装的字体，它们不是大多数默认安装的一部分。我可以用 DNF 手动安装每种字体，每次安装的时候我可以手动修改 Midnight Commander 的配置，但是这要花很多时间，而且非常乏味和无聊。

当我手动做这些事情的时候，我会忘记一些事情，所以我开始记录要做的事情，但是这仍然非常耗时。所以这些年来，我开发了一个过程，确保安装快速可靠地完成，并且我不会忘记安装或配置任何东西。

我以前的流程是先做一个非常基本的安装。我会按照自己的方式配置磁盘分区和逻辑卷。我没有浏览可用软件包或组的完整列表，并试图记住我想要安装的软件包或组，以便在我的计算机上获得我想要的工具。浏览安装程序提供的选项并选择我想要的选项非常麻烦，而且花费了很多时间。

### 让它变得更容易

我开发了一个非常简单的 bash 脚本，运行它来配置和安装我想要的其他 RPM 包。在执行了基本安装之后，我将以 root 用户身份登录到终端会话并运行我的脚本。

随着时间的推移，这个简单的脚本演变为包括命令行选项，允许我根据不同的需求(无论是台式机、服务器、客户系统还是教室系统)来定制标准安装。当我了解到我发现有用的工具时，我将它们添加到要安装的软件包列表中。

我创建了需要安装的各种配置文件，并确定最好的方法是创建一个包含这些文件的 RPM 包。其中一些文件是我多年来创建的用于执行各种其他重复性任务的更多脚本，以及我的安装后脚本。

RPM 包本身就是一种自动化的形式，因为它让我不再需要记住要安装哪些文件以及要安装在哪里。RPM 包现在安装了大约十几个我自己创建的文件，并确保从各种 Fedora 和 CentOS 存储库中安装了某些必备的 RPM 包。大约 10 年来，我一直在改进安装后脚本，它有超过 1500 行代码，超过 1100 行注释，总共超过 2600 行。

即使使用 RPM 和安装后脚本，仍然需要一个多小时才能完成所有的工作，才能让我安装的每一台计算机都符合我的标准。我当然不会怀念手动输入所有这些指令，等待每一个指令完成后再输入下一个指令的日子。我现在需要做的就是安装 RPM，然后键入一个命令来安装所有其他的包并对它们进行配置。

### 从理想到必然

一切都进行得很顺利，虽然我可以手动完成所有这些工作，但使用自动化要容易得多。当 Fedora 21 出现在舞台上时，我多年来创造的自动化成了一种必需品。

对于那些不熟悉 Fedora 21 的人来说，该版本的安装程序发生了巨大的变化。不是单一的 ISO 映像，而是三个独立的安装 ISO 映像:桌面、服务器和云。

我使用过台式机和服务器 ISOs 进行安装，我非常不喜欢它们。我认为新的安装对于大多数 Fedora 用户来说是非常有限的。没有简单的安装映像。桌面 ISO 是一个实时映像。在安装过程中，除了实时映像 ISO 中的软件包之外，没有安装任何软件包的选项。没有。如果我想安装 KDE——或任何其他——桌面，而不是 GNOME(我这样做了),我必须在初始安装后下载 KDE 旋转或安装 KDE。我无法从主安装介质(实时映像)中完成此操作。

我甚至不能选择安装 LibreOffice。在安装过程中没有办法做到这一点。在初始安装之后，我必须安装那个和许多其他的东西。在我看来，这对许多潜在的 Linux 用户来说是一个巨大的绊脚石，尤其是 noobs。当然，我总是在执行新的 Fedora 安装后立即安装更新，因为总是有更新。

幸运的是，我的后安装 RPM 和后安装脚本允许我毫不费力地完成所有这些事情。是的，我不得不对我的脚本做一些调整——正如我对每个新版本所做的那样——以适应不同版本之间的一些变化。

我对遵循系统管理员的 Linux 理念的嗜好给我带来了非常好的回报。因为我花时间“自动化一切”，我个人很少经历由于 Fedora Linux 处理安装方式的重大改变而造成的中断。

这就是我通过自动化安装所获得的收获。

*   节省每次安装的时间。

*   安装是一致的。

*   始终安装更新。

*   对配电装置进行重大变更时，中断最小或没有中断。

*   易于创建相同的安装。

还有其他方法可以实现 Linux 安装和配置的自动化，并且有许多工具可以应用于这项任务，比如 Kickstart、Puppet、Satellite Server 等等。我广泛使用了 Kickstart。参见我和一位同事为 Linux 杂志写的文章“完整的 Kickstart”——我在自己的网站上保留了一份。 <sup>[1](#Fn1)</sup>

我的脚本在我当前的环境下非常适合我，并且满足了我的需求——这就是 Linux 游戏的名字。

## 更新

我经常做的另一项任务是在我所有的计算机上安装更新。事实上，今天早上我一直在更新。这是一个只需要做几个决定的任务，并且很容易自动化。"但是这么简单，为什么要自动化一个只需要一两个命令的任务呢？"原来更新不是这么简单的。让我们思考一下这个问题。

首先，我必须确定是否有可用的更新。然后我需要确定需要重启的包是否正在更新，比如内核或 glibc。此时，我可以安装更新。在重新启动之前，假设需要重新启动，我运行`mandb`实用程序来更新手册页；如果不这样做，新的和替换的手册页将无法访问，被删除的旧手册页将会出现在那里，尽管它们并不存在。图 [9-1](#Fig1) 显示了今天早上更新完 man 数据库后的部分结果。然后，如果内核已经更新，我需要重新构建 grub 引导加载程序配置文件，以便它包含每个已安装内核的恢复选项。最后，如果需要重启，我会这样做。

![../images/462716_1_En_9_Chapter/462716_1_En_9_Fig1_HTML.png](../images/462716_1_En_9_Chapter/462716_1_En_9_Fig1_HTML.png)

图 9-1

执行升级后运行 mandb 的部分结果

这是一组需要一些决策的非平凡的单个任务和命令。手动执行这些任务需要注意力和干预，以便在前一个命令完成时输入新的命令。因为需要在等待输入下一个命令的时候照看孩子，这将花费我大量的时间来监控每台计算机，因为它经历了这些过程。当我在主机上输入错误的命令时，偶尔会有人提醒我，这是有出错的空间的。

![../images/462716_1_En_9_Chapter/462716_1_En_9_Figa_HTML.png](../images/462716_1_En_9_Chapter/462716_1_En_9_Figa_HTML.png)

使用我在上面创建的需求陈述，因为这就是那个段落的真实内容，很容易自动消除所有这些问题。我写了一个叫做 doUpdates 的小脚本。它的长度超过 400 行，提供了帮助、详细模式、打印当前版本号等选项，以及只有在内核或 glibc 更新后才重新启动的选项。

这个程序中超过一半的行都是注释，所以下次我需要修改它或者增加一些功能的时候，我可以记得这个程序是如何工作的。大部分基本功能都是从一个模板文件中复制的，该模板文件维护了我在编写的每个脚本中使用的所有标准组件。因为新脚本的框架总是在那里，所以很容易开始新的脚本。

图 9-2 是 doUpdates bash 脚本的列表。为了防止大部分较长的行换行，我将字体大小设置得比平时小一点。然而，一些很长的行被包装。如果太小，读起来不舒服，我道歉。我还删除了一些空白行和空的注释行，以尽可能缩短列表，但它仍然有大约 8 页长。

![../images/462716_1_En_9_Chapter/462716_1_En_9_Fig2a_HTML.png](../images/462716_1_En_9_Chapter/462716_1_En_9_Fig2a_HTML.png)![../images/462716_1_En_9_Chapter/462716_1_En_9_Fig2b_HTML.png](../images/462716_1_En_9_Chapter/462716_1_En_9_Fig2b_HTML.png)![../images/462716_1_En_9_Chapter/462716_1_En_9_Fig2c_HTML.png](../images/462716_1_En_9_Chapter/462716_1_En_9_Fig2c_HTML.png)![../images/462716_1_En_9_Chapter/462716_1_En_9_Fig2d_HTML.png](../images/462716_1_En_9_Chapter/462716_1_En_9_Fig2d_HTML.png)![../images/462716_1_En_9_Chapter/462716_1_En_9_Fig2e_HTML.png](../images/462716_1_En_9_Chapter/462716_1_En_9_Fig2e_HTML.png)![../images/462716_1_En_9_Chapter/462716_1_En_9_Fig2f_HTML.png](../images/462716_1_En_9_Chapter/462716_1_En_9_Fig2f_HTML.png)![../images/462716_1_En_9_Chapter/462716_1_En_9_Fig2g_HTML.png](../images/462716_1_En_9_Chapter/462716_1_En_9_Fig2g_HTML.png)![../images/462716_1_En_9_Chapter/462716_1_En_9_Fig2h_HTML.png](../images/462716_1_En_9_Chapter/462716_1_En_9_Fig2h_HTML.png)![../images/462716_1_En_9_Chapter/462716_1_En_9_Fig2i_HTML.png](../images/462716_1_En_9_Chapter/462716_1_En_9_Fig2i_HTML.png)

图 9-2

doUpdates 脚本的列表

根据 Linux FHS，doUpdates 脚本应该位于/usr/local/bin 中。它可以使用命令`doUpdates -r`运行，该命令将导致它仅在满足其中一个或两个条件时重新启动主机。

我不会为你解构整个 doUpdates 程序，但有些事情我想引起你的注意。先注意评论数量；这些帮助我记住每个部分应该做什么。she-bang(！/bin/bash)包含程序的名称、其功能的简短描述以及维护或更改历史。第一部分基于我在 IBM 工作时学到并遵循的一些实践。其他意见描述了各种程序和主要部分，并提供了每个简短的描述。最后，嵌入在代码中的较短注释描述了较短代码的功能或目标，如流控制结构。

我在脚本的开头有大量的程序。这是他们狂欢的地方。这些过程来自我的模板脚本，我尽可能在新脚本中使用它们，以节省重写它们的工作量。

过程名和变量名是有意义的，有些用大写字母表示一两个字符。这使得阅读更容易，并帮助程序员(我)和任何未来的维护者(也包括我)理解过程和变量的功能。是的，这似乎与哲学的另一个原则相违背，但是从长远来看，使代码更具可读性可以节省更多的时间。我从自己和他人的代码中了解到这一点。

我为一个组织做了一些咨询工作，这个组织让我开始修复一些脚本中的错误。我看了一眼脚本，知道要修复实际的错误需要做很多工作，因为我首先要修复脚本的可读性。我从给脚本添加注释开始，因为没有注释。然后，我开始重命名变量和过程，以便更容易理解这些变量的用途和它们所保存的数据的性质。只有在做出这些改变之后，我才能开始理解他们所经历的问题的本质。

我们将在第 18 章中看到更多关于这个组织的内容。他们真的对那些剧本有很多问题。

doUpdates 脚本可以从 Apress 网站下载。

[T2`https://github.com/Apress/linux-philo-sysadmins/tree/master/Ch09`](https://github.com/Apress/linux-philo-sysadmins/tree/master/Ch09)

## 额外的自动化水平

现在我有了这个令人难以置信的精彩而有用的脚本。我已经把它复制到我所有电脑上的/usr/local/bin。我现在要做的就是在适当的时候在我的每台 Linux 主机上运行它来进行更新。我可以通过使用 SSH 登录到每台主机并运行程序来做到这一点。

但是等等！还有呢！我告诉过你宋承宪有多酷吗？

`ssh`命令是一个安全的终端模拟器，允许用户登录到远程计算机来访问远程 shell 会话并运行命令。所以我可以登录到远程计算机，并在远程计算机上运行`doUpdates`命令。结果显示在我的本地主机上的 ssh 终端模拟器窗口中。该命令的标准输出(STDOUT)显示在我的终端窗口上。

那部分是琐碎的，每个人都这样做。但是下一步更有趣一些。与其在远程计算机上维护终端会话，我可以简单地在本地计算机上使用如图 [9-3](#Fig3) 所示的命令，在远程计算机上运行相同的命令，结果显示在本地主机上。这里假设 SSH 公共/私有密钥对 <sup>[2](#Fn2)</sup> (PPKP)正在使用中，并且我不必在每次向远程主机发出命令时都输入密码。

![../images/462716_1_En_9_Chapter/462716_1_En_9_Fig3_HTML.png](../images/462716_1_En_9_Chapter/462716_1_En_9_Fig3_HTML.png)

图 9-3

此命令使用公钥/私钥对进行身份验证，在远程主机上运行 doUpdates 程序

现在，我在本地主机上运行一个命令，通过 SSH 隧道向远程主机发送一个命令。好的，这很好，但是这意味着什么呢？

这意味着我能在一台电脑上做的事，我也能在几台甚至几百台电脑上做。图 [9-4](#Fig4) 中的 bash 命令行程序展示了我现在拥有的能力。

![../images/462716_1_En_9_Chapter/462716_1_En_9_Fig4_HTML.png](../images/462716_1_En_9_Chapter/462716_1_En_9_Fig4_HTML.png)

图 9-4

这个 bash 命令行程序在三台远程主机上运行 doUpdates 程序

以为我们完事了吗？不，我们不是！下一步是为这个 CLI 程序创建一个简短的 bash 脚本，这样我们就不必在每次想要在主机上安装更新时重新键入它。这不一定要花里胡哨；脚本可以像图 [9-5](#Fig5) 中的脚本一样简单。

![../images/462716_1_En_9_Chapter/462716_1_En_9_Fig5_HTML.png](../images/462716_1_En_9_Chapter/462716_1_En_9_Fig5_HTML.png)

图 9-5

这个 bash 脚本包含在三台远程主机上运行 doUpdates 程序的命令行程序

这个脚本可以被命名为“updates”或其他名称，这取决于您喜欢如何命名脚本以及您认为它的最终功能是什么。我认为我们应该把这个脚本叫做“`doit` `.`”现在我们只需输入一个命令，就可以在`for`语句列表中的所有主机上运行智能更新程序。我们的脚本应该位于/usr/local/bin 目录中，这样就可以很容易地从命令行运行它。

我们的小`doit`脚本看起来可以作为更广泛应用的基础。我们可以向 doit 添加更多的代码，使它能够接受参数或选项，比如在列表中的所有主机上运行的命令的名称。这使我们能够在主机列表上运行我们想要的任何命令，我们安装更新的命令可能是`doit doUpdates -r`或`doit` `myprogram`以在每台主机上运行“myprogram”。

下一步可能是从程序本身中取出主机列表，并将它们放在位于/usr/local/etc 中的 doit.conf 文件中——同样符合 Linux FHS。对于简单的`doit`脚本，该命令看起来如图 [9-6](#Fig6) 所示。注意后面的 tics(` ),它根据`cat`命令的结果创建了一个由`for`结构使用的列表。

![../images/462716_1_En_9_Chapter/462716_1_En_9_Fig6_HTML.png](../images/462716_1_En_9_Chapter/462716_1_En_9_Fig6_HTML.png)

图 9-6

我们现在添加了一个简单的外部列表，其中包含脚本将在其上运行指定命令的主机名

通过保持主机列表独立，我们可以允许非根用户修改主机列表，同时保护程序本身不被修改。给`doit`程序添加一个-f 选项也很容易，这样用户就可以指定一个文件的名称，该文件包含他们自己的运行指定程序的主机列表。

最后，我们可能希望将它设置为一个 cron 作业，这样我们就不必记得按照我们想要的时间表来运行它。设置 cron 作业值得在本章中单独讨论，所以接下来将会讨论。

## 使用 cron 实现及时自动化

有许多任务需要在没有人使用计算机的非工作时间执行，或者更重要的是，在特定的时间定期执行。我不想不得不在凌晨起床开始备份或重大更新，所以我使用 cron 服务重复地安排任务，比如每天、每周或每月。让我们看看 cron 服务以及如何使用它。

我使用 cron 服务安排一些显而易见的事情，比如每天凌晨 2:00 进行定期备份。我还做一些不太明显的事情。我所有的电脑都有自己的系统时间，也就是操作系统时间，使用网络时间协议 NTP 来设置。NTP 设置系统时间；它不设置硬件时间，硬件时间可能会漂移并变得不准确。我使用 cron 通过系统时间来设置硬件时间。我还有一个每天早上运行的 bash 程序，它会在每台计算机上创建一个新的“每日消息”(MOTD)，其中包含磁盘使用情况等信息，这些信息应该是最新的，以便于使用。许多系统进程也使用 cron 来调度任务。像 logwatch、logrotate 和 rkhunter 这样的服务每天都使用 cron 服务来运行程序。

crond 守护进程是支持 cron 功能的后台服务。

cron 服务检查/var/spool/cron 和/etc/cron.d 目录中的文件以及/etc/anacrontab 文件。这些文件的内容定义了将在不同时间间隔运行的 cron 作业。单个用户 cron 文件位于/var/spool/cron 中，系统服务和应用程序通常会在/etc/cron.d 目录中添加 cron 作业文件。/etc/anacrontab 是一个特例，我们将在后面介绍。

### 例行性工作排程

包括 root 在内的每个用户都可以拥有一个 cron 文件。默认情况下没有文件存在，但是使用如图 [9-7](#Fig7) 所示的 crontab -e 命令编辑 cron 文件会在/var/spool/cron 目录下创建它们。我强烈建议您不要使用标准的编辑器，比如 vi、vim、emacs、nano 或任何其他可用的编辑器。使用`crontab`命令不仅允许您编辑该命令，还可以在您保存并退出编辑器时重启 crond 守护进程。crontab 命令使用 vi 作为其底层编辑器，因为 vi 总是出现在最基本的安装中。

![../images/462716_1_En_9_Chapter/462716_1_En_9_Fig7_HTML.png](../images/462716_1_En_9_Chapter/462716_1_En_9_Fig7_HTML.png)

图 9-7

crontab 命令用于查看或编辑 cron 文件

第一次编辑时，所有 cron 文件都是空的，因此必须从头开始创建。我将图 [9-7](#Fig7) 中的作业定义示例添加到我自己的 cron 文件中，只是作为快速参考。可以随意复制自己用。

在图 [9-7](#Fig7) 中，前三行设置了一个默认环境。需要将环境设置为给定用户所必需的，因为 cron 不提供任何类型的环境。shell 变量指定执行命令时使用的 SHELL。在本例中，它指定了 bash shell。MAILTO 变量设置 cron 作业结果将被发送到的电子邮件地址。这些电子邮件可以提供备份、更新或任何其他内容的状态，并且包括程序的输出，如果您从命令行手动运行它们，您将会看到这些输出。这三行中的最后一行设置了这个环境的路径。然而，不管这里设置了什么路径，我总是喜欢在每个可执行文件前面加上完全限定的路径。

有几个注释行详细说明了定义 cron 作业所需的语法。我认为它们基本上是不言自明的，所以我将使用图 [9-7](#Fig7) 中的条目作为例子，然后再添加一些条目，向您展示 crontab 文件的一些更高级的功能。

图 [9-8](#Fig8) 中显示的行运行我的另一个 bash shell 脚本`rsbu`，来执行我所有系统的备份。这项工作在每天凌晨 1 点后 1 分钟开始。时间规范的位置 3、4 和 5 中的 splat/star/星号(*)类似于那些时间划分的文件组；它们匹配每月的每一天、每月的每一天以及一周的每一天。这一行运行我的备份两次；一次备份到内部专用备份硬盘上，一次备份到我可以带到保险箱的外部 USB 硬盘上。

![../images/462716_1_En_9_Chapter/462716_1_En_9_Fig8_HTML.png](../images/462716_1_En_9_Chapter/462716_1_En_9_Fig8_HTML.png)

图 9-8

/etc/crontab 中的这一行运行一个脚本，为我的系统执行每日备份

图 [9-9](#Fig9) 所示的行使用系统时钟作为精确时间的来源来设置计算机上的硬件时钟。这条线路设置为每天早上 5 点过 3 分运行。

![../images/462716_1_En_9_Chapter/462716_1_En_9_Fig9_HTML.png](../images/462716_1_En_9_Chapter/462716_1_En_9_Fig9_HTML.png)

图 9-9

这一行使用系统时间作为源来设置硬件时钟

最后一个 cron 作业，如图 [9-10](#Fig10) 所示，是我们特别感兴趣的一个。它用于在每月第一天的 04:25 执行我们的更新。这里假设我们使用的是图 [9-5](#Fig5) 中非常简单的`doit`程序。cron 服务没有“当月最后一天”的选项，所以我们使用下个月的第一天。

![../images/462716_1_En_9_Chapter/462716_1_En_9_Fig10_HTML.png](../images/462716_1_En_9_Chapter/462716_1_En_9_Fig10_HTML.png)

图 9-10

用于运行 doit 命令的 cron 作业，doit 命令又会运行 doUpdates

因此，现在我们网络中的所有主机每个月都会更新，完全不需要我们的干预。这是懒惰的系统管理员的终极表现。

### 克朗·德

cron 服务提供了一些其他选项，我们也可以使用它们定期运行我们的`doit`程序。目录/etc/cron.d 用于各种用户运行的系统级作业。这是一些应用程序在没有用户的情况下运行时安装 cron 文件的地方，这些程序需要一个位置来定位 cron 文件，因此它们被放置在/etc/cron.d 中。root 也可以将其他 cron 文件放置在该目录中，包括非 Root 用户的 cron 文件。许多 Linux 系统管理员更喜欢使用 cron.d 目录来存储 cron 文件，而不是使用位于/var/spool/cron 中的旧 crontab 系统来管理 cron 文件。

位于/etc/cron.d 中的 cron 文件具有与常规 cron 文件相同的格式。对于位于 cron.d 目录中的每个文件，我们上面提到的关于常规 cron 文件的所有信息都是相同的。

位于 cron.d 目录中的文件按字母数字排序顺序运行。这就是 0hourly 文件在其名称的开头有一个零的原因，因此它首先运行。

管理 cron 作业的 crontab 系统的一个缺点是，一些用户使用标准编辑器来修改文件。该方法不会将更改通知 crond 守护进程，因此更改后的 cron 文件在 crond 重新启动之前不会被激活。位于/etc/cron.d 中的 cron 文件则不是这种情况，因为 crond 每分钟都会检查文件修改时间。如果对文件进行了更改，crond 会将其重新加载到内存中。这是一种更积极的方法，可以确保 cron 文件的更改在做出更改后立即得到识别。

让我们为/etc/cron.d 目录创建一个简单的 cron 作业，该作业每分钟运行一次，因此我们不需要长时间等待结果。

### 实验 9-1

以 root 用户身份执行此实验。只有 root 可以向 cron.d 添加文件。

将/etc/cron.d 设为 PWD，并列出已经位于那里的文件。在一个简单的培训系统或虚拟机上，应该有三个。

```
[root@david ~]# cd /etc/cron.d ; ls -l
total 12
-rw-r--r-- 1 root root 128 Aug  2 15:32 0hourly
-rw-r--r-- 1 root root  74 Mar 25  2017 atop
-rw-r--r-- 1 root root 108 Aug  3 21:02 raid-check

```

现在使用您最喜欢的编辑器在 cron.d 中创建一个名为 myfree 的新文件，其内容如下。

```
# Run the free command every minute. The accumulated
# data is stored in /tmp/free.log where it can be viewed.
* * * * * root /usr/bin/free >> /tmp/free.log

```

保存新文件。它不应该成为可执行的。不需要对其权限进行任何更改。在另一个根终端会话中，使/tmp 成为 PWD 并列出文件。如果您没有看到 free.log 文件，请等到一分钟结束后大约一秒钟，然后重试。

当 free.log 文件出现时，使用 tail 命令跟踪文件的内容。它应该看起来与我的结果相似。

```
[root@testvm1 tmp]# tail -f free.log
          total        used        free      shared  buff/cache   available
Mem:    4042112      271168     2757044        1032     1013900     3484604
Swap:   8388604           0     8388604
          total        used        free      shared  buff/cache   available
Mem:    4042112      261008     2767212        1032     1013892     3494860
Swap:   8388604           0     8388604
          total        used        free      shared  buff/cache   available
Mem:    4042112      260856     2767336        1032     1013920     3495012
Swap:   8388604           0     8388604
          total        used        free      shared  buff/cache   available
Mem:    4042112      260708     2767452        1032     1013952     3495148
Swap:   8388604           0     8388604
          total        used        free      shared  buff/cache   available
Mem:    4042112      260664     2767468        1032     1013980     3495176
Swap:   8388604           0     8388604
          total        used        free      shared  buff/cache   available
Mem:    4042112      260772     2767280        1032     1014060     3495040
Swap:   8388604           0     8388604

```

几个周期之后，删除/etc/cron.d/myfree 文件，或者将其移动到另一个位置。这将停止该作业的执行。您也可以使用 Ctrl-C 退出 tail 命令。

有一个重要的服务依赖于位于/etc/cron.d，anacron 中的 0hourly cron 文件，我们应该查看一下。还有其他的，但是这个为运行计划任务提供了一些有趣的选项。

### 特点

crond 服务假定主机一直在运行。这意味着，如果计算机关闭了一段时间，而 cron 作业是在这段时间安排的，那么它们将被忽略，直到下次安排它们时才会运行。如果没有运行的 cron 作业很关键，这可能会导致问题。因此，当计算机不需要一直开着时，还有另一个定期运行作业的选择。

anacron 程序执行与常规 cron 作业相同的功能，但是它增加了运行作业的能力，如果计算机关闭或在一个或多个周期内无法运行作业，则会跳过这些作业。这对于关闭或进入睡眠模式的笔记本电脑和其他电脑非常有用。

在计算机打开并启动后不久，anacron 会检查已配置的作业是否错过了最后一次计划运行。如果有，这些作业会立即运行，但不管错过了多少个周期，都只运行一次。例如，如果一个每周作业因为系统在您外出度假时关闭而连续三周未运行，它将在您打开计算机后立即运行，但它将运行一次而不是三次。

anacron 程序提供了一些简单的选项来运行定期调度的任务。只需将您的脚本安装在/etc/cron 中。[每小时|每天|每周|每月]目录，这取决于它们需要运行的频率。

这是如何工作的？这个序列比它第一次出现时要简单。

1.  The crond service runs the cron job specified in /etc/cron.d/0hourly as seen in Figure [9-11](#Fig11).

    ![../images/462716_1_En_9_Chapter/462716_1_En_9_Fig11_HTML.png](../images/462716_1_En_9_Chapter/462716_1_En_9_Fig11_HTML.png)

    图 9-11

    /etc/cron.d/0hourly 的内容导致位于/etc/cron.hourly 中的 shell 脚本运行

2.  /etc/cron . d/0 中指定的 cron 作业每小时运行一次 run-parts 程序。run-parts 程序运行位于/etc/cron.hourly 目录中的所有脚本。

3.  The /etc/cron.hourly directory contains the 0anacron script that runs the anacron program using the /etdc/anacrontab configuration file shown in Figure [9-12](#Fig12).

    ![../images/462716_1_En_9_Chapter/462716_1_En_9_Fig12_HTML.png](../images/462716_1_En_9_Chapter/462716_1_En_9_Fig12_HTML.png)

    图 9-12

    /etc/anacrontab 文件的内容运行 cron 中的可执行文件。适当时间的[每日|每周|每月]目录

4.  anacron 程序每天运行一次/etc/cron.daily 中的程序；它每周运行一次/etc/cron.weekly 中的作业，每月运行一次 cron.monthly 中的作业。请注意每一行中指定的延迟时间，这有助于防止这些作业自身与其他 cron 作业重叠。

而不是将完整的 bash 程序放在 cron 中。x 目录，我将它们安装在/usr/local/bin 目录中，这允许我从命令行轻松地运行它们。然后，我在适当的 cron 目录中添加一个符号链接，比如/etc/cron.daily。

anacron 程序不是为在特定时间运行程序而设计的。相反，它旨在以指定的时间间隔运行程序，例如每天的凌晨 3 点(参见图 [9-12](#Fig12) 中的 START_HOURS_RANGE)、开始一周的周日以及每月的第一天。如果错过了任何一个或多个周期，那么 anacron 将尽快运行一次错过的作业。

### 日程安排提示

我在 crontab 文件中为我的各种系统设置的一些时间看起来相当随机，在某种程度上确实如此。尝试调度 cron 作业可能具有挑战性，尤其是随着作业数量的增加。我通常只在自己的每台计算机上安排几个任务，所以这比我工作过的一些生产和实验室环境要简单一些。

在我担任系统管理员的一个系统中，通常有大约 12 个 cron 作业需要每天晚上运行，另外还有 3 到 4 个必须在周末或月初运行。这是一个挑战，因为如果同时运行太多的作业，特别是备份和编译，系统将耗尽 RAM，然后几乎填满交换文件，这将导致系统崩溃，同时性能下降，从而什么也做不了。我们增加了更多的内存，并且能够更好地安排任务。调整任务列表包括删除一个写得很差并且使用大量内存的任务。

### 关于克隆的思考

我使用这些方法中的大部分来计划在我的计算机上运行的任务。所有这些任务都需要以 root 权限运行。我只见过几次用户真正需要任何类型的 cron 作业的情况，其中一次是开发人员在开发实验室开始日常编译。

限制非 root 用户对 cron 函数的访问非常重要。然而，在某些情况下，用户可能需要设置任务在预先指定的时间运行，cron 可以允许用户在必要时这样做。系统管理员意识到许多用户不理解如何使用 cron 正确配置这些任务，并且用户在配置中会犯错误。这些错误可能是无害的，但它们会给自己和其他用户带来问题。通过设置使用户与系统管理员交互的程序策略，这些单独的 cron 作业不太可能干扰其他用户和其他系统功能。

可以对分配给单个用户或组的总资源设置限制，但这是另一篇文章了。

### cron 资源

cron、crontab、anacron、anacrontab 和 run-parts 的手册页都有关于 cron 系统如何工作的极好的信息和描述。

## 其他自动化可能性

我已经自动化了许多其他需要在我负责的 Linux 计算机上执行的任务。下面的列表当然不是包罗万象的，只是想给你一些开始的想法。

*   备份。

*   升级(dnf-upgrade)。

*   将本地 shell 脚本的更新分发到一系列主机。

*   查找和删除非常旧的文件。

*   创建每日消息(/etc/motd)。

*   检查病毒、rootkits 和其他恶意软件。

*   更改/添加/删除邮件列表订户电子邮件地址。

*   定期检查主机的运行状况，如温度、磁盘使用情况、RAM 使用情况、CPU 使用情况等。

*   任何重复的东西。

### 一些另类想法

这里是我在互联网上发现的一些不寻常的自动化想法，它们推动了自动化和适当性这两个目标的界限。原始信息来自 GitHub 知识库，许多程序都有厌女症和 NSFW 的名字。我让你决定是否要在网上搜索这个人，但我不会帮你找到他。

在我找到的参考资料中，这些程序的创建者总是会自动完成每一项耗时超过 90 秒的任务。让我们从我最喜欢的几个开始。

首先是与连接到内部网络的“智能”办公室咖啡机一起工作的 shell 脚本。当这个程序员运行脚本时，它会等待 17 秒，连接到机器并告诉它开始煮一杯咖啡。它会等 24 秒，然后把咖啡倒进杯子里。显然，这是程序员走向咖啡机所花的时间。

接下来是一个脚本，让我们懒惰的系统管理员可以睡懒觉，而不用担心让团队知道他不在。如果他在早上的特定时间还没有登录到他的开发服务器，脚本会发送一封电子邮件来表明他将在家工作。该程序从一个数组中随机选择一个借口，并在发送前将其添加到电子邮件中。该程序由 cron 作业触发。

当然，这家伙工作到很晚的时候还会做什么？如果他在晚上的特定时间仍然登录，这个脚本会向他的妻子|女朋友发送一封带有适当随机借口的电子邮件。

这些脚本与他的编程工作没有直接关系。然而，它们会让他更有效率，因为他不必每天花时间处理这些事情。就我个人而言，我肯定不会自动给我妻子发电子邮件！

但这里的想法表明，几乎任何事情都可以自动化。也许这些“替代”想法会给你一些你自己的节省时间的自动化想法。

## 深化哲学

系统管理员自己工作的自动化是这项工作的一大部分。正因为如此，面向系统管理员的 Linux 理念的许多原则都与使用 shell 脚本和特定命令行编程来支持自动化的任务和工具有关。

计算机被设计用来自动化各种各样的日常任务，为什么不把它应用到系统管理员的工作中呢？我们这些懒惰的系统管理员利用我们工作的计算机的能力来使我们的工作更容易。尽我们所能实现自动化意味着我们通过创建自动化而腾出的时间现在可以用于响应其他人，尤其是 PHB 的一些真实或感知的紧急情况。它还可以为我们提供更多的自动化时间。

如果你反思我们在这一章中所做的，你会发现自动化不仅仅是创建一个程序来执行每一项任务。它可以使这些程序变得灵活，以便它们可以以多种方式使用，例如从其他脚本调用和作为 cron 作业调用的能力。

我的程序几乎总是使用选项来提供灵活性。本章中使用的`doit`程序可以很容易地扩展成比现在更通用的程序，同时仍然非常简单。如果它的目标是在一系列主机上运行特定的程序，它仍然可以做好一件事。

我的 shell 脚本并不仅仅包含成百上千行代码。在大多数情况下，它们作为一个单独的特别命令行程序启动。我从临时程序创建了一个 shell 脚本。然后，另一个命令行程序被添加到这个简短的脚本中。然后是另一个。随着简短的脚本变长，我添加了注释、选项和一个帮助特性。

然后，有时候，让一个脚本更通用是有意义的，这样它可以处理更多的情况。通过这种方式，`doit`脚本变得不仅仅能够为单个程序“做”更新。

<aside class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

David Both，Linux DataBook，《完成 Kickstart》， [`http://www.linux-databook.info/?page_id=9`](http://www.linux-databook.info/?page_id=9)

  [2](#Fn2_source)

如何伪造， [`https://www.howtoforge.com/linux-basics-how-to-install-ssh-keys-on-the-shell`](https://www.howtoforge.com/linux-basics-how-to-install-ssh-keys-on-the-shell)

 </aside>