# 20.记录一切

> 真正的程序员不会评论他们的代码，如果代码很难写，就应该很难理解，更难修改。
> 
> —未知

如果是我写的，我也想匿名。它甚至可能意味着讽刺或讽刺。不管怎样，这似乎是许多开发人员和系统管理员的态度。在一些开发人员和系统管理员中有一种很难掩饰的风气，即一个人必须自己搞清楚所有事情才能加入这个俱乐部——不管是什么俱乐部。他们暗示，如果你想不出来，你应该去做些别的事情，因为你不属于这里。

首先，这不是真的。其次，我认识的大多数开发人员、程序员和系统管理员肯定不同意这种观点。事实上，最优秀的人，其中一些多年来一直是我的导师，恰恰相反。精英中的精英让文档——好的文档——成为他们所做的每件事情的重中之重。

我用过很多软件，它们的创建者都认同这样一种理念，即所有代码都是不言自明的。我还被要求修复大量完全没有注释或者没有文档记录的代码。似乎许多开发人员和系统管理员认为如果程序对他们有用，就不需要文档化。

有很多类似上面的引用。他们都倾向于支持文档既不需要也不应该存在的观点。然而在我的职业生涯中。我已经看到了这种缺乏文件的灾难性后果。我已经不止一次被指派为修复未注释代码的系统管理员。这是我做过的最不愉快的任务之一。

问题的一部分是许多 PHB 没有将文档视为高优先级。我参与了 IT 行业的许多方面，幸运的是，我工作过的大多数公司都认为，文档不仅重要，而且对于手头的任务至关重要，不管这个任务是什么。

我想我从来没有听到任何人说，“这个文档太棒了。”大多数情况下，我听到一些特定的文档有多糟糕。我自己也多次重复这句话。

然而，有很多非常好的文档。例如，LibreOffice 的文档非常优秀。它包括多种格式的几个文档，包括 HTML 和 PDF，从“入门”到每个 LibreOffice 应用程序的非常完整的用户指南。

RHEL 和 CentOS 的文档，以及 Fedora 的文档——它们都是非常相关的发行版——也是我在 IT 行业工作的四十多年中所见过的最好的文档之一。

好的文档并不容易，而且需要时间。它还需要了解读者——不仅与文档的目的有关，还需要了解目标读者的专业技术以及读者的语言和文化。Rich Bowen 在 Opensource.com 的一篇优秀文章《RTFM？如何写出一本值得一读的手册。” <sup>[1](#Fn1)</sup>

还有一个问题是，对于一个系统管理员来说，什么是好的文档。我们在这一章中探索这些事情，这主要是关于记录我们写的脚本。

## 红色男爵

在我作为客户工程师的 IBM 职业生涯中，最令人沮丧的一件事是在一家炼油厂协助解决 IBM 1800 <sup>[2](#Fn2)</sup> 过程控制计算机上的一些问题。

这台特殊的计算机与炼油厂外的许多传感器相连，它被用来对生产过程中的各个部分进行调整。根据传感器读数，该计算机将调整温度和流速等事项，以确保过程的产品是正确的和高质量的。但是当事情出错时，它可能是灾难性的。我是说，拜托！这是一个该死的炼油厂的过程控制！

似乎写代码的程序员没有很好地注释他的代码——或者据我所知根本没有——并不是说我可以直接访问他的专有源代码。这位开发人员显然也不喜欢信息性的错误消息。

我不得不说代码很擅长检测错误。它似乎还擅长在炼油厂的地面上关闭受影响的流程。毕竟没有爆炸。然而，说程序在传达错误方面有缺陷是一种保守的说法。不管是什么错误，不管出了什么问题，控制台上打印的唯一信息是，“诅咒你，红色男爵，”以及一个数字错误信息，我们必须在一个很长的错误代码列表中查找。从列表中得到的信息也没有多大帮助。

为 IBM 说句公道话，这位程序员并没有为 IBM 工作。

## 我的文档哲学

我的哲学是多年来我最好的导师灌输给我的，“直到文档完成，工作才算完成。”这意味着一切都必须记录在案。文档也绝对不是节省打字时间的地方。尽管如此，好的文档对系统管理员的意义不同于对最终用户的意义。

在针对系统 *管理员*的 *Linux 理念的背景下，我们将考虑针对我们代码的目标受众——我们自己和其他系统管理员——的文档。我们系统管理员需要两种主要类型的文档。某种形式的体面的命令行帮助选项和注释良好的 shell 代码。*

### 帮助选项

在寻找帮助我理解 shell 脚本的文档时，我首先去的地方是 help 工具，因为我最常见的需求是理解启动程序的命令的语法以及命令的可用选项和必需或可选参数。这种类型的信息通常可以通过对所需命令使用-h 选项来获得。

我们在第 [10](10.html) 章“总是使用 Shell 脚本”中创建的 bash 脚本模板包含代码清单 [20-1](#FPar1) 中所示的模板帮助工具。你以前见过这个。注意，这只是一个模板，就像脚本模板的其余部分一样。必要时，需要在此过程中添加和修改为脚本提供有用帮助所需的所有细节。添加新选项或功能时，该信息也应记录在帮助工具中。

### 代码清单 20-1

```sh
##########################################################################
# Help                                                                   #
##########################################################################
Help()
{
   # Display Help
   echo "Add description of the script functions here."
   echo
   echo "Syntax: template <option list here>"
   echo "options:"
   echo "g     Print the GPL license notification."
   echo "h     Print this Help."
   echo "v     Verbose mode."
   echo "V     Print software version and exit."
   echo
}

```

像这样的简单帮助工具可以回答我关于脚本做什么的大部分问题，以及可以用来修改其行为的各种可用选项。在脚本功能描述、语法图、选项列表以及每个选项的简短描述之间，运行时问题很容易回答。

好的帮助是我们作为系统管理员编写的脚本的第一行文档。所有操作文档必须包含在帮助程序中。这也意味着脚本的用户界面应该非常明显和简单，这样就可以最大限度地减少任何形式的帮助。

### 宽松地注释代码

代码中的注释是文档的一种形式。事实上，它们应该是系统管理员文档的第一和主要形式。

作为我自己记录一切的需要的一部分，我在我的脚本中添加了许多注释。当试图减少注释时，我回想起当我必须解释和修复别人写的没有注释和没有文档记录的代码时的感觉。

我知道许多系统管理员和其他开发人员认为他们的代码是自解释的，甚至没有注释。不管我们的代码有多好，即使有大量的、写得很好的注释，代码也永远不会是不言自明的。我们思考问题的方式不同，编写代码的方式不同，解决问题的方式也不同。因为我们理解代码及其结构的方式不同，代码的目的对你来说可能是显而易见的，即使没有注释，对我来说可能是难以理解的。

在本书的前面，我们首先创建了一个 bash 脚本模板，然后使用该模板创建了一个简短的脚本。模板和脚本都得到了好评。这样做的目的是让我在构建代码时记得注释自己的代码。我在脚本模板中包含的注释是一个良好的开端。

我认为前三个部分特别重要。这些是程序描述、变更历史和许可声明。为了方便访问，我在代码清单 [20-2](#FPar2) 中再次包含了这些。

### 代码清单 20-2

```sh
#!/bin/bash
##########################################################################
#                              scriptTtemplate                           #
#                                                                        #
# Use this template as the beginning of a new program. Place a short     #
# description of the script here.                                        #
#                                                                        #
# Change History                                                         #
# 04/12/2017  David Both    Original code. This is a template for creating  #
#                          new Bash shell scripts.                       #
# 01/30/2018  David Both   Add an option for setting test mode.          #
#                                                                        #
#                          Add new history entries as needed.            #
#                                                                        #
#                                                                        #
##########################################################################
##########################################################################
##########################################################################
#                                                                        #
#  Copyright (C) 2007, 2018 David Both                                   #
#  LinuxGeek46@both.org                                                  #
#                                                                        #
#  This program is free software; you can redistribute it and/or modify  #
#  it under the terms of the GNU General Public License as published by  #
#  the Free Software Foundation; either version 2 of the License, or     #
#  (at your option) any later version.                                   #
#                                                                        #
#  This program is distributed in the hope that it will be useful,       #
#  but WITHOUT ANY WARRANTY; without even the implied warranty of        #
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         #
#  GNU General Public License for more details.                          #
#                                                                        #
#  You should have received a copy of the GNU General Public License     #
#  along with this program; if not, write to the Free Software           #
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA   #
#                                                                        #
##########################################################################

```

程序描述定义了程序的目的和一些主要的功能和选项。变更历史告诉未来的系统管理员可能需要对脚本进行维护，添加或删除了什么特性，修复了哪些错误，谁做了哪些工作，以及这些事情发生的时间。

许可证声明用于记录许可证，在该许可证下，脚本被分发并可供其他用户使用。这一点很重要，这样就不会对脚本的使用、修改和分发条件产生疑问。

代码中嵌入的注释应该描述它们所引用的代码段的功能。它们还应该包含为什么事情要以某种方式完成的信息，以及在不明显的地方对逻辑的解释。例如，下面的代码清单 [20-3](#FPar3) 中的代码片段有关于它的功能的注释，我做的一些假设，一个使用了新方法的指示器，旧代码被保留为注释，以便可以评估差异。

### 代码清单 20-3

```sh
###########################################################################
# Processing Intel CPU data
###########################################################################
# NOTE :This assumes certain data to be constant in /proc/cpuinfo based on
#       data from the chipsets.
if [ $verbose == 1 ]
then
   echo "This is an Intel box"
fi
CPUtype="Intel"
# Get number of CPU cores  
# CPUs=`cat /proc/cpuinfo | grep "^processor" | wc -l`
# New method below
CPUs=`cat /proc/cpuinfo | grep "cpu cores" | uniq | awk -F: '{print $2}' | sed -e "s/^ //"`

```

此外，代码清单 [20-2](#FPar2) 中的代码部分有一个标题，有助于在视觉上将其与代码的其他部分区分开来。这使得可视化代码的整体结构和功能流变得容易。

### 我的代码文档过程

哪个先出现？程序或文档。理想情况下，文档应该放在首位。然后可以开发代码来满足文档中概述的规范。在编写代码之前，您确实创建了规范，不是吗？这是我遇到的另一个常见问题:缺乏清晰的脚本规范。

如前所述，我喜欢通过使用注释创建我提议的代码的大纲来开始编码。这让我可以看到程序的结构，并确定它是否干净和优雅，允许我在编写任何代码之前，在必要时更改结构。无论我是在写新代码还是维护现有代码，注释是我添加的第一件事。这些评论成为我正在编写或维护的脚本的规范。然后，我可以编写代码来实现注释中描述的操作。

但是我并不总是一开始就做所有的评论。我首先创建一个基本大纲，包含描述程序逻辑的注释框架。我尽可能地创建了程序主体的轮廓。如果我设想使用额外的过程，我会创建并命名空过程，然后添加注释来描述其内部功能。

然后我创建代码来实现这个基本框架。我通常从程序的主体开始，在必要时添加新的注释，然后填充代码来实现这些注释。当我到达一个分支到一个不完整函数的调用时，我编写该函数并添加任何可能仍然需要的注释，然后编写代码来实现该过程。

这是我在本节开始时提出的问题的答案。至少对我来说，文档是第一位的。我可以听到敏捷支持者的键盘已经打出了他们相反的意见。但是从一个非常真实的意义上来说，我所做的是敏捷的，因为我只写我需要的文档，正好赶上写代码。然后评论也变成了文档。

并不是每个人都想这样工作，或者像我一样发现这很适合他们的工作方式。有多少人在做，就有多少种创建代码和记录代码的方法。做最适合你的事情，但是一定要做！

## 手册页

手册页在什么地方适合这种记录一切的哲学？坦率地说，对于系统管理员编写的脚本来说不是很好。

在早期，我们讨论了我们系统管理员工作的时间限制，以及我们编写的大多数脚本都倾向于作为操作问题的最小化解决方案的事实。在这种环境中，我们几乎没有时间来创建手册页。底线是我不会花时间去创建手册页。

## 系统文档

这种类型的文档不是关于记录脚本或程序的。它是关于记录网络的状态，连接的主机，以及我在它们上面执行的任何工作。这份文件对我以前咨询公司的客户，以及我作为全职员工或承包商工作过的任何雇主来说都是至关重要的。

我曾经拥有一个小的有限责任公司，通过它我可以做一些关于 Linux 和开源的咨询。我仍然为我的教会和几个朋友做一些咨询。

当与客户一起工作时，我总是记录我与他们的互动以及我所做的工作。像这样的文件为我服务，就像医生对我的就诊记录为她服务一样。这是客户环境的永久记录，我可以在与他们打电话或进行电子邮件交谈时参考。它为我提供了对我发现的问题以及我采取的解决措施的持续评论。

在某些情况下，我有多年的文档，涵盖了从我第一次与他们联系到我在为他们工作时发现的关于他们网络的信息，我为他们安装的硬件的细节，我在项目中工作的细节，以及我每次安装更新的记录。我在这些记录中加入了数据，如网络图、网络 IP 和 MAC 地址表以及每个节点的功能说明。我还保留了我编写的脚本的输出，该脚本列出了我工作的每台 Linux 主机的硬件和一些配置细节。

这些信息有多种用途。它给了我一个记录，以便我可以回去回忆我做了什么以及我的客户环境的结构，这对我来说是一个记忆辅助工具。需要时，我可以用它来支持我对额外工作的建议。在与客户发生纠纷时，保留详细的记录也很有用。

在为客户工作之前，我总是会创建一个任务列表，这样我就不会忘记任何需要完成的事情。我在清单上做笔记，然后，在工作结束时，任务清单成为我已经完成的工作的文档的一部分，并由我在工作过程中所做的笔记进行补充。对于我的一些客户来说，我已经完成了超过 40 页的这种类型的文档。

对于这种类型的文档，我通常使用 LibreOffice Writer。Writer 使用开放文档文本(ODT)格式，这是一种开放的、众所周知的格式，被许多文字处理程序所使用。即使是 Microsoft Word 也可以使用 odt 格式。

对这种类型的文档使用文字处理程序可以让我把它做得很漂亮，这样当我把它的副本给我的客户时，它看起来就很好。

### 系统文档模板

我创建了一个模板——实际上是一个模板的大纲——它帮助我记录我过去工作过的组织的系统信息。下面的简化大纲对我来说很有用，如果你还没有这种类型文档的规范或模板，我建议你把它作为一个起点。请随意使用和修改它，以满足您自己的独特需求。

1.  标题页。

2.  目录。

3.  表格索引。

4.  插图索引。

5.  代码列表的索引。

6.  简介–对文件和组织的简要描述。

7.  管理员–当前系统管理员及其联系信息的列表。

8.  互联网连接–对互联网连接和提供互联网连接的 ISP 的描述。这可能包括有关合同日期和成本的信息。
    *   电缆线路——描述从 ISP 的街道连接到分界点(通常是 ISP 的调制解调器/路由器/交换机)的物理电缆位置。

    *   外部 IP 地址–外部 IP 地址(如果是静态的)和通用 IP 地址范围(如果是 DHCP)的列表。

9.  内部网络–内部网络的描述。
    *   所有内部网络的内部 IP 地址空间。

    *   防火墙–对属于组织而非 ISP 的防火墙的描述。

    *   物理描述–包括文本描述、网络图和地址映射，其中列出了每个网络节点、其名称、MAC 地址、IP 地址、网络配置是静态还是 DHCP，以及对其功能的简短描述。

10.  硬件–每个网络节点的列表。
    *   硬件的描述。这可以使用本书前面创建的 mymotd 程序来创建。

    *   操作系统。对于 Linux，这包括分发和发布。

    *   网络节点提供的功能描述。

11.  操作系统和软件
    *   所有操作系统及其在哪些主机上运行的列表。

    *   每台主机上特定软件的列表。这并不意味着所有的软件，如没有线索的 PHP 可能会要求，但主要的软件，该主机打算。例如，对于一个简单的桌面，你可以说“桌面软件”。对于服务器，这可能是，“DHCPD，HTTPD，命名”，等等。

    *   许可证–可能相关的软件许可证信息，如续订信息和费用。拥有专有许可的软件应列出许可证 id 或编号，以便在需要进行许可证合规性审核时参考。

12.  主机配置–常见的主机配置项目，如 DNS 和 DHCP 服务器、默认网关、电子邮件服务器等方面的网络配置。

13.  管理任务–各种管理任务的列表，以及负责执行这些任务或监控这些任务(如果它们是自动执行的)的系统管理员或用户。

14.  联系人列表–包括内部系统管理员和管理联系人及其职责，以及所有供应商的联系人，包括 ISP、硬件和软件供应商、HVAC、数据中心冷却、UPS、内部安全、外部安全公司、外部紧急联系人(如消防和警察)以及您可能想到的任何其他人。

15.  活动日志–这是我与客户联系的日志以及我为客户完成的工作。在描述问题及其解决方案时，这一部分应该尽可能清晰明了。

这个模板是一个很好的起点。拥有这种类型的文档作为记忆辅助是很重要的——我总是很高兴不用问客户我为他们做了什么，因为我可以很容易地找到它。在最坏的情况下，当客户或 PHB 质疑你的行为时，你可能会发现有必要使用一份维护良好的文件作为证据。我很幸运，从未发现自己处于最坏的情况。

## 记录现有代码

为现有代码创建文档需要不同于任何其他类型的方法。

我做的第一件事是阅读源代码，对我来说几乎总是 Perl 或 bash 脚本。然后，我可以使用这些评论作为创建外部文档的起点——如果有任何评论，如果这些评论有任何意义的话。

很多年前，我接手了一份工作，负责维护和修复大量预先存在的 bash 脚本。这些脚本是该公司使用的一系列复杂内部应用程序的一部分。代码可以工作——大多数情况下——但是过于复杂，缺乏任何可用的注释和文档。

我的第一个任务是修复几个脚本中的一些错误。我开始阅读这些脚本，以确定它们实际上应该做什么。当我确定了代码的每一部分是做什么的时候，我添加了注释来描述我刚刚阅读和解释的代码。就在这个过程中，我能够确定一些错误的原因并纠正它们。

在这个初始阶段，通过阅读 bash 脚本和询问 IT 人员，我确定这些脚本最初是由几个不同的承包商编写的，并且由一系列其他承包商维护了多年。每个承包商都添加了一些代码，这些代码显然是为了规避他们遇到的问题。这些附加的代码没有一个试图修复根本原因。每个承包商都有自己的做事方式，比如变量的命名方案、缩进、编码风格和注释。那些剧本完全是一场灾难。

那个项目简直是一场噩梦。我花了几周时间来分析代码，并给代码添加适当的、可理解的、有用的注释。这项任务很繁琐，而且由于变量的命名明显是随机的，因此变得更加困难。这是这么多不同的人在没有任何类型的指导或监督的情况下在项目目标或编程风格方面工作的不可避免的结果之一。

在我完成了注释这些脚本的任务之后，尽可能多地重命名变量，解决剩下的问题就变得容易多了。

当然，其他人写的代码并不是唯一有这些问题的代码。我自己的代码，尤其是我的大部分旧代码，也面临着同样的问题。这是因为我还没有了解 Unix 或 Linux 的哲学。随着时间的推移，我的代码确实有所改进，当重新访问我的一些旧代码来修改它或修复一个问题变得有用时，我会修改它，以遵循从我还是一个系统管理员时就学到的更好的编程实践。

## 保持文档更新

我自己的文档有一些问题。首先是忽视了及时或完整地更新文档。当我需要的信息没有被正确记录时，这就造成了问题。

当我发现我在文档方面有所松懈时，我会尽快回去改正它。这通常意味着纠正和更新我的脚本中嵌入的注释。这还意味着修复帮助过程，使其与对代码所做的更改保持一致。

更新我的客户文档也是我需要跟上的一项任务。我有时会忘记这样做，因为我似乎总是急于下一个任务。

让我的文档保持最新需要自律。如果没有持续的维护，文档可能会过时。

### 文件兼容性

文件兼容性也可能是外部文档的一个问题——即我的代码之外的文档，如客户文档。几年来，我使用了一些开源软件，这些软件以非纯文本的格式维护我的数据，从某种意义上说，这些数据是专有的，没有文档记录，其他软件也无法访问。这至少部分是因为我不知道数据格式，这是我自己的错。这也是该程序开发者的错误，因为他们应该使用开放格式的数据。

在第 [13](13.html) 章“以开放格式文件存储数据”中，我们探讨了使用开放格式的一些原因。重点是程序本身使用的数据。现在我们来看看系统管理员用来维护各种类型的文档的数据，比如客户访问记录和维修历史记录。这些是重要的文件，因为它们使我们能够回过头来回顾已经完成的工作，并感受我们在确定当前问题方面取得的进展。

因此，当有问题的程序升级未能正确升级存储数据的数据库时，我无法访问几年来的客户记录。即使回到程序的前一个版本也不能恢复我的数据，因为它已经被破坏了。不幸的是，我的备份不像现在这样广泛，所以我无法回溯足够远的时间来获得未损坏的副本。

我现在以开放文档格式(ODF)保存我的笔记。ODF 是一种众所周知的、开放的、文档化的格式，有许多应用程序可以使用它。尽管这一原则具体指的是程序数据，但我认为一个必然的结果应该是文档应该以一种开放的格式保存，比如 ODF。

## 一些想法

文档对系统管理员来说非常重要。在履行我们的日常职责时，我们依赖他人留给我们的文件。我们工作的质量和速度直接受到文件质量的影响。这里有一些记录我们脚本的指导方针。

1.  脚本应该用清晰而有意义的注释来记录。

2.  脚本应该易于阅读。这是自我记录的一种形式。

3.  脚本应该有一个有用和简洁的帮助功能。

4.  遵循这些原则会产生优雅的脚本。

作为与客户互动记录或内部记录保存的系统文件应始终保持最新。工作完成后应尽快进行记录，以确保尽可能准确地回忆信息。

无论您做什么，无论您选择什么工作方式，请记住，在文档完成之前，工作还没有完成。

<aside class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

鲍文，里奇，Opensource.com， *RTFM？如何写一本值得一读的手册*、[、`https://opensource.com/business/15/5/write-better-docs`、](https://opensource.com/business/15/5/write-better-docs)

  [2](#Fn2_source)

工程与技术维基， *IBM 1800* ， [`http://ethw.org/IBM_1800`](http://ethw.org/IBM_1800)

 </aside>