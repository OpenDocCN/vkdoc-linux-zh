# 17.力求优雅

优雅是很难定义的事物之一。当我看到它的时候我就知道了，但是把我看到的用一个简洁的定义表达出来是一个挑战。使用 Linux `dict`命令，Wordnet 给优雅下了一个定义:“在解决一个问题(特别是在科学或数学方面)时整洁和巧妙简单的品质”；他的发明的简单和优雅。"

在本书的上下文中，我认为优雅是硬件和软件的设计和工作中的一种美丽和简单的状态。当一个设计是优雅的，软件和硬件工作得更好，效率更高。简单、高效、易懂的工具有助于用户。

在技术环境中创造优雅很难。也是必要的。优雅的解决方案产生优雅的结果，并且易于维护和修复。优雅不是偶然发生的；你必须为之努力。

简单的品质是技术优雅的很大一部分。如此之大，事实上它应该有自己的一章，第 [18](18.html) 章，“寻找简单”，但我们在这里不忽略它。本章讨论了硬件和软件优雅的含义。

## 硬件优雅

是的，硬件可以是优雅的——甚至是漂亮的，赏心悦目的。设计良好的硬件也更可靠。优雅的硬件解决方案提高了可靠性。

我们许多系统管理员既负责软件，也负责硬件。对于我们这些在小型组织中工作的人来说尤其如此，但在大型环境中也是如此。在我为思科工作的五年中，我的系统管理员工作需要我给新服务器装架和布线，识别和修复硬件问题，帮助设计机架布局和电源要求，以及更多与硬件相关的任务。

理解硬件的优雅与理解软件和操作系统的优雅同样重要。

### 印刷电路板

在谷歌上搜索“pcb <sup>[1](#Fn1)</sup> 可靠性”，可以找到许多关于 pcb 设计和可靠性的文章和论文。Darvin Edwards 的一篇文章“PCB 设计及其对器件可靠性的影响”， <sup>[2](#Fn2)</sup> 讨论了影响可靠性的 PCB 设计的四大领域。爱德华兹讨论的一个因素是热机械可靠性。反复的功率循环会导致快速的热变化，进而导致元件、走线(电导体)和焊点的膨胀和收缩。随着时间的推移，这些重复的热应力循环会导致 PCB 出现各种类型的故障。

在我大学的一门技术制图课上，我的作业之一是为印刷电路板绘制一组图纸。布局已经提供了，我真正需要做的就是使用我们刚刚学到的一些新技术重新绘制它。

当我查看图中的元件布局、走线和焊盘图形(元件焊接在 PCB 上的位置)时，我有了一点感悟。我们在课堂上学到的一件事是，每个焊点都是潜在的故障点，PCB 上使用的每个跳线(用于“跳过”其他走线的短导线)都会增加两个故障点，每个焊点一个。在这个板上有两个跳线，我决定看看我是否可以改变设计来消除它们。我把几条线路改到了不同的位置，消除了跳线。我把这个给老师看了，他的回答是这是一个更好的解决方案。他在那个项目上给了我一个好分数。

### 底板

硬件优雅可能意味着主板的简单和布局良好的设计，这是一个相当大的 PCB。如前所述，良好的主板设计可以提高可靠性。

在我看来，一个布局良好的主板，看起来很好，表面有光滑的导线和焊盘图案(元件焊接的安装焊盘),是优雅的。主板上放置的组件不会相互干扰，也不会与以后可能添加的其他组件(如功能强大但较长的视频适配器)相互干扰，CPU 插槽位于主板上，以便 RAM 内存和其他主板组件不会干扰添加高容量空气冷却风扇或液体冷却设备，这是一种优雅的设计。坦率地说，我一直很欣赏设计良好的主板的外观。这些主板是真正的艺术品。

### 计算机

设计良好的电脑是优雅的。这包括一个Shell，其设计便于接触内部组件，提供大量不受限制的气流，大量安装风扇和液冷散热器的位置，以及大量便于电缆布线的选项。

这与主板上的大量 LED 照明、风扇、LED 灯条和花哨的照明控制器无关。这种东西是用来表演和娱乐的。我为我的主工作站购买的最新主板是华硕 TUF X299，它满足了我对这台工作站的所有要求。这也是唯一一个满足我所有需求的。它的背面恰好有一串发光二极管，可以产生简单的滚动颜色的光显示。我没有在 BIOS 中关闭它们，因为它们有点好玩，但我不会特意在我的需求中添加 LED 显示。

当外部电源和硬盘活动指示灯容易看到，并且亮度适中，因此在任何照明条件下都能看到时，计算机就是优雅的。电源和复位开关也很容易操作，但不要太显眼，否则可能会被意外碰到，导致计算机复位或关机

我可以继续说下去，但你应该明白。

### 数据中心

硬件优雅还意味着精心规划和建造的机房或数据中心。机架式盘柜的布局方式使得多个电源可以轻松接入，并且前后通道畅通无阻。布线整洁有序——不像图 [17-1](#Fig1) 中那样杂乱无章；它被切割成一定长度，在整个计算机房的电缆通道和电缆槽中无扭结或缠结..

![img/462716_1_En_17_Fig1_HTML.jpg](img/462716_1_En_17_Fig1_HTML.jpg)

图 17-1

它可能会完成工作，但这种布线工作肯定不是优雅的。知识共享 CC0

应使用不间断电源来维持所有设备的电力供应，直到发电机可以联机，并且在电源故障的情况下，电力可以切换到该发电机以实现长期稳定。电源和接地导线本身的布线应既安全又方便。

### 电源和接地

很难想象计算机的电源和接地应该有一个像“优雅”这样的术语。但是这里有一些事情需要考虑。

大约在 1976 年，我在俄亥俄州利马的 IBM 公司担任客户工程师。除了修理坏掉的电脑和安装新电脑，我的职责之一是协助客户规划新电脑的安装。这包括规划合适的电源和接地。在这种特殊情况下，我与客户就电源和良好接地的要求进行了长时间的讨论。良好的接地对于正确的电子操作和计算机的稳定性至关重要。

那么什么是好的理由呢？这是一根带有绿色绝缘(绿色地线)的大规格电线，从受保护的设备(计算机)连接到一个埋在潮湿土壤中至少 10 英尺深的铜桩。绿线接地不得连接任何其他接地线，也不得连接到它所经过的任何配电箱中的任何接地或中性母线。请注意，这是 IBM 对计算机逻辑操作完整性以及人类安全的定义。

经过我们的讨论后，客户说他们有一口旧井，内衬铜，至少有 80 英尺深，水深超过 60 英尺。这是一个很好的接地，我同意将计算机的绿线接地连接到井套管是合适的接地。使用这个预先存在的非常好的地面点是一个优雅的解决方案。

安装后，我们除了问题什么也没有。这些看似随机但经常发生的问题，某一天可能是内存故障，第二天可能是磁盘问题，第三天可能是处理器问题，等等。在大约两周的时间里，我们更换了内存、CPU 板和几乎所有我们能想到的东西，客户感到不安是可以理解的。

我现在相当确定这是接地问题。我和工厂的电工讨论了接地问题，他说他已经按照我们讨论的那样接好了地线。但我必须亲眼看看才能确定。

我拿出示波器，用一个感应钳夹住地线，这样我就能看到地线的任何电噪声。当我把这一切都搞定后，IT 副总裁过来了，我告诉他我在做什么。至少可以说，他有点怀疑。

就在我们结束讨论的时候，我们都听到了一个电机启动的声音，在示波器上出现了一大串电噪声。不一会儿，有人从机房跑出来，大喊电脑坏了。我不可能找到比心怀不满的副总统更好的听众了。特别是因为我们听到启动的马达是我们旁边的大型软饮料机上的压缩机马达。

我们让电工开始拆除所有配电箱的前面板，以便查看和验证绿线接地的完整性。在我们看的第一个盒子里，我立刻发现了问题。有一根又大又丑、看起来很脏、很旧的电线被嫁接到我们曾经干净的绿色电线地上。

大约就在这个时候，有人走进我们一直站着的那个小房间，把几封信放进了邮资机。地线产生的噪音说明了一切，因为这两个设备都插入了同一个电源插座。我们让电工剪掉了我漂亮的新的干净的绿色地线的丑陋的旧地线，客户再也没有因为接地问题而引起的其他问题。

有时候，优雅是一个原始的绿色电线地面。

## 软件优雅

在这里，我回到专门讨论 shell 脚本，这是系统管理员通常做的编码类型。对于一个系统管理员来说，用像 C 这样的语言编写代码是很不寻常的，这需要更多的开发工作，并且需要编译。对于系统管理员来说，这是对时间的浪费。

关于软件优雅有很多观点。是什么让软件变得优雅，在软件世界中“优雅”是什么意思？以下是我的一些观点，并对每一个观点做了一些解释。

一般来说，优雅是看起来很好，甚至很漂亮的代码，并且遵循本书中概述的原则。在我看来，当你使用这些指导方针时，软件是优雅的。这是我列出的特征，我敢打赌，其他系统管理员对于什么是软件优雅有他们自己的想法。在任何情况下，这些都不是硬性规定，只是指导方针。任何软件最重要的方面是它应该执行你写它要做的任务。使用这些指导方针可以让其他人——和你——更容易理解你做了什么，并维护你写的代码。

1.  **使用一致的缩进**——代码应该在过程和流程控制结构的缩进中保持一致。这有助于在各种情况下更容易可视化程序的结构和执行流程。
    *   我知道一些开发人员使用制表符缩进，其他人使用空格。人们使用的制表符或空格的数量也各不相同。只要代码能被任何没有编写它的人容易地阅读——也能被那些确实编写了它的人容易地阅读，那么这基本上是无关紧要的。

2.  **布局清晰的设计** -代码应该很好地布局和排序，以便在各种条件下容易看到执行的流程。
    *   最有效的代码是以直通方式执行的代码，它不会来回跳转，也不会有不必要的流控制结构来降低速度。

    *   使用过程有很好的理由，例如防止在多个地方复制相同的代码。然而，在可能的情况下，程序的主体应该以简单明了的方式流动。

3.  **使用****STDIO**——我们已经看到 STDIO 是一个强大的使能器；它允许我们将许多小程序链接在一起，以执行单个程序无法完成的复杂任务。具有强制用户界面(CUI)的程序(如菜单)不提供 STDIO。这种程序仅限于独立存在，不能在数据流中工作。应该避免使用强制用户界面，因为它们的局限性太大，不能很好地与命令行管道和重定向配合使用。
    *   fdisk 程序是使用菜单界面的有用且强大的实用程序的一个例子。这样做的问题是 fdisk 不能在脚本中使用。有人编写了一个单独的程序，从脚本中执行 fdisk 函数。目前的工具是 sfdisk。

4.  **添加有意义的注释** -程序被很好地注释了有意义的信息。这有助于让维护人员清楚代码的目的，并确保可以快速定位和修复问题。

5.  每个程序都应该做好一件事——这个指导原则一直是 Unix 和 Linux 哲学的宗旨，并产生了核心实用程序，以及其他小型的、针对单一任务并能很好地执行该任务的核心实用程序。这就产生了强大而灵活的命令行程序，可以组合成管道来执行单个程序无法完成的复杂任务。
    *   这样做的一个副作用是做一件事的程序往往很小。这使得它们易于理解，并在必要时进行修改。

    *   这个原则的推论是，给这些小程序增加更多的功能通常不是一个好主意。对所谓“新特性”的需求实际上应该被看作是对新程序的需求，新程序也应该遵循这些指导原则。大多数新特性，当修补到现有程序上时，只会造成代码膨胀，使程序更难使用和维护。

6.  **沉默是金**——Linux 命令行工具通常不会向系统管理员显示一切正常的消息。这可以防止不需要的消息进入 STDOUT 数据流，进入管道并给后面的程序造成混乱。

7.  **总是使用最少的必要代码** -使用执行所需任务所需的最少代码。其他的都是糟粕，应该淘汰。这就是简单的症结所在，也是复杂的对立面。
    *   一些程序员喜欢炫耀错综复杂的代码，这些代码无法确定入口和出口。这种类型的代码不太实用，容易出现错误。

    *   在另一个极端，有一种游戏，一种竞赛，真的，叫做“代码高尔夫” <sup>[3](#Fn3)</sup> 目标是用最小可能的结果可执行二进制实现指定的算法。这绝对是*而不是*我们在这个特定的指导方针中所做的。诸如此类的竞争是好的，只要它们不被带入系统管理的实际实践中。在 SysAdmin 的上下文中，使用最少的必要代码意味着尽可能地满足这些准则的其余部分。Code golf 则不然，因为它在追求最小化的过程中忽略了其他一切。

8.  **输出易于阅读和理解** -当需要任何输出时，用户应易于理解。对于许多程序来说，输出是它们存在的理由。
    *   充斥着与程序目的没有什么关系的消息和其他信息的输出混淆了重要的数据。输出的实际结构并不重要，只要它清楚地服务于预期的目的。

9.  使用有意义的变量名**——我喜欢在我的命令行和 shell 编程中使用有意义的变量名。对于几年后需要调试代码的人来说，随机变量名或像$X 这样的名字没有什么意义；这包括最初编写代码的人。

    *   像$AccountTotal 和$NumberOfUsers 这样的名字远比$A1、$B3 更有意义。它们使得阅读代码更加容易。它们也是第 20 章中“记录一切”原则的良好开端。命名良好的变量告诉程序维护人员，在调试程序时，变量如何适应程序的逻辑以及预期的值的种类。

    *   回到我负责清理的 Perl 程序，变量名是如此的随机，以至于其中几个变量名指向同一个东西。我重命名了程序中的所有变量，然后能够用一个单独的变量名代替同一个变量的其他不同名称。仅仅这一小步就在清理该特定程序方面向前迈出了一大步。

     **
***   **遵循埃里克 S.** **雷蒙的** **17** **Unix** **规则**<sup>[4](#Fn4)</sup>**-**这是包括系统管理员在内的所有开发人员都应该阅读和理解的 17 条规则。Raymond 在他的书《Unix 编程的艺术》中详细阐述了这些规则。 <sup>[5](#Fn5)</sup> 维基百科对这些规则有一个很好的总结(见脚注 3)。
    *   如果你认为我的列表中缺少一个重要的指导方针，它可能在雷蒙德的规则列表中。请务必阅读这些规则，因为它们适用于系统管理员和开发人员。

         *   测试一切 -这难道不明显吗？！显然不是，因为我遇到过很多显然没有经过很好测试的软件。
    *   我在思科的工作是双重的。有一段时间我是实验室经理的助理，测试部门的测试就是在那里进行的。其余时间，我是测试人员之一，负责测试 Linux 驱动的设备。

    *   测试不仅仅是运行一系列测试程序来验证被测软件可以执行其设计任务，它还确保软件在遇到意外输入时不会失败。黑客用来获得对由软件运行的计算机和其他设备的未授权访问的最常见的漏洞之一是软件不能处理意外输入。

    *   我做的其他测试是简单地阅读文档和代码，以确定代码是否符合文档中概述的规范。如果没有，我不得不使它失败，或者开发团队不得不获得一个异常，这是很少见的。

    *   在审查代码和文档时，我所做的一部分工作是确保代码的设计支持 Linux 理念和文档完善的标准，如文件系统分层标准，以及为确保所有 Linux 发行版使用的一致性而创建的标准。

         *   清除 cruft - Cruft 是程序中从未使用过的所有旧代码。许多程序随着时间的推移而发展，有时曾经有用的代码不再需要。当我修改自己的脚本或添加新的特性或选项时，我有时会发现自己的代码和变量不再被使用，需要清理掉。

     **

 **遵循这些准则将有助于确保您编写的代码易于阅读和修改。它看起来很好，运行也很好。会很优雅的。

## 修复我的网站

现在你已经知道我使用 WordPress 来托管我自己的网站和其他网站。我使用它是因为它是免费的开源软件，能够很好地完成任务并提供很大的灵活性。然而，事情确实会出错。你可以指望它。在这个特殊的例子中，我在不同的网站上遇到过两次这个问题，现在已经修复了两次。

这个问题的症状是令人费解的，直到我确定了来源。在博客页面上看起来一切正常，这是我的 both.org 网站的主页。这个问题只在我试图显示这个网站的任何静态页面时才出现。

静态页面显示主题元素，如顶部横幅和网站名称。每一页都显示了正确的标题，但没有显示内容。这是一个没有内容的页面。我试图改变主题，但没有成功，这意味着问题不在于主题本身。我安装了另一个 WordPress 实例，并将其指向 both.org 网站现有的 MySQL 数据库。症状没有改变或消失。

唯一需要检查的地方是 MySQL 数据库。太糟糕了，我忘记了`mysqlcheck`工具；我可能会很容易地解决这个问题。幸好我忘记了`mysqlcheck`工具，因为我学到了比其他方式更多的东西。

这个问题很容易解决。我将该网站的 mysql 数据库文件从我的日常备份复制到/var/lib/mysql/wordpress 目录，并重新启动 MySQL。

WordPress 可以为每个网站使用不同的 MySQL 数据库，或者为每个网站使用一个带有不同表格的 MySQL 数据库。每个网站的表都有不同的表名前缀。这个前缀在 WordPress wp-config.php 文件中为每个站点定义。

我在/var/lib/mysql/wordpress 目录中找到了正确的数据库文件集，并把它们保存到另一个位置以防万一。然后我去了我的一个几天前的备份，因为我不确定这个问题是什么时候开始的。我把备份文件复制到/var/lib/mysql/wordpress 目录，重启 mysql。在这一点上一切都很好。我可能不需要重新启动 MySQL，但是我想我可能还需要一个干净的重新启动来刷新可能在某个地方的缓存中的任何东西。

唯一可行的方法是 WordPress 和 MySQL 都打开，这样我就可以查看 WordPress 的代码以及 WordPress 和 MySQL 的配置和数据文件。我本来可以下载 MySQL 的源代码，但是不需要。对于 WordPress 我也不需要这么做，但是因为它是用 PHP 编写的，所以它是完全开放的。

MySQL 的数据文件存储在 Linux FHS 定义的位置/var，这是数据库文件！我能够找到它们，确定哪些文件属于我的网站，并轻松地用以前的备份替换它们。

另一个促成因素是，我编写的备份脚本创建了以正常格式和目录结构存储文件的备份。它不会将它们压缩成 tarballs、zip 文件，或者——更糟糕的是——某种专有的备份格式。我可以用 cd 和 cp 之类的命令行工具访问我的文件；午夜指挥官(mc)文本模式文件管理器；或者诸如 Krusader、Dolphin 等 GUI 文件管理器。当我找到我想要的备份文件时，我可以简单地将它们复制到所需的位置来替换损坏的文件。

也可以使用`mysqldump`命令将数据导出到一个文件中，该文件是将重建数据库的 SQL 命令的脚本。我过去曾经尝试过这种方法，发现效果相当好。两种方法都可以，但是我更喜欢我自己的方法。

WordPress、MySQL 和我的备份解决方案的优雅结合在一起，可以轻松解决手头的问题。我从解决这个问题中学到的一件事是，对于 MySQL 数据库来说，花哨的备份解决方案是不必要的。

## 拆卸脚

创造优雅是一项艰苦的工作。维护它会更加困难。Cruft 是程序中多余的程序和代码，旧的数据文件，以及包含已删除程序中剩余文件的目录。

作为系统管理员，清除 cruft 是我们工作的一个重要部分。我们可以搜索 cruft 的东西包括旧的或未使用的软件、我们自己脚本中的旧代码以及旧的配置和数据文件。幸运的是，我们有一些工具可以帮助我们完成这项任务。

### 旧的或未使用的程序

我刚刚删除了一些我不用的程序。我正在使用 KDE 应用启动器，注意到列表中有几个 Calligra 办公套件程序。我从来不用 Calligra，更喜欢 LibreOffice。它被默认安装在 Fedora 上，我在几个月前测试的时候用了它。因为我永远不会在我的生产工作中使用它，所以我决定删除它。

但是我们如何主动搜索不用的程序呢？有一种方法可以找到所谓的孤儿——任何其他程序都不需要的程序。这种情况通常很少，所以使用我们必须尝试找到它们的工具不会有什么坏处。对于此任务，我们使用`rpmorphan`实用程序列出 RPM 软件包，这些软件包不依赖于主机上安装的任何其他软件包。

### 实验 17-1

如果 rpmorphan 包还没有安装，请安装它。

```sh
[root@testvm1 ~] dnf -y install rpmorphan

```

列出孤立的软件包。

```sh
[root@testvm1 ~]# rpmorphan
liberation-sans-fonts
liberation-serif-fonts
libertas-usb8388-firmware
libkolab
libsss_autofs
libsss_sudo
libyui-mga-gtk
libyui-mga-qt
libyui-qt-graph
[root@testvm1 ~]#

```

您的孤立包列表将与我的不同。我的测试虚拟机上的一些“孤立”包可能可以删除，但我真的需要额外的字体。我也不能说在没有很好的研究的情况下是否可以安全地删除其他包，但是我确实查看了 libkolab 包，它看起来可以从我的 VM host 上安全地删除。如果已经安装了它，请将其删除，然后重新安装；如果还没有安装，请安装它，这样我们可以看到另一个选项。

```sh
[root@testvm1 ~]# dnf -y remove libkolab ; dnf -y install libkolab

```

让我们使用 rpmorphan 的时间函数来识别最新的包。首先让我们看看一天前安装的孤儿。

```sh
[root@testvm1 ~]# rpmorphan -install-time +1
liberation-sans-fonts
liberation-serif-fonts
libertas-usb8388-firmware
libsss_autofs
libsss_sudo
libyui-mga-gtk
libyui-mga-qt
libyui-qt-graph

```

注意 libkolab 不在这个列表中。现在找到不到一天前安装的孤儿。

```sh
[root@testvm1 ~]# rpmorphan -install-time -1
libkolab

```

我们看到的唯一孤儿是 libkolab。如果在过去的一天里安装了其他软件包，它们也会被发现并被删除。

rpmorphan 工具有许多有趣的选项，使我们能够做一些事情，比如定位那些超过某个日期的孤立包。它还可以查找比特定日期更新的包。后一个选项允许我们删除为了测试而添加的包。

阅读手册页，了解更多关于一些有趣选项的信息。您会看到它也有一个 GUI 选项，但我更喜欢命令行界面。这个程序说明了许多程序员喜欢遵循的一个重要考虑。它确实与埃里克·雷蒙德的分离法则有关。 <sup>[6](#Fn6)</sup> 在这种情况下，程序员将程序的逻辑和功能方面从用户界面中分离出来。这种逻辑与用户界面的分离允许他们创建一个命令行界面和两个图形界面，一个基于 tk，另一个基于 curses。

### 小心！

不要乱拆孤儿包。这可能会导致删除所需的包。他们是孤儿并不意味着不需要他们。删除孤立包时要谨慎。rpmorphan 工具只允许我们识别应该进一步调查的包，以便我们可以确定删除它们是否真正安全。

`deborphan`工具可以用于 Debian 发行版。事实上，rpmorphan 是基于 deborphan。rpmorphan 工具仅定位孤立项，而不会删除它们。如果您决定删除任何孤立包，您可以使用包管理器，如 yum 或 dnf。

这些工具无法发现我们希望从系统中删除的所有软件包。找到孤儿是一回事，但是许多没有显示为孤儿的包也可能被删除。例如，我在本章前面提到的 Calligra office 套件不会显示为孤儿，LibreOffice 或许多其他用户级应用也不会。有时删除这些大程序可以恢复大部分磁盘空间。

您可以使用桌面的应用启动器来定位您从不使用的用户级包。这也可以帮助你找到一些你从来不使用的 GUI 管理工具。

### 小心！

不要试图使用软件包管理器的-y 选项删除软件包。这可能会导致删除许多您不想删除的包。当您的软件包管理器显示如果您回复“y”它将删除的软件包列表时，请务必仔细检查该列表。检查列表后，您可以选择“y”或“n”。这样安全多了。

如果您决定删除找到的软件包，请注意不要删除其他需要的软件。我总是使用不带-y 选项的 package removal 命令，该命令会不停地删除所有依赖于我要删除的包的包，以及我要删除的包所依赖的包。请务必检查您的软件包管理员准备删除的软件包列表，如果有您认为不应该删除的软件包，请回答“否”。

我曾经试图移除一个我认为不需要的包。作为依赖项被删除的软件包有数百个，它们会把 KDE 桌面从我的系统中完全删除。那绝对不是我想做的。

### 脚本中的旧代码

在脚本中寻找 cruft 代码也是系统管理员至少应该偶尔承担的任务。清除未使用的代码和定位语法错误可能具有挑战性，但是有一些工具可以帮助我们。

`shellcheck`实用程序就像 C 和其他语言的 lint <sup>[7](#Fn7)</sup> 。它扫描为 bash 和 bash 类 shells、sh、dash 和 ksh 编写的脚本，寻找可以改进的语法和语法。一如既往，你可以选择是否做出建议的改变。

让我们看看这个工具是如何工作的。

### 实验 17-2

让我们从安装 ShellCheck 包开始——是的，用所示的大写字母。

```sh
[root@testvm1 student]# dnf -y install ShellCheck

```

现在让我们使用 shellcheck 检查 shell 脚本模板。

```sh
[student@testvm1 ~]$ shellcheck script.template.sh | less

```

我收到了许多类似这样的 SC2086 错误。

```sh
In script.template.sh line 92:
   if [ $verbose = 1 ]
        ^-- SC2086: Double quote to prevent globbing and word splitting.

```

shellcheck 实用工具有点过分热心于让我们在变量周围加上双引号。有一些边缘情况 <sup>[8](#Fn8)</sup> 时，这可能是一个问题，但我自己从来没有遇到过。因此，在检查以确保我们没有这些边缘情况之一后，我们可以在下一个命令中排除这些错误。

```sh
[student@testvm1 ~]$ shellcheck --exclude SC2086 script.template.sh

In script.template.sh line 152:
RC=0
^-- SC2034: RC appears unused. Verify it or export it.

In script.template.sh line 153:
Test=0
^-- SC2034: Test appears unused. Verify it or export it.

In script.template.sh line 160:
if [ `id -u` != 0 ]
     ^-- SC2046: Quote this to prevent word splitting.
     ^-- SC2006: Use $(..) instead of legacy `..`.

```

现在更容易看到一些可以从代码中删除的未使用的变量。我们还看到了一些关于 if 语句的语法建议。

现在您可以看到 shellcheck 突出显示的几个问题。使用此信息进行您想要的任何更改。

除了`shellcheck`所能告诉你的关于语法、孤儿变量和其他事情之外，有时你只需要浏览代码。例如，`shellcheck`没有发现的一种 cruft 是多余的过程，这些过程不会在脚本中的任何地方被调用。如果不需要，也可以删除。

您是否在脚本模板中看到了一个未使用的过程？有一个`SelectPkgMgr()`没有在模板中使用，并且`shellcheck`没有发现它是多余的。

### 旧文件

有时旧软件不再需要时就会被删除。在许多情况下，软件包删除过程会留下它们的用户级配置文件。这些通常是我们在主目录中找到的隐藏的“点”文件。

这些遗留下来的配置文件的好处是，如果软件包被重新安装，我们将不会丢失我们的个人配置。糟糕的是，经过很长一段时间，这些文件会大量积累。

例如，我最近删除的 Calligra 的个人配置文件仍然位于我的主目录中。

旧的数据文件也留在我们的硬盘上，它们可能已经没有任何用处了。这通常是因为我们很少花时间评估我们拥有的所有文件，以确定它们是否可以删除、归档或保留。找到旧文件的一个简单方法是使用`find`命令来确定文件被访问的最后时间。

### 实验 17-3

首先，让我们创建几个旧文件。我们用触摸命令来做。如果没有参数，touch 会将 atime、mtime 和 ctime 全部设置为当前系统时间。首先让我们使用`stat`命令来查看您在之前的实验中创建的文件之一 file0.txt 的属性。如果您没有这个文件，现在就创建它。

```sh
[student@testvm1 ~]$ stat file0.txt
  File: file0.txt
  Size: 15            Blocks: 8          IO Block: 4096   regular file
Device: fd03h/64771d    Inode: 393236      Links: 1
Access: (0664/-rw-rw-r--) Uid: ( 1001/ student)  Gid: ( 1001/ student)
Context: system_u:object_r:user_home_t:s0
Access: 2018-02-02 15:39:56.415630341 -0500
Modify: 2018-01-27 11:41:36.056367865 -0500
Change: 2018-01-28 12:15:03.176000000 -0500
 Birth: -

```

这显示了文件的当前访问、修改和更改时间(atime、mtime 和 ctime)。它们可能相同，但也可能不同，除非您刚刚创建了该文件。现在不使用任何选项来触摸文件，将这三个属性设置为当前时间。然后再次检查时间。

```sh
[student@testvm1 ~]$ touch file0.txt
[student@testvm1 ~]$ stat file0.txt
  File: file0.txt
  Size: 15            Blocks: 8          IO Block: 4096   regular file
Device: fd03h/64771d    Inode: 393236      Links: 1
Access: (0664/-rw-rw-r--) Uid: ( 1001/ student)  Gid: ( 1001/ student)
Context: system_u:object_r:user_home_t:s0
Access: 2018-02-23 10:28:25.794938943 -0500
Modify: 2018-02-23 10:28:25.794938943 -0500
Change: 2018-02-23 10:28:25.794938943 -0500
 Birth: -
[student@testvm1 ~]$

```

请注意，这三个时间现在完全相同。这里我们使用`touch`来设置 atime——上次访问文件的时间——更早。下面命令中的-a 选项告诉 touch 命令只设置 atime。t 选项使用以下时间戳将日期和时间设置为 2013 年 7 月 15 日 16:45:23。

```sh
[student@testvm1 ~]$ touch -a -t 1307151645.23 file0.txt
[student@testvm1 ~]$ stat file0.txt
  File: file0.txt
  Size: 15            Blocks: 8          IO Block: 4096   regular file
Device: fd03h/64771d    Inode: 393236      Links: 1
Access: (0664/-rw-rw-r--) Uid: ( 1001/ student)  Gid: ( 1001/ student)
Context: system_u:object_r:user_home_t:s0
Access: 2013-07-15 16:45:23.000000000 -0400
Modify: 2018-02-23 10:28:25.794938943 -0500
Change: 2018-02-23 10:48:13.781669926 -0500
 Birth: -

```

请注意，ctime 也已更改。ctime 是最后一次更改文件索引节点，并且是在我们设置 atime 时发生的。

到目前为止，我们所做的只是为实验设置了条件。现在，我们可以使用 find 命令根据 atime 查找旧文件。使用如下所示的 find 命令查找超过两年的文件。find 命令上的 atime 选项使用以天为单位的年龄，实际上是以“现在”开始的 24 小时周期。因此，我们需要使用 365*2 = 730 天作为我们的时间段。我们将 atime 设置为五年前，因此测试文件应该在这个测试中出现。

```sh
[student@testvm1 ~]$ find . -atime +730
./file0.txt

```

file0.txt 文件按预期显示。您还可以显示最近超过 730 天被访问的文件。通过 sort 实用程序传输结果，以便更容易看到 file0.txt 不在列出的列表中。

```sh
[student@testvm1 ~]$ find . -atime -730 | sort
.
./.bash_history
./.bash_logout
./.bash_profile
./.bashrc
./.cache
./.cache/mc
./.cache/mc/Tree
./.config
./.config/mc
./.config/mc/ini
./error.txt
./file1.txt
./file2.txt
./file3.txt
./file4.txt
./file5.txt
./file6.txt
./file7.txt
./file8.txt
./file9.txt
./good.txt
./index.cgi
./.lesshst
./.local
./.local/share
./.local/share/mc
./.local/share/mc/history
./.mozilla
./.mozilla/extensions
./.mozilla/plugins
./mymotd
./perl.index.cgi
./script.template.sh
./test1.html
./test1.txt
./.viminfo

```

`find`命令可以根据大小、权限、名称和其他标准来定位文件。但是，它所能做的只是找到值得进一步研究的文件。这一调查是以任何程度的把握知道应该如何处理找到的文件的唯一途径。这通常意味着调查内容，但有时也可以根据文件名或文件位置来确定处理方式。

使用 find 命令的一个潜在问题是，最近从备份中恢复的文件没有保留它们的属性。这可能会使旧文件看起来比实际更新，并妨碍轻松识别最旧的文件。在这种情况下，再次需要使用基本工具，如`ls`命令或您最喜欢的文件管理器来搜索文件，打开它们检查内容，如果不再需要，就删除它们。

另一个可用于定位可能被归档或删除的文件的标准是大小。有两种方法可以做到这一点。我们可以使用`find`命令或`du`命令。find 命令让我们对结果有了更多的控制，因为我们可以组合参数并做一些有趣的事情，例如查找所有大于 15MB、最后一次访问是在五年多以前，并且属于特定用户的文件。在下一个实验中，我们将首先查看`du`命令，然后查看`find`命令。

### 实验 17-4

以学生用户的身份执行此实验。

我们再次需要做一些设置，以便使这个实验比学生用户的主目录中只有几个小文件的实验更有趣。首先，我们将创建~/Documents 目录(如果它不存在的话),然后我们将向其中添加一些大小不断增加的文件。

```sh
[student@testvm1 ~]$ mkdir Documents

```

下一个命令应该在一行中输入。它会在~/Documents 目录中创建 100 个数据量不断增加的文件。

```sh
[student@testvm1 ~]$ count=0;while [ $count -lt 100000 ]; do count=$((count+1000)); echo $count;dd if=/dev/urandom of=~/Documents/file-$count.txt bs=256 count=$count ;done

```

make ~/记录 PWD 并列出内容。为了简洁起见，我在这里只显示了前 20 个文件。如果你愿意，你可以去掉 head 实用程序，这样你就可以看到它们了。

```sh
[student@testvm1 Documents]$ ls -l | head -20
total 1262600
-rw-rw-r--. 1 student student 25600000 Feb 23 15:32 file-100000.txt
-rw-rw-r--. 1 student student  2560000 Feb 23 15:31 file-10000.txt
-rw-rw-r--. 1 student student   256000 Feb 23 15:31 file-1000.txt
-rw-rw-r--. 1 student student  2816000 Feb 23 15:31 file-11000.txt
-rw-rw-r--. 1 student student  3072000 Feb 23 15:31 file-12000.txt
-rw-rw-r--. 1 student student  3328000 Feb 23 15:31 file-13000.txt
-rw-rw-r--. 1 student student  3584000 Feb 23 15:31 file-14000.txt
-rw-rw-r--. 1 student student  3840000 Feb 23 15:31 file-15000.txt
-rw-rw-r--. 1 student student  4096000 Feb 23 15:31 file-16000.txt
-rw-rw-r--. 1 student student  4352000 Feb 23 15:31 file-17000.txt
-rw-rw-r--. 1 student student  4608000 Feb 23 15:31 file-18000.txt
-rw-rw-r--. 1 student student  4864000 Feb 23 15:31 file-19000.txt
-rw-rw-r--. 1 student student  5120000 Feb 23 15:31 file-20000.txt
-rw-rw-r--. 1 student student   512000 Feb 23 15:31 file-2000.txt
-rw-rw-r--. 1 student student  5376000 Feb 23 15:31 file-21000.txt
-rw-rw-r--. 1 student student  5632000 Feb 23 15:31 file-22000.txt
-rw-rw-r--. 1 student student  5888000 Feb 23 15:31 file-23000.txt
-rw-rw-r--. 1 student student  6144000 Feb 23 15:31 file-24000.txt
-rw-rw-r--. 1 student student  6400000 Feb 23 15:31 file-25000.txt

```

`du -a`命令简单地列出了文件及其大小，以及每个目录中所有文件的累积大小。我们可以使用它轻松快速地找到最大的文件和包含最大数据量的目录。我们通过`sort`实用程序运行结果，得到一个按数字排序的列表，最大的文件和目录在最后。在这种情况下，我只显示列表中的最后 20 项。

```sh
[student@testvm1 ~]$ du . -a | sort -n | tail -20
20752   ./Documents/file-83000.txt
21000   ./Documents/file-84000.txt
21252   ./Documents/file-85000.txt
21500   ./Documents/file-86000.txt
21752   ./Documents/file-87000.txt
22000   ./Documents/file-88000.txt
22252   ./Documents/file-89000.txt
22500   ./Documents/file-90000.txt
22752   ./Documents/file-91000.txt
23000   ./Documents/file-92000.txt
23252   ./Documents/file-93000.txt
23500   ./Documents/file-94000.txt
23752   ./Documents/file-95000.txt
24000   ./Documents/file-96000.txt
24252   ./Documents/file-97000.txt
24500   ./Documents/file-98000.txt
24752   ./Documents/file-99000.txt
25000   ./Documents/file-100000.txt
1262604 ./Documents
1262780 .

```

结果以千字节为单位。请注意，由于目录中包含的文件，这些目录在底部附近排序。使用`du`时，很难将目录与文件分开。

`find`命令可以更具体一点。让我们找到所有大于 20MB 的文件。

```sh
[student@testvm1 ~]$ find . -size +20M
./Documents/file-93000.txt
./Documents/file-94000.txt
./Documents/file-90000.txt
./Documents/file-92000.txt
./Documents/file-89000.txt
./Documents/file-88000.txt
./Documents/file-91000.txt
./Documents/file-98000.txt
./Documents/file-84000.txt
./Documents/file-85000.txt
./Documents/file-83000.txt
./Documents/file-97000.txt
./Documents/file-100000.txt
./Documents/file-96000.txt
./Documents/file-95000.txt
./Documents/file-82000.txt
./Documents/file-87000.txt
./Documents/file-86000.txt
./Documents/file-99000.txt
[student@testvm1 ~]$

```

注意，`find`命令没有列出文件大小。我们可以在`find`命令中添加一些代码来实现这一点。

```sh
[student@testvm1 ~]$ find . -size +20M -exec ls -l {} \;
-rw-rw-r--. 1 student student 23808000 Feb 23 15:32 ./Documents/file-93000.txt
-rw-rw-r--. 1 student student 24064000 Feb 23 15:32 ./Documents/file-94000.txt
-rw-rw-r--. 1 student student 23040000 Feb 23 15:32 ./Documents/file-90000.txt
-rw-rw-r--. 1 student student 23552000 Feb 23 15:32 ./Documents/file-92000.txt
-rw-rw-r--. 1 student student 22784000 Feb 23 15:32 ./Documents/file-89000.txt
-rw-rw-r--. 1 student student 22528000 Feb 23 15:32 ./Documents/file-88000.txt
-rw-rw-r--. 1 student student 23296000 Feb 23 15:32 ./Documents/file-91000.txt
-rw-rw-r--. 1 student student 25088000 Feb 23 15:32 ./Documents/file-98000.txt
-rw-rw-r--. 1 student student 21504000 Feb 23 15:32 ./Documents/file-84000.txt
-rw-rw-r--. 1 student student 21760000 Feb 23 15:32 ./Documents/file-85000.txt
-rw-rw-r--. 1 student student 21248000 Feb 23 15:32 ./Documents/file-83000.txt
-rw-rw-r--. 1 student student 24832000 Feb 23 15:32 ./Documents/file-97000.txt
-rw-rw-r--. 1 student student 25600000 Feb 23 15:32 ./Documents/file-100000.txt
-rw-rw-r--. 1 student student 24576000 Feb 23 15:32 ./Documents/file-96000.txt
-rw-rw-r--. 1 student student 24320000 Feb 23 15:32 ./Documents/file-95000.txt
-rw-rw-r--. 1 student student 20992000 Feb 23 15:32 ./Documents/file-82000.txt
-rw-rw-r--. 1 student student 22272000 Feb 23 15:32 ./Documents/file-87000.txt
-rw-rw-r--. 1 student student 22016000 Feb 23 15:32 ./Documents/file-86000.txt
-rw-rw-r--. 1 student student 25344000 Feb 23 15:32 ./Documents/file-99000.txt
[student@testvm1 ~]$

```

我们现在有了主目录中最大文件的列表。在这种情况下，它们都在~/Documents 目录中。

我们又一次拥有了可以帮助我们识别主目录中最大文件的工具。仍然需要一些判断来决定这些文件中的哪些(如果有的话)可以被删除或存档。

## 最后一句话

要做到本章和我给你指出的参考文献中讨论的每一件事并不总是可能的。如果我们能做到，那就太好了，但在现实生活中，我们不可能总是这样做。我们的脚本永远不会完全摆脱 cruft，它们永远不会达到最高水平的优雅。

这一章的标题应该暗示了这一点。优雅是我们努力追求的目标，但我们可能永远也不会达到这样的巅峰:所有的 cruft 都被删除，所有的代码都尽可能地高效，为我们的代码添加了准确数量的清晰简洁的完美注释，所有的编程规则和建议都被遵循。

由于多种原因，这是不可能的。我最常遇到的两个问题是，PHB 不关心我们，也不允许我们有时间，以及这些指导方针中的一些——至少在某种程度上——是冲突的。

我们确实有一些工具可以帮助定位脚本中的 cruft 和硬盘上的文件。虽然这些工具可能有所帮助，但它们并不完善，只能做这么多。作为系统管理员，在我们的代码和目录中搜索 cruft 真的取决于我们；有时，这意味着手动浏览，看看有什么可以消除。这很费时间，我不喜欢这样做，但确实需要这样做。

使用这些工具在我们的系统上找到我们的主目录(或其他非 root 用户的主目录)中最大和最老的文件，这可能是清理 cruft 的第一步。它给了我们一个起点，让我们可以用最少的努力获得最好的结果。删除最大和最早的文件后，继续寻找较小和较新的文件来删除或移动到归档存储变得不太有效。

<aside class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

印制电路板

  [2](#Fn2_source)

Edwards，Darvin，电子设计， *PCB 设计及其对器件可靠性的影响【T2， [`http://www.electronicdesign.com/boards/pcb-design-and-its-impact-device-reliability`](http://www.electronicdesign.com/boards/pcb-design-and-its-impact-device-reliability)*

  [3](#Fn3_source)

维基百科、*高尔夫码*、 [`https://en.wikipedia.org/wiki/Code_golf`](https://en.wikipedia.org/wiki/Code_golf)

  [4](#Fn4_source)

维基百科，*Unix 哲学*，章节:*埃里克雷蒙的 17 条 Unix 规则*， [`https://en.wikipedia.org/wiki/Unix_philosophy#Eric_Raymond%E2%80%99s_17_Unix_Rules`](https://en.wikipedia.org/wiki/Unix_philosophy#Eric_Raymond%25E2%2580%2599s_17_Unix_Rules)

  [5](#Fn5_source)

雷蒙德，埃里克·s .，*Unix 编程的艺术*， [`http://www.catb.org/~esr/writings/taoup/html/`](http://www.catb.org/%257Eesr/writings/taoup/html/)

  [6](#Fn6_source)

Raymond，Eric S .，*Unix 编程的艺术*，章节*分离的法则*， [`http://www.catb.org/~esr/writings/taoup/html/ch01s06.html#id2877777`](http://www.catb.org/%257Eesr/writings/taoup/html/ch01s06.html#id2877777)

  [7](#Fn7_source)

维基百科、 *Lint* 、 [`https://en.wikipedia.org/wiki/Lint_(software`](https://en.wikipedia.org/wiki/Lint_(software) `)`

  [8](#Fn8_source)

GitHub，shellcheck，*双引号防止 globbing 和 word splitting】， [`https://github.com/koalaman/shellcheck/wiki/SC2086`](https://github.com/koalaman/shellcheck/wiki/SC2086)*

 </aside>**