# 4.转换数据流

本章介绍了使用管道将数据流从一个实用程序连接到另一个使用 STDIO 的实用程序。你将了解到这些程序的功能是以某种方式转换数据。您还将了解如何使用重定向将数据重定向到文件。

我将术语“transform”与这些程序结合使用，因为每个程序的主要任务是按照系统管理员的意图，以特定的方式转换来自 STDIN 的输入数据，并将转换后的数据发送到 STDOUT，以供另一个 transformer 程序使用或重定向到一个文件。

标准术语“过滤器”暗示了一些我不同意的东西。根据定义，过滤器是一种去除某些东西的装置或工具，例如空气过滤器可以去除空气中的污染物，这样汽车的内燃机就不会被这些微粒磨死。在我高中和大学的化学课上，滤纸被用来去除液体中的微粒。我家暖通空调系统中的空气过滤器去除了我不想呼吸的微粒。

虽然它们有时会从流中过滤掉不需要的数据，但我更喜欢“转换器”这个术语，因为这些实用程序做得更多。他们可以向数据流中添加数据，以一些令人惊讶的方式修改数据，对数据进行排序，重新排列每行中的数据，根据数据流的内容执行操作，等等。

随便你用哪个词，但我更喜欢变形金刚。

## 作为原材料的数据流

数据流是核心实用程序和许多其他 CLI 工具执行工作所依赖的原始资料。顾名思义，数据流是使用 STDIO 从一个文件、设备或程序传递到另一个文件、设备或程序的数据流。

可以通过使用管道将转换器插入数据流来操作数据流。SysAdmin 使用每个 transformer 程序对流中的数据执行一些操作，从而以某种方式改变其内容。然后可以在管道末端使用重定向将数据流定向到文件。如前所述，该文件可以是硬盘上的实际数据文件，也可以是设备文件，如驱动器分区、打印机、终端、伪终端或任何其他连接到计算机的设备。

使用这些小而强大的 transformer 程序操纵这些数据流的能力是 Linux 命令行界面的核心。许多核心实用程序都是 transformer 程序，并使用 STDIO。

## 白日梦

管道对于我们在命令行上做令人惊奇的事情至关重要，以至于我认为认识到它们是由道格拉斯·麦克洛伊 <sup>[2](#Fn2)</sup> 在 Unix 早期发明的是很重要的。谢谢道格。普林斯顿大学的网站上有一段对麦克洛伊的采访片段 <sup>[3](#Fn3)</sup> ，其中他讨论了管道的创建和 Unix 哲学的开端。

请注意实验 4-1 中显示的简单命令行程序中管道的使用，该程序一次列出每个登录用户，不管他们有多少个活动登录。

### 实验 4-1

如果您尚未这样做，请打开一个终端会话，以学生用户身份登录，然后以 root 用户身份登录第二个终端会话。

在一行中输入如下所示的命令。

```
[student@testvm1 ~]$ w | tail -n +3 | awk '{print $1}' | sort | uniq
root
student

```

您还可以使用`sort -u`来代替`uniq`转换器，以确保每个登录 ID 只打印一个实例。输入下面的命令试试看。

```
[student@testvm1 ~]$ w | tail -n +3 | awk '{print $1}' | sort -u
root
student

```

这些命令的结果产生两行数据，显示用户 root 和 student 都已登录。它不显示每个用户登录的次数。

实验 4-1 中的两条命令管道产生了相同的结果。在这个实验中，至少还有一种方法可以改变命令管道，同时仍然生成相同的结果。你能找到它吗？有许多方法可以完成同样的任务。没有对错，只是不同而已。在我看来，使用第二种形式既简单又优雅。我们将在第 [17](17.html) 章“追求优雅”和第 [18](18.html) 章“寻找简单”中讨论这些属性。"

管道——由竖线(|)表示——是将这些命令行实用程序连接在一起的语法粘合剂、操作符。管道允许一个命令的标准输出被“管道化”,即从一个命令的标准输出流到下一个命令的标准输入。

![../images/462716_1_En_4_Chapter/462716_1_En_4_Figa_HTML.png](../images/462716_1_En_4_Chapter/462716_1_En_4_Figa_HTML.png)

用管道连接的一串程序被称为管道，使用 STDIO 的程序被正式称为过滤器，但我更喜欢用转换器这个术语。

想想如果我们不能将数据流从一个命令传输到下一个命令，这个程序将如何工作。第一个命令将对数据执行任务，然后该命令的输出必须保存在一个文件中。下一个命令必须从中间文件中读取数据流，并对数据流进行修改，将自己的输出发送到一个新的临时数据文件中。第三个命令将不得不从第二个临时数据文件中取出它的数据，并执行它自己的数据流操作，然后将得到的数据流存储在另一个临时文件中。在每一步，数据文件名必须以某种方式从一个命令传递到下一个命令。

我甚至无法忍受去想它，因为它太复杂了。记住简单就是摇滚！

## 建设管道

当我做一些新的事情，解决一个新的问题时，我通常不会像实验 4-1 那样，从头开始输入一个完整的 bash 命令管道。我通常从管道中的一两个命令开始，然后通过添加更多命令来进一步处理数据流。这允许我在管道中的每个命令之后查看数据流的状态，并在需要时进行纠正。

在实验 4-2 中，你应该输入每行显示的命令，并按所示运行它以查看结果。这将让你感受到如何分阶段构建复杂的管道。

### 实验 4-2

输入每行显示的命令。当使用管道将每个新的 transformer 实用程序添加到数据流中时，观察数据流中的变化。第一次通过时，使用`uniq`工具。这个实验的最终结果将与实验 4-1 的结果相同。

```
[student@f26vm ~]$ w

[student@f26vm ~]$ w | tail -n +3

[student@f26vm ~]$ w | tail -n +3 | awk '{print $1}'

[student@f26vm ~]$ w | tail -n +3 | awk '{print $1}' | sort

[student@f26vm ~]$ w | tail -n +3 | awk '{print $1}' | sort | uniq
Now let’s also use the alternate form of this last command.

[student@f26vm ~]$ w | tail -n +3 | awk '{print $1}' | sort -n

```

这个实验的结果说明了由管道中的每个 transformer 实用程序执行的对数据流的改变。

可以构建非常复杂的管道，使用许多与 STDIO 一起工作的不同实用程序来转换数据流。

## 重寄

重定向是将程序的标准输出数据流重定向到一个文件而不是显示的默认目标的能力。“大于号”(>)字符，也称为“gt”，是重定向的语法符号。实验 4-3 展示了如何将`df -h`命令的输出数据流重定向到文件 diskusage.txt。

### 实验 4-3

重定向命令的 STDOUT 可用于创建包含该命令结果的文件。

```
[student@f26vm ~]$ df -h > diskusage.txt

```

除非出现错误，否则该命令不会向终端输出任何内容。这是因为 STDOUT 数据流被重定向到文件，而 STDERR 仍然被定向到 STDOUT 设备，即显示器。您可以使用下面的命令查看刚刚创建的文件的内容。

```
[student@f26vm ~]$ cat diskusage.txt
Filesystem                     Size  Used Avail Use% Mounted on
devtmpfs                       2.0G     0  2.0G   0% /dev
tmpfs                          2.0G     0  2.0G   0% /dev/shm
tmpfs                          2.0G  988K  2.0G   1% /run
tmpfs                          2.0G     0  2.0G   0% /sys/fs/cgroup
/dev/mapper/fedora_f26vm-root   49G   11G   36G  24% /
tmpfs                          2.0G     0  2.0G   0% /tmp
/dev/sda1                      976M  158M  752M  18% /boot
/dev/mapper/fedora_f26vm-home   25G   45M   24G   1% /home
tmpfs                          396M     0  396M   0% /run/user/991
tmpfs                          396M     0  396M   0% /run/user/1001

```

使用>符号进行重定向时，如果指定的文件尚不存在，则会创建该文件。如果它已经存在，内容将被来自命令的数据流覆盖。如实验 4-4 所示，你可以使用双大于号>>，将新的数据流附加到文件中任何现有的内容上。

### 实验 4-4

该命令将新数据流追加到现有文件的末尾。

```
[student@f26vm ~]$ df -h >> diskusage.txt

```

您可以使用 cat 和/或更低版本查看 diskusage.txt 文件，以验证新数据是否已附加到文件末尾。

使用重定向到标准输入的一个例子是使用`od`命令，如实验 4-5 所示。N 50 选项防止输出永远持续下去。如果不使用-N 选项来限制输出数据流，可以使用 Ctrl-C 来终止它。

### 实验 4-5

这个实验演示了使用重定向作为 STDIN 的输入。

```
[student@f26vm ~]$ od -c -N 50 < /dev/urandom  
0000000 331 203   _ 307   ]   { 335 337   6 257 347       $   J   Z   U
0000020 245  \0   `  \b   8 307 261 207   K   :   }   S   \ 276 344   ;
0000040 336 256 221 317 314 241 352   ` 253 333 367 003 374 264 335   4
0000060   U  \n 347   (   h 263 354 251   u   H   ] 315 376   W 205  \0
0000100 323 263 024   % 355 003 214 354 343   \   a 254   #   `   {   _
0000120   b 201 222   2 265   [ 372 215 334 253 273 250   L   c 241 233
<snip>

```

本实验中的字体大小已经减小，因此无需换行即可适应。理解结果的本质要容易得多。

重定向可以是管道的来源，也可以是管道的终点。因为很少需要它作为输入，重定向通常被用作管道的终止。

### 重定向标准错误

STDERR 被设计为打印在 STDERR 设备上——通常是与 STDOUT 相同的终端会话——以确保错误消息被显示出来，并且可以被系统管理员查看，而不是通过管道传递并可能丢失。即使 STDOUT 被重定向或通过管道传送到管道的下一级，STDERR 通常也会显示在终端上。

实验 4-6 说明了 STDERR 数据流的默认行为，然后继续展示如何创建替代行为。

### 实验 4-6

让我们通过在您的主目录中创建一些测试文件来开始这个实验。在一行中输入以下命令。

```
[student@testvm1 ~]$ for I in 0 1 2 3 4 5 6 7 8 9;do echo "This is file $I" > file$I.txt;done

```

现在使用 cat 命令连接其中三个文件的内容。在这一点上，我们仍然不期望任何错误，只是设置阶段。

```
[student@testvm1 ~]$ cat file0.txt file4.txt file7.txt > test1.txt
[student@testvm1 ~]$ cat test1.txt
This is file 0
This is file 4
This is file 7

```

到目前为止，一切正常。现在让我们更改命令，通过指定一个不存在的文件来生成一个简单的错误。我们指定了不存在的 filex.txt，而不是 file4.txt。

```
[student@testvm1 ~]$ cat file0.txt filex.txt file7.txt > test1.txt
cat: filex.txt: No such file or directory
[student@testvm1 ~]$ cat test1.txt
This is file 0
This is file 7

```

当数据仍然被重定向到 test1.txt 时，cat 命令生成的错误消息出现在终端上。

```
[student@testvm1 ~]$ cat file0.txt filex.txt file7.txt &> test1.txt
[student@testvm1 ~]$ cat test1.txt
This is file 0
cat: filex.txt: No such file or directory
This is file 7

```

在上面的命令中，STDOUT 和 STDERR 都被重定向到文件 test1.txt。现在让我们假设我们希望 STDOUT 继续被发送到终端，而我们并不关心错误消息。为此，我们将 STDERR 重定向到/dev/null。 <sup>[4](#Fn4)</sup> 首先我们确保 test1.txt 为空，这样就不会有任何数据存储在其中而混淆结果。

```
[student@testvm1 ~]$ echo "" > test1.txt
[student@testvm1 ~]$ cat test1.txt

[student@testvm1 ~]$ cat file0.txt filex.txt file7.txt 2> 
/dev

/
null

This is file 0
This is file 7
[student@testvm1 ~]$ cat test1.txt

[student@testvm1 ~]$

```

我们还可以将 STDERR 重定向到 test1.txt 文件，同时仍然将 STDOUT 发送到终端。

```
[student@testvm1 ~]$ cat file0.txt filex.txt file7.txt 2> test1.txt
This is file 0
This is file 7
[student@testvm1 ~]$ cat test1.txt
cat: filex.txt: No such file or directory
[student@testvm1 ~]$

```

我们可能还会发现将 STDOUT 重定向到一个文件并将 STDERR 重定向到另一个文件是很有用的。这看起来像下面的命令。

```
[student@testvm1 ~]$ cat file0.txt filex.txt file7.txt 1> good.txt 2> error.txt
[student@testvm1 ~]$ cat good.txt
This is file 0
This is file 7
[student@testvm1 ~]$ cat error.txt
cat: filex.txt: No such file or directory
[student@testvm1 ~]$

```

重定向提供的灵活性使我们有可能以一种非常优雅的方式执行一些令人惊奇的事情。例如，我有一些脚本会输出大量的输出，这使得很难确定是否发生了任何错误。通过将 STDOUT 重定向到一个日志文件，将 STDERR 重定向到另一个日志文件，我可以很容易地确定是否有任何错误，而不必搜索将近一兆字节的数据。

## 管道挑战

我为 Opensource.com<sup>[5](#Fn5)</sup>写了很多东西，几年前我向我们的读者提出了一个挑战，其中涉及到管道作为解决方案的必要组件。这是一个简单的问题，有一个我经常使用的解决方案。

### 问题

我有多台计算机配置为向我自己的电子邮件帐户发送管理电子邮件。我已经在我的邮件服务器上配置了 procmail，将这些管理邮件中的大部分移到一个文件夹中，这样就可以很容易地找到它们。在过去的几年里，我在那个文件夹里收集了超过 50，000 封电子邮件。这些电子邮件包括来自 rkhunter (Rootkit hunter)、logwatch、cron jobs 和 Fail2Ban 等的输出。

我感兴趣的消息来自 Fail2Ban，这是一个免费的开源软件，可以动态禁止试图恶意访问我自己主机的主机的 IP 地址，主要是互联网上的防火墙。Fail2Ban 通过向 IPTables 添加规则来做到这一点。每当一个 IP 地址因多次 SSH 登录尝试失败而被禁止时，Fail2Ban 就会发送一封电子邮件。

挑战的目标是创建一个命令行程序来计算来自每个 IP 地址的试图使用 SSH 访问我的主机的电子邮件数量。参赛者将下载 admin.index 文件，其中包含从我的电子邮件客户端导出的 CSV 数据，以及从电子邮件中提取的超过 50，000 个主题行。所有的主题行都包含在参赛者可用的数据中，因此部分任务是只提取与禁止的 SSH 连接相关的主题行。图 [4-1](#Fig1) 中显示了参赛者可用数据的一个小样本。请注意，图中有一些线条被包裹起来，但你明白了。

![../images/462716_1_En_4_Chapter/462716_1_En_4_Fig1_HTML.png](../images/462716_1_En_4_Chapter/462716_1_En_4_Fig1_HTML.png)

图 4-1

挑战中使用的 CSV 数据示例

规则规定命令行程序应该只有一行，并且必须使用管道将数据从一个命令传送到下一个命令。对于额外的学分，结果可以包括每个 IP 地址的国家的名称。

### 解决方案

我们收到了居住在世界各地许多国家的 Opensource.com 读者的来信。有些人提交了多个解决方案，但竞赛规则规定，只有参赛者的第一个解决方案将被考虑。因此，一些好的参赛作品不得不被取消资格，因为它们是同一个人的第二次或第三次参赛作品。

我有自己非常简单的解决方案，如图 [4-2](#Fig2) 所示。然而，即使我有资格，也不会是赢家。事实上，许多参赛作品提供了比我自己更好的解决方案。

![../images/462716_1_En_4_Chapter/462716_1_En_4_Fig2_HTML.png](../images/462716_1_En_4_Chapter/462716_1_En_4_Fig2_HTML.png)

图 4-2

我自己解决问题的方法

我自己的解决方案提供了一个按 IP 地址升序排序的列表，其中大多数条目的源数据来自 admin.index 文件。我的解决方案中的最后一种方法并不是赢得比赛的必要条件，但它是我喜欢做的事情，以查看大多数攻击是从哪里发出的。

我的解决方案产生了 5，377 行输出，所以大约有这个数量的唯一 IP 地址。然而，我的解决方案没有考虑到一些没有 IP 地址的异常条目。当我在思考命令行程序在这个挑战中的目标时，我决定不指定应该产生的行数，因为我觉得这可能限制太多，并且会对条目施加不必要的约束。我认为这是一个好主意，因为我们收到的许多条目产生了多少有些不同的数字。所以一个成功的解决方案不需要产生和我的解决方案一样多的数据行。

#### 带解决方案的第一个条目

美国新泽西州汉密尔顿的迈克尔·迪多梅尼科提交了比赛的第一份参赛作品，这也是一份工作。我特别喜欢 Michael 使用 sort 命令来确保输出按照 IP 地址排序。

Michael 的输入，如图 [4-3](#Fig3) 所示，产生 5295 行输出，与我自己的结果相差不大。这也是许多其他条目产生的输出行数。

![../images/462716_1_En_4_Chapter/462716_1_En_4_Fig3_HTML.png](../images/462716_1_En_4_Chapter/462716_1_En_4_Fig3_HTML.png)

图 4-3

Michael DiDomenico 提交了第一个带有正确答案的条目

#### 最短解决方案

有资格获奖的最短解决方案是由西班牙马德里的 Víctor Ochoa Rodríguez 提交的。他在图 [4-4](#Fig4) 中的 65 个字符的解决方案非常优雅，使用 egrep 仅选择包含 SSH 和 IP 地址的行，同时仅打印每行中与表达式匹配的部分。我从这个条目中了解到了-o 选项，所以感谢 Víctor 提供的这一点新知识。

![../images/462716_1_En_4_Chapter/462716_1_En_4_Fig4_HTML.png](../images/462716_1_En_4_Chapter/462716_1_En_4_Fig4_HTML.png)

图 4-4

维克多·奥乔亚·罗德里格斯提交了这个解决方案，这是有资格获奖的最短的一个

图 [4-5](#Fig5) 显示了另一个实际上比 Víctor 更短的条目。Teresa e Junior 提交了一个长度为 58 个字符的条目。她没有资格在竞赛中获奖，但她的解决方案至少应该在这个类别中得到非正式的认可。

![../images/462716_1_En_4_Chapter/462716_1_En_4_Fig5_HTML.png](../images/462716_1_En_4_Chapter/462716_1_En_4_Fig5_HTML.png)

图 4-5

小特雷莎·e·提交的这份文件是所有文件中最短的

这两种解决方案都会产生 5，295 行输出。

#### 最有创意的解决方案

前两个类别可以根据纯粹的客观标准来判断，所以我希望有这个类别来提供一个额外的机会，以表彰那些提出更有创意的答案的人。这一类别的结果是基于我的纯主观意见，在我看来，这一类别有一个平局。

爱尔兰科克公司的 Przemo Firszt 提交了图 [4-6](#Fig6) 中的参赛作品，该作品因其对 tee 和 xargs 命令的使用而非常有趣且富有创意。它的独特之处还在于，除了使用管道之外，它还使用 tee 命令将中间数据存储在一个文件中，该命令还将数据传递给 STDOUT，最终输出被重定向到另一个文件，而不是允许输出到 STDOUT。它甚至在最后通过删除临时文件来进行清理。

![../images/462716_1_En_4_Chapter/462716_1_En_4_Fig6_HTML.png](../images/462716_1_En_4_Chapter/462716_1_En_4_Fig6_HTML.png)

图 4-6

Przemo Firszt 提交了这个使用 tee 和 xargs 的创意作品

这个解决方案产生 7，403 行输出。这似乎是因为许多 IP 地址有多行。因此，尽管这不是一个完美的解决方案，但只需很少的修改就可以为每个 IP 地址生成一行输出。

美国德克萨斯州弗里斯科的蒂姆·蔡斯。，是这个类别的另一个赢家。Tim 的条目如图 [4-7](#Fig7) 所示，其独特之处在于它使用 curl 命令从服务器下载文件，然后它使用 awk 命令选择文件中所需的行，并仅从每一行中选择 IP 地址。Tim 的解决方案是唯一包含执行文件下载的代码的解决方案。它产生 5，295 行输出。

![../images/462716_1_En_4_Chapter/462716_1_En_4_Fig7_HTML.png](../images/462716_1_En_4_Chapter/462716_1_En_4_Fig7_HTML.png)

图 4-7

Tim Chase 的解决方案在使用 curl 下载文件方面很有创意

#### 额外积分解决方案

许多条目旨在满足额外积分解决方案的要求，为每个 IP 地址提供国家名称。我找到了两个特别引起我兴趣的条目。这两个条目都使用 GeoIP 包提供本地数据库来获取国家信息。其他几个条目使用了`whois`命令，但是除了其他问题之外，`whois`使用了远程数据库，当从单个 IP 地址访问太快时，就会被阻塞。GeoIP 包在标准 Fedora 存储库和 EPEL CentOS 存储库中提供。

来自阿根廷的 Gustavo Yzaguirre 提交了图 [4-8](#Fig8) 中的条目，我喜欢它，因为它首先给出了一个带有计数的 IP 地址的基本列表，然后列出了国家。它产生 16，419 行输出，其中许多是重复的。Gustavo 说它没有优化，但这不是要求之一。

![../images/462716_1_En_4_Chapter/462716_1_En_4_Fig8_HTML.png](../images/462716_1_En_4_Chapter/462716_1_En_4_Fig8_HTML.png)

图 4-8

Gustavo Yzaguirre 提交了这个条目，列出了每个 IP 地址的国家名称

塞尔维亚贝尔格莱德的 Dejan Bogdanovic 也提交了一个非常有趣的额外积分解决方案。他在图 [4-9](#Fig9) 中的条目按频率降序列出了 IP 地址和国家信息。德扬的条目产生 5，764 行输出。

![../images/462716_1_En_4_Chapter/462716_1_En_4_Fig9_HTML.png](../images/462716_1_En_4_Chapter/462716_1_En_4_Fig9_HTML.png)

图 4-9

这个额外学分条目是由德扬·波格丹诺维奇提交的

### 关于解决方案的思考

我很惊讶 Opensource.com 的读者能想出这么多不同的方法来解决这个问题。在某种程度上，我认为这是因为许多参与者对预期结果的解释有点随意，在许多情况下，添加了比原始规范中要求的更多的信息。

在所有的解决方案中也有很多创意。没有两个解决方案是相同的，这强调了每个人解决问题的方式不同的事实。即使有些解决方案看起来是从相同的角度出发的，但每个解决方案都有自己的个性和一点天赋，这只能是多样化、聪明、知识渊博且非常有创造力的系统管理员带来的独特视角的产物。

让我们把这个竞赛作为现实世界的一个隐喻。竞赛规则是这个项目的规范。每个系统管理员，甚至那些没有在竞赛中胜出的系统管理员，都采用了那些规范，并精心制作了满足需求的解决方案，这些解决方案也具有惊人的创造力。每个解决方案都说明了如何使用 transformer 程序和 STDIO 来转换数据流，最终为系统管理员提供有意义的信息。

这场竞赛也很好地说明了“没有应该”没有一种方法可以让你“应该”做任何事情。重要的是结果。你知道，这听起来很好，我应该把它作为信条之一。在我写作的这一点上，我还没有把它当作一个信条，但它确实是，所以我现在就要创造这一章。

## 摘要

对于系统管理员来说，只有使用管道和重定向，Linux 哲学的许多原则才有意义。管道将 STDIO 数据流从一个程序或文件传输到另一个程序或文件。在本章中，您已经了解到通过一个或多个 transformer 程序使用管道传输数据流支持对这些流中的数据进行强大而灵活的操作。

实验中展示的每个项目，以及这里展示的所有参赛项目，都很小，而且每个项目都做得很好。他们也是变形金刚，也就是说。它们接受标准输入，以某种方式进行处理，然后将输出发送到标准输出。将这些程序实现为转换器，将经过处理的数据流从它们自己的标准输出发送到其他程序的标准输入，这是对将管道实现为 Linux 工具的补充，也是必要的。

<aside class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

在 Linux 系统中，所有硬件设备都被视为文件。在第 5 章“一切都是一个文件”中有更多关于这个的内容

  [2](#Fn2_source)

维基百科，道格拉斯·麦克洛伊传， [`http://www.cs.dartmouth.edu/~doug/biography`](http://www.cs.dartmouth.edu/%257Edoug/biography)

  [3](#Fn3_source)

普林斯顿大学，采访道格拉斯·麦克洛伊， [`https://www.princeton.edu/~hos/frs122/precis/mcilroy.htm`](https://www.princeton.edu/%257Ehos/frs122/precis/mcilroy.htm)

  [4](#Fn4_source)

我们将在第 [5](05.html) 章“一切都是文件”中学习更多关于设备特殊文件的知识，比如/dev/null

  [5](#Fn5_source)

[T2`http://opensource.com`](http://opensource.com)

 </aside>