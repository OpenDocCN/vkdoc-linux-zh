第九章

![image](images/frontdot.jpg)

net filter〔t0〕

[第八章](08.html)讨论了 IPv6 子系统的实现。本章讨论 netfilter 子系统。netfilter 框架是由 Rusty Russell 于 1998 年创建的，他是最著名的 Linux 内核开发人员之一，是对旧版本的`ipchains` (Linux 2.2.x)和`ipfwadm` (Linux 2.0.x)的改进。netfilter 子系统提供了一个框架，允许在网络堆栈中数据包遍历的各个点(netfilter 挂钩)注册回调，并对数据包执行各种操作，如更改地址或端口、丢弃数据包、记录日志等。这些 netfilter 钩子 为注册回调的 netfilter 内核模块提供基础设施，以便执行 netfilter 子系统的各种任务。

Netfilter 框架

netfilter 子系统提供本章中讨论的以下功能:

*   数据包选择(iptables)
*   包过滤
*   网络地址转换(NAT)
*   数据包篡改(在路由之前或之后修改数据包报头的内容)
*   连接跟踪
*   收集网络统计数据

以下是一些基于 Linux 内核 netfilter 子系统的常见框架:

*   **IPVS (IP 虚拟服务器):** 一种传输层负载均衡解决方案(`net/netfilter/ipvs`)。很早的内核就支持 IPv4 IPVS，从内核 2.6.28 开始，支持 IPv6 中的 IPVS。对 IPVS 的 IPv6 内核支持是由谷歌的朱利叶斯·沃尔茨和文斯·布萨姆开发的。更多详情见 IPVS 官网，`www.linuxvirtualserver.org`。
*   **IP 集:** 一个框架，由一个叫做`ipset`的用户空间工具和一个内核部分(`net/netfilter/ipset`)组成。IP 集基本上是一组 IP 地址。IP sets 框架是由 Jozsef Kadlecsik 开发的。更多细节请见`http://ipset.netfilter.org`。
*   **iptables:** 大概是最流行的 Linux 防火墙， **iptables** 是 netfilter 的前端，它为 netfilter 提供了一个管理层:比如添加和删除 netfilter 规则，显示统计数据，添加一个表，将一个表的计数器清零等等。

根据协议，内核中有不同的 iptables 实现:

*   【IPv4 的 iptables:(`net/ipv4/netfilter/ip_tables.c`
*   【IPv6 的 IP 6 tables:(`net/ipv6/netfilter/ip6_tables.c`)
*   **ARP 表**用于 ARP: ( `net/ipv4/netfilter/arp_tables.c`)
*   **以太网的数据表**:(`net/bridge/netfilter/ebtables.c`)

在用户空间中，有`iptables`和`ip6tables`命令行工具，分别用于设置、维护和检查 IPv4 和 IPv6 表。参见`man 8 iptables`和`man 8 ip6tables`。`iptables`和`ip6tables`都使用`setsockopt()` / `getsockopt()`系统调用从用户空间与内核通信。我应该在这里提到两个有趣的正在进行的 netfilter 项目。`xtables2`项目——主要由 Jan Engelhardt 开发，在撰写本文时仍在进行中——使用基于 netlink 的接口与内核 netfilter 子系统通信。详见项目网站`http://xtables.de`。第二个项目是`nftables`项目，它是一个新的包过滤引擎，可以替代`iptables`。`nftables`解决方案基于使用一个虚拟机和一个统一的实现，而不是前面提到的四个`iptables`对象(`iptables`、`ip6tables`、`arptables`和`ebtables`)。Patrick McHardy 在 2008 年的 netfilter 研讨会上首次提出了`nftables`项目。内核基础设施和用户空间实用程序是由 Patrick McHardy 和 Pablo Neira Ayuso 开发的。更多详细信息，请参见`http://netfilter.org/projects/nftables`和`http://lwn.net/Articles/324989/`的“Nftables:一个新的包过滤引擎”。

有许多 netfilter 模块扩展了核心 netfilter 子系统的核心功能；除了一些例子，我不在这里深入描述这些模块。从管理的角度来看，网上和各种管理指南中有许多关于这些 netfilter 扩展的信息资源。另见 netfilter 项目官方网站:`www.netfilter.org`。

Netfilter 挂钩

网络堆栈中有五个点有 netfilter 挂钩:在前面章节讨论 IPv4 和 IPv6 中的 Rx 和 Tx 路径时，您会遇到这些点。请注意，挂钩的名称对于 IPv4 和 IPv6 是通用的:

*   NF_INET_PRE_ROUTING: 这个钩子在 IPv4 的`ip_rcv()`方法中，在 IPv6 的`ipv6_rcv()`方法中。`ip_rcv()`方法是 IPv4 的协议处理器，`ipv6_rcv()`方法是 IPv6 的协议处理器。在路由子系统中执行查找之前，它是所有传入数据包到达的第一个挂钩点。
*   NF_INET_LOCAL_IN: 这个钩子在 IPv4 的`ip_local_deliver()`方法中，在 IPv6 的`ip6_input()`方法中。寻址到本地主机的所有传入分组在第一次通过 NF_INET_PRE_ROUTING 钩点之后以及在路由子系统中执行查找之后到达该钩点。
*   NF_INET_FORWARD: 这个钩子在 IPv4 的`ip_forward()`方法中，在 IPv6 的`ip6_forward()`方法中。所有转发的数据包在第一次通过 NF_INET_PRE_ROUTING 挂钩点并在路由子系统中执行查找后到达该挂钩点。
*   NF_INET_POST_ROUTING: 这个钩子在 IPv4 的`ip_output()`方法中，在 IPv6 的`ip6_finish_output2()`方法中。转发的数据包在通过 NF_INET_FORWARD 钩子点后到达这个钩子点。同样，在本地机器中创建并发送出去的数据包在通过 NF_INET_LOCAL_OUT 钩子点之后到达 NF_INET_POST_ROUTING。
*   NF_INET_LOCAL_OUT: 这个钩子在 IPv4 的`__ip_local_out()`方法中，在 IPv6 的`__ip6_local_out()`方法中。在本地主机上创建的所有传出数据包在到达 NF_INET_POST_ROUTING 挂钩点之前到达该点。

```
(include/uapi/linux/netfilter.h)
```

前几章提到的 NF_HOOK 宏在内核网络栈中数据包遍历的一些不同点被调用；它在`include/linux/netfilter.h`中定义:

```
static inline int NF_HOOK(uint8_t pf, unsigned int hook, struct sk_buff *skb,
                  struct net_device *in, struct net_device *out,
                  int (*okfn)(struct sk_buff *))
{
    return NF_HOOK_THRESH(pf, hook, skb, in, out, okfn, INT_MIN);
}
```

NF_HOOK()的参数如下:

*   `pf`:协议族。IPV4 的 NFPROTO_IPV4 和 IPV6 的 NFPROTO_IPV6。
*   `hook`:前面提到的五个 netfilter 钩子之一(比如 NF_INET_PRE_ROUTING 或者 NF_INET_LOCAL_OUT)。
*   `skb`:SKB 对象代表正在处理的数据包。
*   `in`:输入网络设备(`net_device`对象)。
*   `out`:输出网络设备(`net_device`对象)。存在输出设备为空的情况，因为它还是未知的；比如在`ip_rcv()`方法中，`net/ipv4/ip_input.c`，在执行路由查找之前调用，你还不知道哪个是输出设备；NF_HOOK()宏在这个方法中用一个空输出设备调用。
*   一个指向延续函数的指针，当钩子终止时，这个函数将被调用。它有一个参数，SKB。

netfilter 挂钩的返回值必须是下列值之一(也称为 *netfilter 判断*):

*   NF_DROP (0):无声地丢弃数据包。
*   NF_ACCEPT (1):包照常继续在内核网络堆栈中遍历。
*   NF _ stocked(2):不继续遍历。该数据包由钩子方法处理。
*   NF_QUEUE (3):将数据包排入用户空间的队列。
*   NF_REPEAT (4):应该再次调用钩子函数。

```
(include/uapi/linux/netfilter.h)
```

现在您已经了解了各种 netfilter 挂钩，下一节将介绍如何注册 netfilter 挂钩。

Netfilter 挂钩的注册

要在前面提到的五个挂钩点之一注册一个挂钩回调，首先要定义一个`nf_hook_ops`对象(或者一个`nf_hook_ops`对象的数组)，然后注册它；`nf_hook_ops`结构在`include/linux/netfilter.h`中定义:

```
struct nf_hook_ops {
    struct list_head list;

    /* User fills in from here down. */
    nf_hookfn     *hook;
    struct module *owner;
    u_int8_t      pf;
    unsigned int  hooknum;
    /* Hooks are ordered in ascending priority. */
    int           priority;
};
```

下面介绍一些`nf_hook_ops`结构的重要成员:

*   `hook`:你要注册的钩子回调。它的原型是:

    ```
    unsigned int nf_hookfn(unsigned int hooknum,
                           struct sk_buff *skb,
                           const struct net_device *in,
                           const struct net_device *out,
                           int (*okfn)(struct sk_buff *));

    ```

*   `pf`:协议族(IPV4 为 NFPROTO_IPV4，IPV6 为 NFPROTO_IPV6)。
*   `hooknum`:前面提到的五个 netfilter 钩子之一。
*   `priority`:同一个挂钩上可以注册多个挂钩回叫。首先调用优先级较低的钩子回调。`nf_ip_hook_priorities enum`定义了 IPv4 挂钩优先级的可能值(`include/uapi/linux/netfilter_ipv4.h`)。参见本章末尾“快速参考”部分的[表 9-4](#Tab4) 。

注册 netfilter 挂钩有两种方法:

*   `int nf_register_hook(struct nf_hook_ops *reg)`:注册单个`nf_hook_ops`对象。
*   `int nf_register_hooks(struct nf_hook_ops *reg, unsigned int n)`:注册一个由 *n 个*T1】对象组成的数组；第二个参数是数组中元素的数量。

在接下来的两节中，您将看到两个注册一个`nf_hook_ops`对象数组的例子。下一节的图 9-1 说明了在同一个钩子点注册多个钩子回调时优先级的使用。

连接跟踪

在现代网络中，仅根据 L4 和 L3 报头过滤流量是不够的。您还应该考虑流量基于会话的情况，例如 FTP 会话或 SIP 会话。对于 FTP 会话，我指的是这一系列事件，例如:客户端首先在 TCP 端口 21 上创建一个 TCP 控制连接，这是默认的 FTP 端口。从 FTP 客户端发送到服务器的命令(例如列出目录的内容)在此控制端口上发送。FTP 服务器在端口 20 上打开一个数据套接字，其中客户端的目的端口是动态分配的。应该根据其他参数(如连接状态或超时)过滤流量。这是使用连接跟踪层的主要原因之一。

连接跟踪允许内核跟踪会话。连接跟踪层的主要目标是作为 NAT 的基础。如果未设置 CONFIG_NF_CONNTRACK_IPV4，则无法构建 IPv4 NAT 模块 ( `net/ipv4/netfilter/iptable_nat.c`)。同样，如果没有设置 CONFIG_NF_CONNTRACK_IPV6，则不能构建 IPv6 NAT 模块(`net/ipv6/netfilter/ip6table_nat.c`)。但是，连接跟踪不依赖于 NAT 您可以在不激活任何 NAT 规则的情况下运行连接跟踪模块。本章稍后将讨论 IPv4 和 IPv6 NAT 模块。

![image](images/sq.jpg) **注意**本章末尾的“快速参考”部分提到了一些用于连接跟踪管理的用户空间工具(`conntrack-tools`)。这些工具可以帮助您更好地理解连接跟踪层。

连接跟踪初始化

称为`ipv4_conntrack_ops`的`nf_hook_ops`对象数组定义如下:

```
static struct nf_hook_ops ipv4_conntrack_ops[] __read_mostly = {
        {
                .hook           = ipv4_conntrack_in,
                .owner          = THIS_MODULE,
                .pf             = NFPROTO_IPV4,
                .hooknum        = NF_INET_PRE_ROUTING,
                .priority       = NF_IP_PRI_CONNTRACK,
        },
        {
                .hook           = ipv4_conntrack_local,
                .owner          = THIS_MODULE,
                .pf             = NFPROTO_IPV4,
                .hooknum        = NF_INET_LOCAL_OUT,
                .priority       = NF_IP_PRI_CONNTRACK,
        },
        {
                .hook           = ipv4_helper,
                .owner          = THIS_MODULE,
                .pf             = NFPROTO_IPV4,
                .hooknum        = NF_INET_POST_ROUTING,
                .priority       = NF_IP_PRI_CONNTRACK_HELPER,
        },
        {
                .hook           = ipv4_confirm,
                .owner          = THIS_MODULE,
                .pf             = NFPROTO_IPV4,
                .hooknum        = NF_INET_POST_ROUTING,
                .priority       = NF_IP_PRI_CONNTRACK_CONFIRM,
        },
        {
                .hook           = ipv4_helper,
                .owner          = THIS_MODULE,
                .pf             = NFPROTO_IPV4,
                .hooknum        = NF_INET_LOCAL_IN,
                .priority       = NF_IP_PRI_CONNTRACK_HELPER,
        },
        {
                .hook           = ipv4_confirm,
                .owner          = THIS_MODULE,
                .pf             = NFPROTO_IPV4,
                .hooknum        = NF_INET_LOCAL_IN,
                .priority       = NF_IP_PRI_CONNTRACK_CONFIRM,
        },
};
(net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c)
```

您注册的两个最重要的连接跟踪挂钩是由`ipv4_conntrack_in()`方法处理的 NF_INET_PRE_ROUTING 挂钩和由`ipv4_conntrack_local()`方法处理的 NF_INET_LOCAL_OUT 挂钩。这两个钩子的优先级是 NF_IP_PRI_CONNTRACK (-200)。`ipv4_conntrack_ops`数组中的其他钩子具有 NF_IP_PRI_CONNTRACK_HELPER (300)优先级和 nf _ IP _ pri _ conntrack _ confirm(int _ max，2^31-1)优先级。在 netfilter 挂钩中，首先执行具有较低优先级值的回调。(`include/uapi/linux/netfilter_ipv4.h`中的`enum nf_ip_hook_priorities`代表 IPv4 挂钩可能的优先级值)。`ipv4_conntrack_local()`方法和`ipv4_conntrack_in()`方法都调用`nf_conntrack_in()`方法，将相应的`hooknum`作为参数传递。`nf_conntrack_in()` 方法属于与协议无关的 NAT 核心，既用于 IPv4 连接跟踪，也用于 IPv6 连接跟踪；它的第二个参数是协议族，指定它是 IPv4 (PF_INET)还是 IPv6 (PF_INET6)。我从`nf_conntrack_in()`回调开始讨论。其他钩子回调函数`ipv4_confirm()`和`ipv4_help()`将在本节稍后讨论。

![image](images/sq.jpg) **注意**当内核构建了连接跟踪支持(CONFIG_NF_CONNTRACK 已设置)时，即使没有激活 iptables 规则，也会调用连接跟踪钩子回调。自然，这需要一些性能成本。如果性能非常重要，并且您事先知道设备不会使用 netfilter 子系统，那么可以考虑构建没有连接跟踪支持的内核，或者将连接跟踪构建为内核模块而不加载它。

IPv4 连接跟踪钩子的注册是通过调用`nf_conntrack_l3proto_ipv4_init()`方法(`net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c`)中的`nf_register_hooks()`方法来完成的:

```
in nf_conntrack_l3proto_ipv4_init(void) {
       . . .
       ret = nf_register_hooks(ipv4_conntrack_ops,
                                 ARRAY_SIZE(ipv4_conntrack_ops))
       . . .
}
```

在[图 9-1](#Fig1) 中，可以看到连接跟踪回调 ( `ipv4_conntrack_in()`、`ipv4_conntrack_local()`、`ipv4_helper()`、`ipv4_confirm()`)，根据它们注册的钩子点。

![9781430261964_Fig09-01.jpg](images/9781430261964_Fig09-01.jpg)

[图 9-1](#_Fig1) 。连接跟踪挂钩(IPv4)

![image](images/sq.jpg) **注**为了简单起见，[图 9-1](#Fig1) 没有包括更复杂的场景，比如使用 IPsec 或者分片或者组播的时候。为了简单起见，它还省略了在本地主机上生成并发送出去的数据包所调用的函数(如`ip_queue_xmit()`方法或`ip_build_and_send_pkt()`方法)。

连接跟踪的基本元素是`nf_conntrack_tuple`结构:

```
struct nf_conntrack_tuple {
        struct nf_conntrack_man src;

        /* These are the parts of the tuple which are fixed. */
        struct {
                union nf_inet_addr u3;
                union {
                        /* Add other protocols here. */
                        __be16 all;

                        struct {
                                __be16 port;
                        } tcp;
                        struct {
                                __be16 port;
                        } udp;
                        struct {
                                u_int8_t type, code;
                        } icmp;
                        struct {
                                __be16 port;
                        } dccp;
                        struct {
                                __be16 port;
                        } sctp;
                        struct {
                                __be16 key;
                        } gre;
                } u;

                /* The protocol. */
                u_int8_t protonum;

                /* The direction (for tuplehash) */
                u_int8_t dir;
        } dst;
};
(include/net/netfilter/nf_conntrack_tuple.h)
```

`nf_conntrack_tuple`结构表示一个方向的流程。`dst`结构中的联合包括各种协议对象(如 TCP、UDP、ICMP 等等)。对于每个传输层(L4)协议，都有一个连接跟踪模块，它实现协议特定的部分。因此，举例来说，TCP 协议有`net/netfilter/nf_conntrack_proto_tcp.c`，UDP 协议有`net/netfilter/nf_conntrack_proto_udp.c`，FTP 协议有`net/netfilter/nf_conntrack_ftp.c`，等等；这些模块支持 IPv4 和 IPv6。在本节的后面，您将看到连接跟踪模块的特定于协议的实现如何不同的示例。

连接跟踪条目

`nf_conn`结构表示连接跟踪条目:

```
struct nf_conn {
        /* Usage count in here is 1 for hash table/destruct timer, 1 per skb,
           plus 1 for any connection(s) we are `master' for */
        struct nf_conntrack ct_general;

        spinlock_t lock;

        /* XXX should I move this to the tail ? - Y.K */
        /* These are my tuples; original and reply */
        struct nf_conntrack_tuple_hash tuplehash[IP_CT_DIR_MAX];

        /* Have we seen traffic both ways yet? (bitset) */
        unsigned long status;

        /* If we were expected by an expectation, this will be it */
        struct nf_conn *master;

        /* Timer function; drops refcnt when it goes off. */
        struct timer_list timeout;

      . . .

        /* Extensions */
        struct nf_ct_ext *ext;
#ifdef CONFIG_NET_NS
        struct net *ct_net;
#endif

        /* Storage reserved for other modules, must be the last member */
        union nf_conntrack_proto proto;
};
(include/net/netfilter/nf_conntrack.h)
```

以下是对`nf_conn`结构中一些重要成员的描述:

*   `ct_general`:参考计数。
*   `tuplehash`:有两个`tuplehash`对象:`tuplehash[0]`是原方向，`tuplehash[1]`是回复。它们通常分别被称为`tuplehash[IP_CT_DIR_ORIGINAL]`和`tuplehash[IP_CT_DIR_REPLY]`。
*   `status`:条目的状态。当你开始跟踪一个连接条目时，它是 IP _ CT _ NEW 稍后，当连接建立时，它变成 IP_CT_ESTABLISHED。参见`include/uapi/linux/netfilter/nf_conntrack_common.h`中的`ip_conntrack_info enum`。
*   `master`:预期的连接。由`init_conntrack()`方法设置，当一个期望的包到达时(这意味着由`init_conntrack()`方法调用的`nf_ct_find_expectation()`方法找到一个期望)。另请参阅本章后面的“连接跟踪助手和期望”一节。
*   `timeout`:连接条目的定时器。当没有流量时，每个连接条目在一段时间间隔后到期。时间间隔根据协议确定。当用`__nf_conntrack_alloc()`方法分配一个`nf_conn`对象时，超时定时器被设置为`death_by_timeout()`方法。

现在您已经了解了`nf_conn struct`及其一些成员，让我们来看看`nf_conntrack_in()`方法:

```
unsigned int nf_conntrack_in(struct net *net, u_int8_t pf, unsigned int hooknum,
                          struct sk_buff *skb)
{
        struct nf_conn *ct, *tmpl = NULL;
        enum ip_conntrack_info ctinfo;
        struct nf_conntrack_l3proto *l3proto;
        struct nf_conntrack_l4proto *l4proto;
        unsigned int *timeouts;
        unsigned int dataoff;
        u_int8_t protonum;
        int set_reply = 0;
        int ret;

        if (skb->nfct) {
                /* Previously seen (loopback or untracked)?  Ignore. */
                tmpl = (struct nf_conn *)skb->nfct;
                if (!nf_ct_is_template(tmpl)) {
                        NF_CT_STAT_INC_ATOMIC(net, ignore);
                        return NF_ACCEPT;
                }
                skb->nfct = NULL;
        }
```

首先，您尝试确定网络层(L3)协议是否可以被跟踪:

```
        l3proto = __nf_ct_l3proto_find(pf);
```

现在，您尝试确定是否可以跟踪传输层(L4)协议。对于 IPv4，通过`ipv4_get_l4proto()`方法(`net/ipv4/netfilter/nf_conntrack_l3proto_ipv4`)完成:

```
        ret = l3proto->get_l4proto(skb, skb_network_offset(skb),
                           &dataoff, &protonum);
```

```
        if (ret <= 0) {
           . . .
                ret = -ret;
                goto out;
}
```

```
        l4proto = __nf_ct_l4proto_find(pf, protonum);
```

```
        /* It may be an special packet, error, unclean...
```

```
         * inverse of the return code tells to the netfilter
```

```
         * core what to do with the packet. */
```

现在您可以检查特定于协议的错误条件(例如，参见`net/netfilter/nf_conntrack_proto_udp.c`中的`udp_error()`方法，它检查格式错误的数据包、带有无效校验和的数据包等等，或者参见`net/netfilter/nf_conntrack_proto_tcp.c`中的`tcp_error()`方法):

```
        if (l4proto->error != NULL) {
                ret = l4proto->error(net, tmpl, skb, dataoff, &ctinfo,
                                     pf, hooknum);
                if (ret <= 0) {
                        NF_CT_STAT_INC_ATOMIC(net, error);
                        NF_CT_STAT_INC_ATOMIC(net, invalid);
                        ret = -ret;
                        goto out;
                }
                /* ICMP[v6] protocol trackers may assign one conntrack. */
                if (skb->nfct)
                        goto out;
        }
```

此后立即调用的`resolve_normal_ct()`方法执行以下操作:

*   通过调用`hash_conntrack_raw()`方法计算元组的散列。
*   通过调用`__nf_conntrack_find_get()`方法执行元组匹配的查找，将散列作为参数传递。
*   如果没有找到匹配，它通过调用`init_conntrack()`方法创建一个新的`nf_conntrack_tuple_hash`对象。这个`nf_conntrack_tuple_hash`对象被添加到未确认的 tuplehash 对象列表中。该列表嵌入在网络名称空间对象中；`net`结构包含一个`netns_ct`对象，它由网络名称空间特定的连接跟踪信息组成。它的成员之一是`unconfirmed`，是未确认的`tuplehash`对象列表(见`include/net/netns/conntrack.h`)。稍后，在`__nf_conntrack_confirm()`方法中，它将从未确认列表中删除。我将在本节的后面讨论`__nf_conntrack_confirm()`方法。
*   每个 SKB 都有一个名为`nfctinfo`的成员，它代表连接状态(例如，它是新连接的 IP_CT_NEW)，还有一个名为`nfct`(`nf_conntrack struct`的一个实例)的成员，它实际上是一个引用计数器。`resolve_normal_ct()`方法初始化这两者。

    ```
    ct = resolve_normal_ct(net, tmpl, skb, dataoff, pf, protonum,
                           l3proto, l4proto, &set_reply, &ctinfo);
    if (!ct) {
            /* Not valid part of a connection */
            NF_CT_STAT_INC_ATOMIC(net, invalid);
            ret = NF_ACCEPT;
            goto out;
    }
    ```

```
        if (IS_ERR(ct)) {
                /* Too stressed to deal. */
                NF_CT_STAT_INC_ATOMIC(net, drop);
                ret = NF_DROP;
                goto out;
}
```

```
        NF_CT_ASSERT(skb->nfct);
```

您现在调用`nf_ct_timeout_lookup()`方法来决定您想要对这个流应用什么超时策略。例如，对于 UDP，单向连接的超时为 30 秒，双向连接的超时为 180 秒；参见`net/netfilter/nf_conntrack_proto_udp.c`中`udp_timeouts`数组的定义。对于复杂得多的协议 TCP，在`tcp_timeouts`数组(`net/netfilter/nf_conntrack_proto_tcp.c`)中有 11 个条目:

```
        /* Decide what timeout policy we want to apply to this flow. */
        timeouts = nf_ct_timeout_lookup(net, ct, l4proto);
```

您现在调用特定于协议的`packet()`方法(例如，UDP 的`udp_packet()`或 TCP 的`tcp_packet()`方法)。`udp_packet()`方法通过调用`nf_ct_refresh_acct()`方法根据连接的状态延长超时时间。对于未应答的连接(未设置 IPS_SEEN_REPLY_BIT 标志)，它将被设置为 30 秒，而对于应答的连接，它将被设置为 180。同样，在 TCP 的情况下，`tcp_packet()`方法要复杂得多，这是由于 TCP 高级状态机的缘故。此外，`udp_packet()`方法总是返回 NF_ACCEPT 的结论，而`tcp_packet()`方法有时可能会失败:

```
        ret = l4proto->packet(ct, skb, dataoff, ctinfo, pf, hooknum, timeouts);
        if (ret <= 0) {
                 /* Invalid: inverse of the return code tells
                  * the netfilter core what to do */
                 pr_debug("nf_conntrack_in: Can't track with proto module\n");
                 nf_conntrack_put(skb->nfct);
                 skb->nfct = NULL;
                 NF_CT_STAT_INC_ATOMIC(net, invalid);
                 if (ret == -NF_DROP)
                         NF_CT_STAT_INC_ATOMIC(net, drop);
                 ret = -ret;
                 goto out;
```

```
        }

        if (set_reply && !test_and_set_bit(IPS_SEEN_REPLY_BIT, &ct->status))
                 nf_conntrack_event_cache(IPCT_REPLY, ct);
        out:
        if (tmpl) {
                 /* Special case: we have to repeat this hook, assign the
                  * template again to this packet. We assume that this packet
                  * has no conntrack assigned. This is used by nf_ct_tcp. */
                 if (ret == NF_REPEAT)
                         skb->nfct = (struct nf_conntrack *)tmpl;
                 else
                         nf_ct_put(tmpl);
        }

        return ret;
}
```

在 NF_INET_POST_ROUTING 钩子和 NF_INET_LOCAL_IN 钩子中调用的`ipv4_confirm()`方法通常会调用`__nf_conntrack_confirm()`方法，该方法会将元组从未确认列表中移除。

连接跟踪助手和期望

有些协议有不同的数据流和控制流，例如，FTP(文件传输协议)和 SIP(会话发起协议，即 VoIP 协议)。通常在这些协议中，控制信道与另一端协商一些配置设置，并就数据流使用哪些参数达成一致。netfilter 子系统更难处理这些协议，因为 netfilter 子系统需要知道流是相互关联的。为了支持这些类型的协议，netfilter 子系统提供了连接跟踪帮助程序，它扩展了连接跟踪的基本功能。这些模块创建期望(`nf_conntrack_expect`对象)，这些期望告诉内核它应该在指定的连接上期待一些流量，并且两个连接是相关的。知道两个连接是相关的，就可以在主连接上定义也适用于相关连接的规则。您可以使用基于连接跟踪状态的简单 iptables 规则来接受其连接跟踪状态相关的数据包:

```
iptables -A INPUT -m conntrack --ctstate RELATED -j ACCEPT
```

![image](images/sq.jpg) **注意**联系不仅是期望的结果。例如，如果 netfilter 找到与嵌入 ICMP 的 L3/L4 报头中的元组相匹配的`conntrack`条目，则诸如“需要 ICMP 碎片”之类的 ICMPv4 错误包将是相关的。更多细节见`icmp_error_message()`方法，`net/ipv4/netfilter/nf_conntrack_proto_icmp.c`。

连接跟踪助手由`nf_conntrack_helper`结构(`include/net/netfilter/nf_conntrack_helper.h`)表示。它们分别通过`nf_conntrack_helper_register()`方法和`nf_conntrack_helper_unregister()`方法进行注册和取消注册。因此，例如，`nf_conntrack_ftp_init()` ( `net/netfilter/nf_conntrack_ftp.c`)调用`nf_conntrack_helper_register()`方法来注册 FTP 连接跟踪助手。连接跟踪助手保存在哈希表中(`nf_ct_helper_hash`)。`ipv4_helper()`钩子回调在两个钩子点注册，NF_INET_POST_ROUTING 和 NF_INET_LOCAL_IN(参见前面“连接跟踪初始化”一节中`ipv4_conntrack_ops`数组的定义)。因此，当 FTP 数据包到达 NF_INET_POST_ROUTING 回调函数`ip_output()`或 NF_INET_LOCAL_IN 回调函数`ip_local_deliver()`时，调用`ipv4_helper()`方法，该方法最终调用注册的连接跟踪帮助器的回调函数。在 FTP 的情况下，注册的帮助器方法是`help()`方法，`net/netfilter/nf_conntrack_ftp.c`。这个方法寻找特定于 FTP 的模式，比如“PORT”FTP 命令；参见下面的代码片段(`net/netfilter/nf_conntrack_ftp.c`)中对`help()`方法中`find_pattern()`方法的调用。如果匹配，通过调用`nf_ct_expect_init()`方法创建一个`nf_conntrack_expect`对象:

```
static int help(struct sk_buff *skb,
         unsigned int protoff,
         struct nf_conn *ct,
         enum ip_conntrack_info ctinfo)
{
       struct nf_conntrack_expect *exp;
    . . .
       for (i = 0; i < ARRAY_SIZE(search[dir]); i++) {
              found = find_pattern(fb_ptr, datalen,
                            search[dir][i].pattern,
                            search[dir][i].plen,
                            search[dir][i].skip,
                            search[dir][i].term,
                            &matchoff, &matchlen,
                            &cmd,
                            search[dir][i].getnum);
              if (found) break;
}

if (found == -1) {
             /* We don't usually drop packets.  After all, this is
                connection tracking, not packet filtering.
                However, it is necessary for accurate tracking in
                this case. */
             nf_ct_helper_log(skb, ct, "partial matching of `%s'",
                             search[dir][i].pattern);
```

![image](images/sq.jpg) **注意**正常情况下，连接跟踪不会丢包。在某些情况下，由于某些错误或异常情况，数据包会被丢弃。下面是这种情况的一个例子:早先对`find_pattern()`的调用返回–1，这意味着只有部分匹配；并且由于没有找到完全的模式匹配，该分组被丢弃。

```
              ret = NF_DROP;
              goto out;
       } else if (found == 0) { /* No match */
              ret = NF_ACCEPT;
              goto out_update_nl;
       }

       pr_debug("conntrack_ftp: match `%.*s' (%u bytes at %u)\n",
               matchlen, fb_ptr + matchoff,
               matchlen, ntohl(th->seq) + matchoff);

       exp = nf_ct_expect_alloc(ct);
    . . .
       nf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, cmd.l3num,
                         &ct->tuplehash[!dir].tuple.src.u3, daddr,
                         IPPROTO_TCP, NULL, &cmd.u.tcp.port);
    . . .
}
(net/netfilter/nf_conntrack_ftp.c)
```

稍后，当通过`init_conntrack()`方法创建一个新连接时，您检查它是否有期望，如果有，您设置 IPS_EXPECTED_BIT 标志并设置连接的主节点(`ct->master`)来引用创建期望的连接:

```
static struct nf_conntrack_tuple_hash *
init_conntrack(struct net *net, struct nf_conn *tmpl,
               const struct nf_conntrack_tuple *tuple,
               struct nf_conntrack_l3proto *l3proto,
               struct nf_conntrack_l4proto *l4proto,
               struct sk_buff *skb,
               unsigned int dataoff, u32 hash)
{
        struct nf_conn *ct;
        struct nf_conn_help *help;
        struct nf_conntrack_tuple repl_tuple;
        struct nf_conntrack_ecache *ecache;
        struct nf_conntrack_expect *exp;
        u16 zone = tmpl ? nf_ct_zone(tmpl) : NF_CT_DEFAULT_ZONE;
        struct nf_conn_timeout *timeout_ext;
        unsigned int *timeouts;

        . . .
        ct = __nf_conntrack_alloc(net, zone, tuple, &repl_tuple, GFP_ATOMIC,
                                  hash);
    . . .

        exp = nf_ct_find_expectation(net, zone, tuple);
        if (exp) {
                pr_debug("conntrack: expectation arrives ct=%p exp=%p\n",
                         ct, exp);
                /* Welcome, Mr. Bond.  We've been expecting you... */
                __set_bit(IPS_EXPECTED_BIT, &ct->status);
                ct->master = exp->master;
                if (exp->helper) {
                        help = nf_ct_helper_ext_add(ct, exp->helper,
                                                    GFP_ATOMIC);
                        if (help)
                                rcu_assign_pointer(help->helper, exp->helper);
                }
        . . .
```

请注意，助手监听预定义的端口。例如，FTP 连接跟踪助手监听端口 21(参见`include/linux/netfilter/nf_conntrack_ftp.h`中的 FTP_PORT 定义)。您可以通过两种方式之一设置不同的端口:第一种方式是通过模块参数——您可以通过向`modprobe`命令提供单个端口或逗号分隔的端口列表来覆盖默认端口值:

```
modprobe nf_conntrack_ftp ports=2121
modprobe nf_conntrack_ftp ports=2022,2023,2024
```

第二种方法是使用 CT 目标:

```
iptables -A PREROUTING -t raw -p tcp --dport 8888 -j CT --helper ftp
```

请注意，CT 目标(`net/netfilter/xt_CT.c`)是在内核 2.6.34 中添加的。

![image](images/sq.jpg) **注意** Xtables 目标扩展由`xt_target`结构表示，并通过`xt_register_target()`方法注册单个目标，或者通过`xt_register_targets()`方法注册一个目标数组。Xtables 匹配扩展由`xt_match`结构表示，并由`xt_register_match()`方法注册，或者由`xt_register_matches()`注册一个匹配数组。匹配扩展根据由匹配扩展模块定义的一些标准来检查分组；因此，例如，`xt_length`匹配模块(`net/netfilter/xt_length.c`)根据数据包的长度(IPv4 数据包情况下的 SKB 的`tot_len`)检查数据包，而`xt_connlimit`模块(`net/netfilter/xt_connlimit.c`)限制每个 IP 地址的并行 TCP 连接数。

本节详细介绍了连接跟踪初始化。下一节讨论 iptables，这可能是 netfilter 框架中最广为人知的部分。

防火墙

iptables 有两个部分。内核部分 IPv4 的内核在`net/ipv4/netfilter/ip_tables.c`中，IPv6 的内核在`net/ipv6/netfilter/ip6_tables.c`中。还有用户空间部分，它提供了访问内核 iptables 层的前端(例如，用`iptables`命令添加和删除规则)。每个表由`xt_table`结构表示(在`include/linux/netfilter/x_tables.h`中定义)。表的注册和注销分别由`ipt_register_table()`和`ipt_unregister_table()`方法完成。这些方法在`net/ipv4/netfilter/ip_tables.c`中实现。在 IPv6 中，您也可以使用`xt_table`结构来创建表，但是表的注册和注销分别由`ip6t_register_table()`方法和`ip6t_unregister_table()`方法来完成。

网络名称空间对象包含特定于 IPv4 和 IPv6 的对象(分别为`netns_ipv4`和`netns_ipv6`)。而`netns_ipv4`和`netns_ipv6`对象又包含指向`xt_table`对象的指针。对于 IPv4，在`struct netns_ipv4`中你有例如`iptable_filter`、`iptable_mangle`、`nat_table`等等(`include/net/netns/ipv4.h`)。在`struct netns_ipv6`中你有，比如说`ip6table_filter`、`ip6table_mangle`、`ip6table_nat`等等(`include/net/netns/ipv6.h`)。有关 IPv4 和 IPv6 网络名称空间 netfilter 表以及相应内核模块的完整列表，请参见本章末尾“快速参考”部分的[表 9-2](#Tab2) 和[表 9-3](#Tab3) 。

为了理解 iptables 是如何工作的，让我们看一个使用过滤器表的真实例子。为了简单起见，让我们假设过滤器表是唯一构建的，并且日志目标也是受支持的；我使用的唯一规则是用于日志记录，您很快就会看到。首先，我们来看看过滤表的定义:

```
#define FILTER_VALID_HOOKS ((1 << NF_INET_LOCAL_IN) | \
                            (1 << NF_INET_FORWARD) | \
                            (1 << NF_INET_LOCAL_OUT))

static const struct xt_table packet_filter = {
        .name           = "filter",
        .valid_hooks    = FILTER_VALID_HOOKS,
        .me             = THIS_MODULE,
        .af             = NFPROTO_IPV4,
        .priority       = NF_IP_PRI_FILTER,
};
(net/ipv4/netfilter/iptable_filter.c)
```

首先通过调用`xt_hook_link()`方法完成表的初始化，该方法将`iptable_filter_hook()`方法设置为`packet_filter`表的`nf_hook_ops`对象的钩子回调:

```
static struct nf_hook_ops *filter_ops __read_mostly;
static int __init iptable_filter_init(void)
{
     . . .
        filter_ops = xt_hook_link(&packet_filter, iptable_filter_hook);
     . . .
}
```

然后调用`ipt_register_table()`方法(注意，IPv4 `netns`对象`net->ipv4`，保存一个指向过滤表的指针`iptable_filter`):

```
static int __net_init iptable_filter_net_init(struct net *net)
{
    . . .
       net->ipv4.iptable_filter =
                ipt_register_table(net, &packet_filter, repl);
    . . .

       return PTR_RET(net->ipv4.iptable_filter);
}
(net/ipv4/netfilter/iptable_filter.c)
```

请注意，过滤器表中有三个挂钩:

*   本地网络
*   网络转发
*   本地输出

对于本例，您使用`iptable`命令行设置以下规则:

```
iptables -A INPUT -p udp --dport=5001 -j LOG --log-level 1
```

此规则的含义是，您将把目标端口为 5001 的传入 UDP 数据包转储到 syslog 中。`log-level`修饰符是 0 到 7 范围内的标准系统日志级别；0 表示紧急，7 表示调试。注意，当运行一个`iptables`命令时，您应该用`–t`修饰符指定您想要使用的表；例如，`iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE`会向 NAT 表中添加一条规则。当没有用`–t`修饰符指定表名时，默认情况下使用过滤表。因此，通过运行`iptables -A INPUT -p udp --dport=5001 -j LOG --log-level 1`，您向过滤器表添加了一个规则。

![image](images/sq.jpg) **注意**你可以给 iptables 规则设置目标；通常这些可以是来自 Linux netfilter 子系统的目标(参见前面使用日志目标的例子)。您还可以编写自己的目标，并扩展 iptables 用户空间代码来支持它们。参见 Jan Engelhardt 和 Nicolas Bouliane 的“编写 Netfilter 模块”。

注意，为了在 iptables 规则中使用日志目标，必须设置 CONFIG_NETFILTER_XT_TARGET_LOG，如前面的示例所示。你可以参考`net/netfilter/xt_LOG.c`的代码作为`iptables` 目标模块的例子。

当一个目的端口为 5001 的 UDP 包到达网络驱动，上行到网络层(L3)时，遇到的第一个钩子是 NF_INET_PRE_ROUTING 钩子；过滤表回调没有在 NF_INET_PRE_ROUTING 中注册一个钩子。它只有三个钩子:NF_INET_LOCAL_IN、NF_INET_FORWARD 和 NF_INET_LOCAL_OUT，如前所述。所以您继续使用`ip_rcv_finish()`方法，在路由子系统中执行查找。现在有两种情况:数据包打算传送到本地主机或打算转发(让我们忽略数据包将被丢弃的情况)。在图 9-2 中，你可以看到两种情况下的数据包遍历。

![9781430261964_Fig09-02.jpg](images/9781430261964_Fig09-02.jpg)

[图 9-2](#_Fig2) 。我的流量和转发流量采用过滤表规则

交付给本地主机

首先你到达`ip_local_deliver()`方法；简单看一下这个方法:

```
int ip_local_deliver(struct sk_buff *skb)
{
    . . .
       return NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN, skb, skb->dev, NULL,
                       ip_local_deliver_finish);
}
```

可以看到，你在这个方法中有 NF_INET_LOCAL_IN 钩子，前面也提到过，NF_INET_LOCAL_IN 是过滤表钩子之一；所以 NF_HOOK()宏将调用`iptable_filter_hook()`方法。现在看一看`iptable_filter_hook()`方法:

```
static unsigned int iptable_filter_hook(unsigned int hook, struct sk_buff *skb,
                                    const struct net_device *in,
                        const struct net_device *out,
                                 int (*okfn)(struct sk_buff *))
{
        const struct net *net;
        . . .
        net = dev_net((in != NULL) ? in : out);
        . . .

        return ipt_do_table(skb, hook, in, out, net->ipv4.iptable_filter);
}
(net/ipv4/netfilter/iptable_filter.c)
```

实际上，`ipt_do_table()`方法调用了日志目标回调函数`ipt_log_packet()`，它将数据包报头写入 syslog。如果有更多的规则，他们会在这个时候被调用。因为没有更多的规则，您继续使用`ip_local_deliver_finish()`方法，数据包继续遍历到传输层(L4)由相应的套接字处理。

转发数据包

第二种情况是，在路由子系统中进行查找后，您发现该数据包将被转发，因此调用了`ip_forward()`方法:

```
int ip_forward(struct sk_buff *skb)
  {
  . . .
   return NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD, skb, skb->dev,
                        rt->dst.dev, ip_forward_finish);
   . . .
```

因为过滤表在 NF_INET_FORWARD 中有一个注册的钩子回调函数，正如前面提到的，您再次调用了`iptable_filter_hook()`方法。因此，和以前一样，您再次调用了`ipt_do_table()`方法，它将再次调用`ipt_log_packet()`方法。你会继续到`ip_forward_finish()`方法(注意`ip_forward_finish`是上面 NF_HOOK 宏的最后一个参数，代表 continuation 方法)。然后调用`ip_output()`方法，因为过滤表没有 NF_INET_POST_ROUTING 钩子，所以继续到`ip_finish_output()`方法。

![image](images/sq.jpg) **注意**你可以根据连接跟踪状态过滤数据包。下一个规则将转储到连接跟踪状态已建立的 syslog 数据包中:

`iptables -A INPUT -p tcp -m conntrack --ctstate ESTABLISHED -j LOG --log-level 1`

网络地址转换(NAT)

网络地址转换(NAT)模块主要处理 IP 地址转换，顾名思义，即端口操作。NAT 最常见的用途之一是使局域网中拥有私有 IP 地址的一组主机能够通过某个住宅网关访问互联网。例如，您可以通过设置 NAT 规则来做到这一点。安装在网关上的 NAT 可以使用这样的规则，并为主机提供访问 Web 的能力。netfilter 子系统具有针对 IPv4 和 IPv6 的 NAT 实现。IPv6 NAT 实现主要基于 IPv4 实现，并且从用户的角度来看，提供了类似于 IPv4 的接口。IPv6 NAT 支持在内核 3.7 中被合并。它提供了一些功能，如简单的负载平衡解决方案(通过在传入流量上设置 DNAT)等。IPv6 NAT 模块在`net/ipv6/netfilter/ip6table_nat.c`中。NAT 设置有很多种类型，网上也有很多关于 NAT 管理的文档。我讲两种常见的配置:SNAT 是源 NAT，源 IP 地址改变，DNAT 是目的 NAT，目的 IP 地址改变。您可以使用`–j`标志来选择 SNAT 或 DNAT。DNAT 和 SNAT 的实现都在`net/netfilter/xt_nat.c`。下一节讨论 NAT 初始化。

NAT 初始化

NAT 表和上一节中的过滤器表一样，也是一个`xt_table`对象。除了 NF_INET_FORWARD 钩子之外，它在所有钩子点上都被注册:

```
static const struct xt_table nf_nat_ipv4_table = {
        .name           = "nat",
        .valid_hooks    = (1 << NF_INET_PRE_ROUTING) |
                          (1 << NF_INET_POST_ROUTING) |
                          (1 << NF_INET_LOCAL_OUT) |
                          (1 << NF_INET_LOCAL_IN),
        .me             = THIS_MODULE,
        .af             = NFPROTO_IPV4,
};
(net/ipv4/netfilter/iptable_nat.c)
```

NAT 表的注册和注销分别通过调用`ipt_register_table()`和`ipt_unregister_table()`(`net/ipv4/netfilter/iptable_nat.c`)来完成。网络名称空间(`struct net`)包括一个 IPv4 特定对象(`netns_ipv4`)，该对象包括一个指向 IPv4 NAT 表(`nat_table`)的指针，如前面的“IP 表”部分所述。这个由`ipt_register_table()`方法创建的`xt_table`对象被分配给这个`nat_table`指针。您还定义了一个`nf_hook_ops`对象的数组并注册它:

```
 static struct nf_hook_ops nf_nat_ipv4_ops[] __read_mostly = {
        /* Before packet filtering, change destination */
        {
                .hook           = nf_nat_ipv4_in,
                .owner          = THIS_MODULE,
                .pf             = NFPROTO_IPV4,
                .hooknum        = NF_INET_PRE_ROUTING,
                .priority       = NF_IP_PRI_NAT_DST,
        },
        /* After packet filtering, change source */
        {
                .hook           = nf_nat_ipv4_out,
                .owner          = THIS_MODULE,
                .pf             = NFPROTO_IPV4,
                .hooknum        = NF_INET_POST_ROUTING,
                .priority       = NF_IP_PRI_NAT_SRC,
        },
        /* Before packet filtering, change destination */
        {
                .hook           = nf_nat_ipv4_local_fn,
                .owner          = THIS_MODULE,
                .pf             = NFPROTO_IPV4,
                .hooknum        = NF_INET_LOCAL_OUT,
                .priority       = NF_IP_PRI_NAT_DST,
        },
        /* After packet filtering, change source */
        {
                .hook           = nf_nat_ipv4_fn,
                .owner          = THIS_MODULE,
                .pf             = NFPROTO_IPV4,
                .hooknum        = NF_INET_LOCAL_IN,
                .priority       = NF_IP_PRI_NAT_SRC,
        },
};
```

`nf_nat_ipv4_ops`数组的注册在`iptable_nat_init()`方法中完成:

```
static int __init iptable_nat_init(void)
{
        int err;
        . . .
        err = nf_register_hooks(nf_nat_ipv4_ops, ARRAY_SIZE(nf_nat_ipv4_ops));
        if (err < 0)
                goto err2;
        return 0;
        . . .
}
(net/ipv4/netfilter/iptable_nat.c)
```

NAT 钩子回调和连接跟踪钩子回调

有一些钩子同时注册了 NAT 回调和连接跟踪回调。例如，在 NF_INET_PRE_ROUTING 钩子(传入数据包到达的第一个钩子)上，有两个注册的回调:连接跟踪回调`ipv4_conntrack_in()` 和 NAT 回调`nf_nat_ipv4_in()`。连接跟踪回叫的优先级`ipv4_conntrack_in()`是 NF_IP_PRI_CONNTRACK (-200)，NAT 回叫的优先级`nf_nat_ipv4_in()`是 NF_IP_PRI_NAT_DST (-100)。因为优先级较低的同一个钩子的回调被首先调用，所以优先级为–200 的连接跟踪`ipv4_conntrack_in()`回调将在优先级为–100 的 NAT `nf_nat_ipv4_in()`回调之前被调用。`ipv4_conntrack_in()`方法位置见[图 9-1](#Fig1) 图`nf_nat_ipv4_in()`位置见[图 9-4](#Fig4)；两者都在同一个地方，在 NF_INET_PRE_ROUTING 点。这背后的原因是 NAT 在连接跟踪层执行查找，如果没有找到条目，NAT 不执行任何地址转换操作:

```
static unsigned int nf_nat_ipv4_fn(unsigned int hooknum,
                           struct sk_buff *skb,
                           const struct net_device *in,
                           const struct net_device *out,
                           int (*okfn)(struct sk_buff *))
{
        struct nf_conn *ct;
        . . .
        /* Don't try to NAT if this packet is not conntracked */
        if (nf_ct_is_untracked(ct))
                return NF_ACCEPT;
    . . .
}
(net/ipv4/netfilter/iptable_nat.c)
```

![image](images/sq.jpg) **注意**`nf_nat_ipv4_fn ()`方法是从 NAT PRE_ROUTING 回调中调用的，`nf_nat_ipv4_in()`。

在 NF_INET_POST_ROUTING 钩子上，有两个注册的连接跟踪回调:回调`ipv4_helper()`(优先级为 NF_IP_PRI_CONNTRACK_HELPER，300)和回调`ipv4_confirm()`(优先级为 NF_IP_PRI_CONNTRACK_CONFIRM，INT_MAX，优先级最高的整数值)。你还有一个注册的 NAT 钩子回调，`nf_nat_ipv4_out()`，优先级为 NF_IP_PRI_NAT_SRC，为 100。这样一来，当到达 NF_INET_POST_ROUTING 钩子时，首先会调用 NAT 回调，`nf_nat_ipv4_out()`，然后会调用`ipv4_helper()`方法，`ipv4_confirm()`是最后被调用的。参见[图 9-4](#Fig4) 。

让我们来看看一个简单的 DNAT 规则，看看转发的包的遍历以及连接跟踪回调和 NAT 回调的调用顺序(为了简单起见，假设这个内核映像中没有构建过滤器表)。在图 9-3 所示的设置中，中间主机(AMD 服务器)运行 DNAT 规则:

```
iptables -t nat -A PREROUTING -j DNAT -p udp --dport 9999 --to-destination 192.168.1.8
```

![9781430261964_Fig09-03.jpg](images/9781430261964_Fig09-03.jpg)

[图 9-3](#_Fig3) 。一个简单的 DNAT 规则设置

此 DNAT 规则的含义是，在 UDP 目标端口 9999 上发送的传入 UDP 数据包会将其目标 IP 地址更改为 192.168.1.8。右侧机器(Linux 桌面)将 UDP 数据包发送到 192.168.1.9，UDP 目的端口为 9999。在 AMD 服务器中，目的 IPv4 地址被 DNAT 规则更改为 192.168.1.8，数据包被发送到左边的笔记本电脑。

在[图 9-4](#Fig4) 中，您可以看到第一个 UDP 包的遍历，它是根据前面提到的设置发送的。

![9781430261964_Fig09-04.jpg](images/9781430261964_Fig09-04.jpg)

[图 9-4](#_Fig4) 。NAT 和 netfilter 挂钩

通用的 NAT 模块是`net/netfilter/nf_nat_core.c`。NAT 实现的基本元素是`nf_nat_l4proto`结构(`include/net/netfilter/nf_nat_l4proto.h`和`nf_nat_l3proto`结构。在 3.7 之前的内核中，您将会遇到`nf_nat_protocol`结构，而不是这两个结构，这两个结构作为添加 IPv6 NAT 支持的一部分取代了它们。这两种结构提供了独立于协议的 NAT 核心支持。

这两种结构都包含一个`manip_pkt()`函数指针，用于改变数据包报头。让我们看一个 TCP 协议的`manip_pkt()`实现的例子，在`net/netfilter/nf_nat_proto_tcp.c`中:

```
static bool tcp_manip_pkt(struct sk_buff *skb,
              const struct nf_nat_l3proto *l3proto,
              unsigned int iphdroff, unsigned int hdroff,
              const struct nf_conntrack_tuple *tuple,
              enum nf_nat_manip_type maniptype)
{
        struct tcphdr *hdr;
        __be16 *portptr, newport, oldport;
        int hdrsize = 8; /* TCP connection tracking guarantees this much */

        /* this could be an inner header returned in icmp packet; in such
           cases we cannot update the checksum field since it is outside of
           the 8 bytes of transport layer headers we are guaranteed */
        if (skb->len >= hdroff + sizeof(struct tcphdr))
                hdrsize = sizeof(struct tcphdr);

        if (!skb_make_writable(skb, hdroff + hdrsize))
                return false;

        hdr = (struct tcphdr *)(skb->data + hdroff);
```

根据`maniptype`设置`newport`:

*   如果需要更改源端口，`maniptype`是 NF_NAT_MANIP_SRC。所以您从`tuple->src`中提取端口。
*   如果需要更改目的端口，`maniptype`是 NF_NAT_MANIP_DST。所以您从`tuple->dst`中提取端口:

```
        if (maniptype == NF_NAT_MANIP_SRC) {
                /* Get rid of src port */
                newport = tuple->src.u.tcp.port;
                portptr = &hdr->source;
        } else {
                /* Get rid of dst port */
                newport = tuple->dst.u.tcp.port;
                portptr = &hdr->dest;
        }
```

你要改变 TCP 头的源端口(当`maniptype`为 NF_NAT_MANIP_SRC 时)或者目的端口(当`maniptype`为 NF_NAT_MANIP_DST 时)，所以你需要重新计算校验和。您必须保留旧端口用于校验和重新计算，这将通过调用`csum_update()`方法和`inet_proto_csum_replace2()`方法立即完成:

```
        oldport = *portptr;
        *portptr = newport;

        if (hdrsize < sizeof(*hdr))
                return true;
```

重新计算校验和:

```
        l3proto->csum_update(skb, iphdroff, &hdr->check, tuple, maniptype);
        inet_proto_csum_replace2(&hdr->check, skb, oldport, newport, 0);
        return true;
}
```

NAT 钩子回调

特定于协议的 NAT 模块对于 IPv4 协议是`net/ipv4/netfilter/iptable_nat.c`，对于 IPv6 协议是`net/ipv6/netfilter/ip6table_nat.c`。这两个 NAT 模块各有四个钩子回调，如[表 9-1](#Tab1) 所示。

[表 9-1](#_Tab1) 。IPv4 和 IPv6 NAT 回调

<colgroup><col width="30%"> <col width="35%"> <col width="35%"></colgroup> 
| 

钩

 | 

挂机回拨(IPv4)

 | 

挂钩回调(IPv6)

 |
| --- | --- | --- |
| NF _ INET _ 预路由 | 网络地址转换 ipv4 输入 | 网络地址转换协议 ipv6 协议 |
| 物流配送 | nf_nat_ipv4_out | nf_nat_ipv6_out |
| 本地输出 | nf_nat_ipv4_local_fn | nf_nat_ipv6_local_fn |
| 本地网络 | nf_nat_ipv4_fn | nf_nat_ipv6_fn |

`nf_nat_ipv4_fn()`是这些方法中最重要的(对于 IPv4)。其他三个方法，`nf_nat_ipv4_in()`、`nf_nat_ipv4_out()`和`nf_nat_ipv4_local_fn()`，都调用了`nf_nat_ipv4_fn()`方法。让我们来看看`nf_nat_ipv4_fn()`方法:

```
static unsigned int nf_nat_ipv4_fn(unsigned int hooknum,
                              struct sk_buff *skb,
                              const struct net_device *in,
                              const struct net_device *out,
                              int (*okfn)(struct sk_buff *))
{
        struct nf_conn *ct;
        enum ip_conntrack_info ctinfo;
        struct nf_conn_nat *nat;
        /* maniptype == SRC for postrouting. */
        enum nf_nat_manip_type maniptype = HOOK2MANIP(hooknum);

        /* We never see fragments: conntrack defrags on pre-routing
         * and local-out, and nf_nat_out protects post-routing.
         */
        NF_CT_ASSERT(!ip_is_fragment(ip_hdr(skb)));

        ct = nf_ct_get(skb, &ctinfo);
        /* Can't track?  It's not due to stress, or conntrack would
         * have dropped it.  Hence it's the user's responsibilty to
         * packet filter it out, or implement conntrack/NAT for that
         * protocol. 8) --RR
         */
        if (!ct)
                return NF_ACCEPT;

        /* Don't try to NAT if this packet is not conntracked */
        if (nf_ct_is_untracked(ct))
                return NF_ACCEPT;

        nat = nfct_nat(ct);
        if (!nat) {
                /* NAT module was loaded late. */
                if (nf_ct_is_confirmed(ct))
                        return NF_ACCEPT;
                nat = nf_ct_ext_add(ct, NF_CT_EXT_NAT, GFP_ATOMIC);
                if (nat == NULL) {
                        pr_debug("failed to add NAT extension\n");
                        return NF_ACCEPT;
                }
        }

        switch (ctinfo) {
        case IP_CT_RELATED:
        case IP_CT_RELATED_REPLY:
                if (ip_hdr(skb)->protocol == IPPROTO_ICMP) {
                        if (!nf_nat_icmp_reply_translation(skb, ct, ctinfo,
                                                           hooknum))
                                return NF_DROP;
                        else
                                return NF_ACCEPT;
                }
                /* Fall thru... (Only ICMPs can be IP_CT_IS_REPLY) */
        case IP_CT_NEW:
                /* Seen it before?  This can happen for loopback, retrans,
                 * or local packets.
                 */
                if (!nf_nat_initialized(ct, maniptype)) {
                        unsigned int ret;
```

`nf_nat_rule_find()`方法调用`ipt_do_table()`方法，该方法遍历指定表中条目的所有匹配项，如果有匹配项，则调用目标回调:

```
                        ret = nf_nat_rule_find(skb, hooknum, in, out, ct);
                        if (ret != NF_ACCEPT)
                                return ret;
                } else {
                        pr_debug("Already setup manip %s for ct %p\n",
                                 maniptype == NF_NAT_MANIP_SRC ? "SRC" : "DST",
                                 ct);
                        if (nf_nat_oif_changed(hooknum, ctinfo, nat, out))
                                goto oif_changed;
                }
                break;

        default:
                /* ESTABLISHED */
                NF_CT_ASSERT(ctinfo == IP_CT_ESTABLISHED ||
                             ctinfo == IP_CT_ESTABLISHED_REPLY);
                if (nf_nat_oif_changed(hooknum, ctinfo, nat, out))
                        goto oif_changed;
        }

        return nf_nat_packet(ct, ctinfo, hooknum, skb);

oif_changed:
        nf_ct_kill_acct(ct, ctinfo, skb);
        return NF_DROP;
}
```

连接跟踪扩展

内核 2.6.23 中添加了连接跟踪(CT)扩展。连接跟踪扩展的要点是只分配所需的内存，例如，如果没有加载 NAT 模块，则不会分配连接跟踪层中 NAT 所需的额外内存。有些扩展是由`sysctls`启用的，甚至取决于某些 iptables 规则(例如，`-m connlabel`)。每个连接跟踪扩展模块应该定义一个`nf_ct_ext_type`对象，并通过`nf_ct_extend_register()`方法执行注册(取消注册通过`nf_ct_extend_unregister()`方法完成)。每个扩展应该定义一个方法，将它的连接跟踪扩展附加到一个连接(`nf_conn`)对象，该对象应该从`init_conntrack()`方法中调用。因此，例如，您有用于时间戳 CT 扩展的`nf_ct_tstamp_ext_add()`方法和用于标签 CT 扩展的`nf_ct_labels_ext_add()`方法。连接跟踪扩展基础设施在`net/netfilter/nf_conntrack_extend.c`中实现。这些是撰写本文时的连接跟踪扩展模块(全部在`net/netfilter`下):

*   `nf_conntrack_timestamp.c`
*   `nf_conntrack_timeout.c`
*   `nf_conntrack_acct.c`
*   `nf_conntrack_ecache.c`
*   `nf_conntrack_labels.c`
*   `nf_conntrack_helper.c`

摘要

本章描述了 netfilter 子系统的实现。我介绍了 netfilter 挂钩以及它们是如何注册的。我还讨论了一些重要的主题，比如连接跟踪机制、iptables 和 NAT。第 10 章讲述了 IPsec 子系统及其实现。

快速参考

本节涵盖了与本章中讨论的主题相关的顶级方法，按其上下文排序，后面是三个表和一个关于工具和库的简短部分。

方法

下面是 netfilter 子系统的重要方法的简短列表。本章提到了其中一些。

struct XT _ table * ipt _ register _ table(struct net * net，const struct xt_table *table，const struct ipt _ replace * repl)；

此方法在 netfilter 子系统中注册一个表。

void ipt _ unregister _ table(struct net * net，struct XT _ table * table)；

此方法在 netfilter 子系统中注销一个表。

int nf _ register _ hook(struct nf _ hook _ ops * reg)；

这个方法注册一个单独的`nf_hook_ops`对象。

int nf _ register _ hooks(struct nf _ hook _ ops * reg，unsigned int n)；

该方法注册一个由 *n 个* `nf_hook_ops`对象组成的数组；第二个参数是数组中元素的数量。

void nf _ unregister _ hook(struct nf _ hook _ ops * reg)；

这个方法注销一个单独的`nf_hook_ops`对象。

void nf _ unregister _ hooks(struct nf _ hook _ ops * reg，unsigned int n)；

此方法注销一个由 *n* `nf_hook_ops`个对象组成的数组；第二个参数是数组中元素的数量。

静态内联 void nf _ conntrack _ get(struct nf _ conntrack * nfct)；

该方法增加相关`nf_conntrack`对象的引用计数。

静态内联 void nf _ conntrack _ put(struct nf _ conntrack * nfct)；

该方法减少相关`nf_conntrack`对象的引用计数。如果达到 0，就调用`nf_conntrack_destroy()`方法。

int nf _ conn track _ helper _ register(struct nf _ conn track _ helper * me)；

这个方法注册一个`nf_conntrack_helper`对象。

静态内联结构 nf _ conn * resolve _ normal _ CT(struct net * net，struct nf_conn *tmpl，struct sk_buff *skb，unsigned int dataoff，u_int16_t l3num，u_int8_t protonum，struct nf _ conn track _ L3 proto * L3 proto，struct nf _ conn track _ l4 proto * l4 proto，int *set_reply，enum IP _ conn track _ info * ctinfo)；

这个方法试图通过调用`__nf_conntrack_find_get()`方法根据指定的 SKB 找到一个`nf_conntrack_tuple_hash`对象，如果没有找到这样的条目，就通过调用`init_conntrack()`方法创建一个。从`nf_conntrack_in()`方法(`net/netfilter/nf_conntrack_core.c`)调用`resolve_normal_ct()`方法。

struct nf _ conntrack _ 元组 _ hash * init _ conntrack(struct net * net，struct nf_conn *tmpl，const struct nf _ conntrack _ 元组*元组，struct nf _ conntrack _ L3 proto * L3 protocol，struct nf _ conntrack _ l4 proto * l4 proto，struct sk _ buff * skb，signed int dataoff，u32 hash)；

这个方法分配一个连接跟踪`nf_conntrack_tuple_hash`对象。从`resolve_normal_ct()`方法中调用，它试图通过调用`nf_ct_find_expectation()`方法来寻找这个连接的期望。

static struct nf _ conn * _ _ _ nf _ conntrack _ alloc(struct net * net，u16 区域，const struct nf _ conntrack _ tuple * orig，const struct nf _ conntrack _ tuple * repl，gfp_t gfp，u32 hash)；

这个方法分配一个`nf_conn`对象。将`nf_conn`对象的超时计时器设置为`death_by_timeout()`方法。

int XT _ register _ target(struct XT _ target * target)；

这个方法注册一个 Xtable 目标扩展。

void XT _ unregister _ target(struct XT _ target * target)；

此方法注销 Xtable 目标扩展。

int XT _ register _ targets(struct XT _ target * target，unsigned int n)；

此方法注册 Xtable 目标扩展的数组； *n* 是目标数量。

void XT _ unregister _ targets(struct XT _ target * target，unsigned int n)；

此方法注销 Xtable 目标扩展的数组； *n* 是目标数量。

int XT _ register _ match(struct XT _ match * target)；

此方法注册一个 Xtable 匹配扩展。

void XT _ unregister _ match(struct XT _ match * target)；

此方法注销 Xtable 匹配扩展。

int XT _ register _ matches(struct XT _ match * match，unsigned int n)；

此方法注册 Xtable 匹配扩展的数组； *n* 是匹配的次数。

void XT _ unregister _ matches(struct XT _ match * match，unsigned int n)；

此方法注销 Xtable 匹配扩展的数组； *n* 是匹配的次数。

int nf _ CT _ extend _ register(struct nf _ CT _ ext _ type * type)；

此方法注册连接跟踪扩展对象。

void nf _ CT _ extend _ unregister(struct nf _ CT _ ext _ type * type)；

此方法注销连接跟踪扩展对象。

int _ _ init iptable _ NAT _ init(void)；

此方法初始化 IPv4 NAT 表。

int __init nf_conntrack_ftp_init(请参阅)：

此方法初始化连接跟踪 FTP 帮助程序。调用`nf_conntrack_helper_register()`方法来注册 FTP 助手。

巨

让我们看看本章中使用的宏。

NF_CT_DIRECTION(哈希)

这是一个宏，获取一个`nf_conntrack_tuple_hash`对象作为参数，返回关联元组(`include/net/netfilter/nf_conntrack_tuple.h`)的目的(`dst`对象)的方向(IP_CT_DIR_ORIGINAL，为 0，或者 IP_CT_DIR_REPLY，为 1)。

桌子

下面是表格，显示了 IPv4 网络名称空间和 IPv6 网络名称空间中的 netfilter 表以及 netfilter 挂钩优先级。

[表 9-2](#_Tab2) 。IPv4 网络命名空间(netns_ipv4)表(xt_table 对象)

<colgroup><col width="40%"> <col width="60%"></colgroup> 
| 

Linux 符号( **netns_ipv4)**

 | 

**Linux 模块**

 |
| --- | --- |
| iptable_filter | net/IP v4/netfilter/iptable _ filter . c |
| iptable_mangle | net/IP v4/netfilter/iptable _ mangle . c |
| iptable_raw | net/IP v4/netfilter/iptable _ raw . c |
| ARP 表 _ 过滤器 | net/IP v4/netfilter/ARP _ tables . c |
| nat_table | net/IP v4/netfilter/iptable _ NAT . c |
| iptable_security | net/IP v4/netfilter/iptable _ SECURITY . c(注意:要设置 CONFIG_SECURITY)。 |

[表 9-3](#_Tab3) 。IPv6 网络命名空间(netns_ipv6)表(xt_table 对象)

<colgroup><col width="40%"> <col width="60%"></colgroup> 
| 

Linux 符号( **netns_ipv6)**

 | 

**Linux 模块**

 |
| --- | --- |
| ip6 表格 _ 过滤器 | net/IPv6/netfilter/IP 6 table _ filter . c |
| ip6table_mangle | net/IPv6/netfilter/IP 6 table _ mangle . c |
| ip6table_raw | net/IPv6/netfilter/IP 6 table _ raw . c |
| ip6table_nat | net/IPv6/netfilter/IP 6 table _ NAT . c |
| ip6table_security | net/IPv6/netfilter/IP 6 table _ SECURITY . c(注意:要设置 CONFIG_SECURITY)。 |

[表 9-4。](#_Tab4) Netfilter 挂钩优先级

<colgroup><col width="40%"> <col width="60%"></colgroup> 
| 

Linux 符号

 | 

**值**

 |
| --- | --- |
| NF _ IP _ 优先级 _ 优先 | INT_MIN |
| nf _ ip _ pri _ conntrack _ 碎片整理 | -400 |
| NF_IP_PRI_RAW 格式 | -300 |
| NF _ IP _ 优先级 _ SELINUX _ 优先 | -225 |
| nf _ IP _ pri _ conntrack _ 连线轨迹 | -200 |
| S7-1200 可编程控制器 | -150 |
| NF_IP_PRI_NAT_DST 文件 | -100 |
| 网络过滤协议优先级过滤器 | Zero |
| NF_IP_PRI_SECURITY | Fifty |
| NF_IP_PRI_NAT_SRC | One hundred |
| 最后一个 | Two hundred and twenty-five |
| NF_IP_PRI_CONNTRACK_HELPER | Three hundred |
| NF _ IP _ PRI _ CONNTRACK _ 确认 | INT_MAX |
| NF _ IP _ 优先级 _ 最后 | INT_MAX |

参见`include/uapi/linux/netfilter_ipv4.h`中的`nf_ip_hook_priorities enum`定义。

工具和库

`conntrack-tools`由一个用户空间守护进程`conntrackd`和一个命令行工具`conntrack`组成。它提供了一个工具，系统管理员可以使用该工具与 netfilter 连接跟踪层进行交互。参见:`http://conntrack-tools.netfilter.org/`。

有些库是由 netfilter 项目开发的，允许您执行各种用户空间任务；这些库以“libnetfilter”为前缀；比如`libnetfilter_conntrack`、`libnetfilter_log`、`libnetfilter_queue`。更多详情见 netfilter 官网，`www.netfilter.org`。