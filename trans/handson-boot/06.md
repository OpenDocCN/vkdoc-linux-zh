# 6.

简单地说，dracut 是一个在基于 Fedora 的系统上创建 initramfs 文件系统的工具。基于 Debian 和 Ubuntu 的系统使用一个类似的工具叫做 *update-initramfs* 。如果您想要生成、重新生成或定制现有的 initramfs，那么您应该知道如何使用 dracut 工具。本章将解释 dracut 如何工作，以及如何生成和定制 initramfs。此外，您将了解一些与 initramfs 相关的最常见的“无法启动”问题。

## 入门指南

每个内核都有自己的 initramfs 文件，但是您可能想知道为什么在安装一个新的内核时从来不需要使用`dracut`命令来创建 initramfs。相反，您只是在`/boot`位置找到了各自的 initramfs。嗯，当你安装一个新的内核时，内核的`rpm`包的`post-scripts`命令调用 dracut 并为你创建 initramfs。让我们看看它在基于 Fedora 的系统上是如何工作的:

```
# rpm -q --scripts kernel-core-5.3.7-301.fc31.x86_64
postinstall scriptlet (using /bin/sh):

if [ `uname -i` == "x86_64" -o `uname -i` == "i386" ] &&
   [ -f /etc/sysconfig/kernel ]; then
  /bin/sed -r -i -e 's/^DEFAULTKERNEL=kernel-smp$/DEFAULTKERNEL=kernel/' /etc/sysconfig/kernel || exit $?
fi
preuninstall scriptlet (using /bin/sh):
/bin/kernel-install remove 5.3.7-301.fc31.x86_64 /lib/modules/5.3.7-301.fc31.x86_64/vmlinuz || exit $?
posttrans scriptlet (using /bin/sh):
/bin/kernel-install add 5.3.7-301.fc31.x86_64 /lib/modules/5.3.7-301.fc31.x86_64/vmlinuz || exit $?

```

可以看到，内核包的`post-scripts`命令调用了`kernel-install`脚本。`kernel-install`脚本执行所有在`/usr/lib/kernel/install.d`可用的脚本。

```
# vim /bin/kernel-install

 94 if ! [[ $MACHINE_ID ]]; then
 95     ENTRY_DIR_ABS=$(mktemp -d /tmp/kernel-install.XXXXX) || exit 1
 96     trap "rm -rf '$ENTRY_DIR_ABS'" EXIT INT QUIT PIPE
 97 elif [[ -d /efi/loader/entries ]] || [[ -d /efi/$MACHINE_ID ]]; then
 98     ENTRY_DIR_ABS="/efi/$MACHINE_ID/$KERNEL_VERSION"
 99 elif [[ -d /boot/loader/entries ]] || [[ -d /boot/$MACHINE_ID ]]; then
100     ENTRY_DIR_ABS="/boot/$MACHINE_ID/$KERNEL_VERSION"
101 elif [[ -d /boot/efi/loader/entries ]] || [[ -d /boot/efi/$MACHINE_ID ]]; then
102     ENTRY_DIR_ABS="/boot/efi/$MACHINE_ID/$KERNEL_VERSION"
103 elif mountpoint -q /efi; then
104     ENTRY_DIR_ABS="/efi/$MACHINE_ID/$KERNEL_VERSION"
105 elif mountpoint -q /boot/efi; then
106     ENTRY_DIR_ABS="/boot/efi/$MACHINE_ID/$KERNEL_VERSION"
107 else
108     ENTRY_DIR_ABS="/boot/$MACHINE_ID/$KERNEL_VERSION"
109 fi
110
111 export KERNEL_INSTALL_MACHINE_ID=$MACHINE_ID
112
113 ret=0
114
115 readarray -t PLUGINS <<<"$(
116     dropindirs_sort ".install" \
117         "/etc/kernel/install.d" \
118         "/usr/lib/kernel/install.d"
119 )"

```

在这里您可以看到由`kernel-install`执行的脚本:

```
# ls /usr/lib/kernel/install.d/ -lh
total 36K
-rwxr-xr-x. 1 root root  744 Oct 10 18:26 00-entry-directory.install
-rwxr-xr-x. 1 root root 1.9K Oct 19 07:46 20-grubby.install
-rwxr-xr-x. 1 root root 6.6K Oct 10 13:05 20-grub.install
-rwxr-xr-x. 1 root root  829 Oct 10 18:26 50-depmod.install
-rwxr-xr-x. 1 root root 1.7K Jul 25  2019 50-dracut.install
-rwxr-xr-x. 1 root root 3.4K Jul 25  2019 51-dracut-rescue.install
-rwxr-xr-x. 1 root root 3.4K Oct 10 18:26 90-loaderentry.install
-rwxr-xr-x. 1 root root 1.1K Oct 10 13:05 99-grub-mkconfig.install

```

如您所见，这执行了`50-dracut.install`脚本。这个特定的脚本执行`dracut`命令，并为特定的内核创建 initramfs。

```
 46         for ((i=0; i < "${#BOOT_OPTIONS[@]}"; i++)); do
 47             if [[ ${BOOT_OPTIONS[$i]} == root\=PARTUUID\=* ]]; then
 48                 noimageifnotneeded="yes"
 49                 break
 50             fi
 51         done
 52         dracut -f ${noimageifnotneeded:+--noimageifnotneeded} "$BOOT_DIR_ABS/$INITRD" "$KERNEL_VERSION"
 53         ret=$?
 54         ;;
 55     remove)
 56         rm -f -- "$BOOT_DIR_ABS/$INITRD"
 57         ret=$?
 58         ;;
 59 esac
 60 exit $ret

```

同样，还有脚本`51-dracut-rescue.install`，它将为救援内核生成 initramfs。

```
100         if [[ ! -f "$BOOT_DIR_ABS/$INITRD" ]]; then
101             dracut -f --no-hostonly -a "rescue" "$BOOT_DIR_ABS/$INITRD" "$KERNEL_VERSION"
102             ((ret+=$?))
103         fi
104
105         if [[ "${BOOT_DIR_ABS}" != "/boot" ]]; then
106             {
107                 echo "title      $PRETTY_NAME - Rescue Image"
108                 echo "version    $KERNEL_VERSION"
109                 echo "machine-id $MACHINE_ID"
110                 echo "options    ${BOOT_OPTIONS[@]} rd.auto=1"
111                 echo "linux      $BOOT_DIR/linux"
112                 echo "initrd     $BOOT_DIR/initrd"
113             } > $LOADER_ENTRY
114         else
115             cp -aT "${KERNEL_IMAGE%/*}/bls.conf" $LOADER_ENTRY
116             sed -i 's/'$KERNEL_VERSION'/0-rescue-'${MACHINE_ID}'/' $LOADER_ENTRY
117         fi

```

因此，每个内核都有自己的 initramfs 文件。

```
# ls -lh /boot | grep -e vmlinuz -e initramfs

-rw-------. 1 root root  80M Dec  2 18:32 initramfs-0-rescue-280526b3bc5e4c49ac83c8e5fbdfdb2e.img
-rw-------. 1 root root  28M Dec 23 06:37 initramfs-5.3.16-300.fc31.x86_64.img
-rw-------. 1 root root  30M Dec  2 18:33 initramfs-5.3.7-301.fc31.x86_64.img
-rwxr-xr-x. 1 root root 8.9M Dec  2 18:32 vmlinuz-0-rescue-280526b3bc5e4c49ac83c8e5fbdfdb2e
-rwxr-xr-x. 1 root root 8.9M Dec 13 23:51 vmlinuz-5.3.16-300.fc31.x86_64
-rwxr-xr-x. 1 root root 8.9M Oct 22 01:04 vmlinuz-5.3.7-301.fc31.x86_64

```

注意内核(`vmlinuz`)文件的大小及其相关的 initramfs 文件大小。initramfs 文件比内核大得多。

## 制作 initramfs 映像

首先使用以下命令检查您的系统上安装了哪个内核:

```
# rpm -qa | grep -i kernel-5

kernel-5.3.16-300.fc31.x86_64
kernel-5.3.7-301.fc31.x86_64

```

选择要为其生成新的 initramfs 映像的内核版本，并将其传递给 dracut。

```
# dracut /boot/new.img 5.3.7-301.fc31.x86_64 -v
<snip>
dracut: Executing: /usr/bin/dracut /boot/new.img 5.3.7-301.fc31.x86_64 -v
dracut: dracut module 'busybox' will not be installed, because command 'busybox' could not be found!
dracut: dracut module 'stratis' will not be installed, because command 'stratisd-init' could not be found!
dracut: dracut module 'biosdevname' will not be installed, because command 'biosdevname' could not be found!
dracut: dracut module 'busybox' will not be installed, because command 'busybox' could not be found!
dracut: dracut module 'stratis' will not be installed, because command 'stratisd-init' could not be found!
dracut: *** Including module: bash ***
dracut: *** Including module: systemd ***
dracut: *** Including module: systemd-initrd ***
dracut: *** Including module: nss-softokn ***
dracut: *** Including module: i18n ***
dracut: *** Including module: network-manager ***
dracut: *** Including module: network ***
dracut: *** Including module: ifcfg ***
dracut: *** Including module: drm ***
dracut: *** Including module: plymouth ***
.
.
</snip>

```

在前面的代码中，dracut 将在当前目录中为 64 位 Fedora 内核`Kernel-5.3.7-301.fc31.x86_64`创建一个名为`new.img`的 initramfs 文件。

```
# ls -lh new.img
-rw-------. 1 root root 28M Dec 23 08:16 new.img

```

如果没有提供内核版本，那么 dracut 将为引导系统的内核创建 initramfs。传递给 dracut 的内核版本必须与位于`/lib/modules/`位置的内核目录相匹配。

```
# ls /lib/modules/ -l
total 4
drwxr-xr-x. 6 root root 4096 Dec  9 10:18 5.3.7-301.fc31.x86_64

# ls /lib/modules/5.3.7-301.fc31.x86_64/ -l
total 18084
-rw-r--r--.  1 root root     249 Oct 22 01:04 bls.conf
lrwxrwxrwx.  1 root root      38 Oct 22 01:04 build -> /usr/src/kernels/5.3.7-301.fc31.x86_64
-rw-r--r--.  1 root root  213315 Oct 22 01:03 config
drwxr-xr-x.  5 root root    4096 Oct 24 04:44 extra
drwxr-xr-x. 13 root root    4096 Oct 24 04:43 kernel
-rw-r--r--.  1 root root 1127438 Dec  9 10:18 modules.alias
-rw-r--r--.  1 root root 1101059 Dec  9 10:18 modules.alias.bin
-rw-r--r--.  1 root root    1688 Oct 22 01:04 modules.block
-rw-r--r--.  1 root root    8324 Oct 22 01:04 modules.builtin
-rw-r--r--.  1 root root   10669 Dec  9 10:18 modules.builtin.bin
-rw-r--r--.  1 root root   60853 Oct 22 01:04 modules.builtin.modinfo
-rw-r--r--.  1 root root  415475 Dec  9 10:18 modules.dep
-rw-r--r--.  1 root root  574502 Dec  9 10:18 modules.dep.bin
-rw-r--r--.  1 root root     381 Dec  9 10:18 modules.devname
-rw-r--r--.  1 root root     153 Oct 22 01:04 modules.drm
-rw-r--r--.  1 root root      59 Oct 22 01:04 modules.modesetting
-rw-r--r--.  1 root root    2697 Oct 22 01:04 modules.networking
-rw-r--r--.  1 root root  139947 Oct 22 01:04 modules.order
-rw-r--r--.  1 root root     700 Dec  9 10:18 modules.softdep
-rw-r--r--.  1 root root  468520 Dec  9 10:18 modules.symbols
-rw-r--r--.  1 root root  572778 Dec  9 10:18 modules.symbols.bin
lrwxrwxrwx.  1 root root       5 Oct 22 01:04 source -> build
-rw-------.  1 root root 4426726 Oct 22 01:03 System.map
drwxr-xr-x.  2 root root    4096 Oct 22 01:02 updates
drwxr-xr-x.  2 root root    4096 Oct 24 04:43 vdso
-rwxr-xr-x.  1 root root 9323208 Oct 22 01:04 vmlinuz

```

正如我们所知，initramfs 是一个临时的根文件系统，它的主要目的是提供一个环境来帮助挂载用户的根文件系统。用户的根文件系统可以是系统的本地文件系统，也可以是网络设备，为了使用该设备，内核应该有该硬件的驱动程序(模块),并且在引导时从 initramfs 获取这些模块。

例如，假设用户的根文件系统是本地连接的硬盘，而硬盘是 SCSI 设备。因此，initramfs 必须将 SCSI 驱动程序添加到它的归档中。

```
# lsinitrd | grep -i scsi | awk '{ print $9 }'
etc/ld.so.conf.d/libiscsi-x86_64.conf
usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/firmware/iscsi_ibft.ko.xz
usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/scsi
usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/scsi/iscsi_boot_sysfs.ko.xz
usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/scsi/libiscsi.ko.xz
usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/scsi/qla4xxx
usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/scsi/qla4xxx/qla4xxx.ko.xz
usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/scsi/scsi_transport_iscsi.ko.xz
usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/scsi/scsi_transport_srp.ko.xz
usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/scsi/virtio_scsi.ko.xz
usr/lib/udev/scsi_id

```

在 SCSI 设备之上，用户可能已经配置了一个 RAID 设备。如果有，那么内核需要 RAID 设备驱动程序来识别和组装 RAID 设备。类似地，一些用户的硬盘可以通过 HBA 卡连接。在这种情况下，内核需要一个类似`qlaXxxx-`的模块。

```
# lsinitrd | grep -i qla

        usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/scsi/qla4xxx
        usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/scsi/qla4xxx/qla4xxx.ko.xz

```

请注意，这些天`'/lib'`是到`'/usr/lib/'`的符号链接。

在某些用户的情况下，硬盘可能来自以太网上的光纤通道。然后内核需要 FCOE 模块。在虚拟化环境中，HDD 可以是由虚拟机管理程序公开的虚拟磁盘。在这种情况下，要挂载用户的根文件系统，`virtIO`模块是必需的。这样，硬件和它们各自的模块的列表继续下去。

显然，内核无法将所有这些必需的模块文件(`.ko`)存储在自己的二进制文件(`vmlinuz`)中。因此，initramfs 的主要工作之一是存储挂载用户根文件系统所需的所有模块。这也是 initramfs 文件比内核文件大得多的原因之一。但是请记住，initramfs 不是模块的来源。模块总是由内核提供，并由 dracut 存档在 initramfs 中。内核(`vmlinuz`)是所有模块的来源，但是正如您所猜测的，如果内核将所有模块存储在它的`vmlinuz`二进制文件中，那么内核将会非常大。因此，随着一个`kernel`包，一个名为`kernel-modules`的新包被引入，这个包提供了所有出现在`/lib/modules/<kernel-version-arch>`位置的模块；dracut 只提取那些挂载用户根文件系统所必需的模块(`.ko`文件)。

```
# rpm -qa | grep -i kernel

        Kernel-headers-5.3.6-300.fc31.x86_64
        kernel-modules-extra-5.3.7-301.fc31.x86_64
        kernel-modules-5.3.7-301.fc31.x86_64
        kernel-core-5.3.16-300.fc31.x86_64
        kernel-core-5.3.7-301.fc31.x86_64
        kernel-5.3.16-300.fc31.x86_64
        abrt-addon-kerneloops-2.12.2-1.fc31.x86_64
        kernel-5.3.7-301.fc31.x86_64
        libreport-plugin-kerneloops-2.10.1-2.fc31.x86_64
        Kernel-modules-5.3.16-300.fc31.x86_64
# rpm -ql kernel-modules-5.3.7-301.fc31.x86_64 | wc -l
    1698

    # rpm -ql kernel-modules-5.3.7-301.fc31.x86_64
    <snip>
    /lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/atm/atmtcp.ko.xz
    /lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/atm/eni.ko.xz
    /lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/atm/firestream.ko.xz
    /lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/atm/he.ko.xz
    /lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/atm/nicstar.ko.xz
    /lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/atm/solos-pci.ko.xz
    /lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/atm/suni.ko.xz
    /lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/auxdisplay/cfag12864b.ko.xz
    /lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/auxdisplay/cfag12864bfb.ko.xz
    /lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/auxdisplay/charlcd.ko.xz
    /lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/auxdisplay/hd44780.ko.xz
    /lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/auxdisplay/ks0108.ko.xz
    /lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/bcma/bcma.ko.xz
    /lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/bluetooth/ath3k.ko.xz
    /lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/bluetooth/bcm203x.ko.xz
    /lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/bluetooth/bfusb.ko.xz
    /lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/bluetooth/bluecard_cs.ko.xz
    /lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/bluetooth/bpa10x.ko.xz
    .
    .
    </snip>

```

正如你所看到的,`kernel-5.3.7-301`附带的`kernel-modules`包提供了将近 1698 个模块。另外，`kernel-module`包将是`kernel`包的一个依赖项；因此，每当安装`kernel`时，`kernel-modules`就会被一个基于 Fedora 的操作系统拉过来安装。

## Dracut 和模块

我们现在将回顾 dracut 模块。

### dracut 如何选择模块？

为了理解 dracut 如何拉取 initramfs 中的模块，首先我们需要理解`depmod`命令。`depmod`分析位于`/lib/modules/<kernel-version-arch>`位置的所有内核模块，并列出所有模块及其依赖模块。它将这个列表保存在`modules.dep`文件中。(注意，在基于 Fedora 的系统上，最好将模块的位置称为`/usr/lib/modules/<kernel_version>/*`。)这里有个例子:

```
# vim /lib/modules/5.3.7-301.fc31.x86_64/modules.dep
<snip>
.
.
kernel/arch/x86/kernel/cpu/mce/mce-inject.ko.xz:
kernel/arch/x86/crypto/des3_ede-x86_64.ko.xz: kernel/crypto/des_generic.ko.xz
kernel/arch/x86/crypto/camellia-x86_64.ko.xz:
kernel/arch/x86/crypto/blowfish-x86_64.ko.xz: kernel/crypto/blowfish_common.ko.xz
kernel/arch/x86/crypto/twofish-x86_64.ko.xz: kernel/crypto/twofish_common.ko.xz
.
.
</snip>

```

在这段代码中，您可以看到名为`des3_ede`的模块需要模块`des_generic`才能正常工作。在另一个例子中，您可以看到`blowfish`模块有一个`blowfish_comman`模块作为依赖项。因此，dracut 读取`modules.dep`文件，并开始从`/lib/modules/5.3.7-301.fc31.x86_64/kernel/`位置提取 initramfs 映像中的内核模块。

```
# ls /lib/modules/5.3.7-301.fc31.x86_64/kernel/ -l
total 44
drwxr-xr-x.  3 root root 4096 Oct 24 04:43 arch
drwxr-xr-x.  4 root root 4096 Oct 24 04:43 crypto
drwxr-xr-x. 80 root root 4096 Oct 24 04:43 drivers
drwxr-xr-x. 43 root root 4096 Oct 24 04:43 fs
drwxr-xr-x.  4 root root 4096 Oct 24 04:43 kernel
drwxr-xr-x.  8 root root 4096 Oct 24 04:43 lib
drwxr-xr-x.  2 root root 4096 Oct 24 04:43 mm
drwxr-xr-x. 51 root root 4096 Oct 24 04:43 net
drwxr-xr-x.  3 root root 4096 Oct 24 04:43 security
drwxr-xr-x. 13 root root 4096 Oct 24 04:43 sound
drwxr-xr-x.  3 root root 4096 Oct 24 04:43 virt

```

内核提供了数以千计的模块，但是不需要在 initramfs 中添加每个模块。因此，在收集模块时，dracut 提取非常具体的模块。

```
# find /lib/modules/5.3.7-301.fc31.x86_64/ -name '*.ko.xz' | wc -l
3539

```

如果 dracut 提取每个模块，那么 initramfs 的大小将会很大。还有，为什么在不必要的时候拉每个模块？因此，dracut 只提取那些在该系统上安装用户根文件系统所必需的模块。

```
# lsinitrd | grep -i '.ko.xz'  | wc -l
221

```

正如您所看到的，initramfs 只有 221 个模块，而内核有将近 3，539 个模块。

如果我们在 initramfs 中包含 3，539 个模块，它会使 initramfs 变得很大，最终会降低引导性能，因为 initramfs 归档文件的加载和解压缩时间会很长。此外，我们需要理解 initramfs 的主要任务是挂载用户的根文件系统。因此，只包含那些挂载根文件系统所必需的模块是有意义的。例如，与蓝牙相关的模块没有必要添加到 initramfs 中，因为根文件系统永远不会来自蓝牙连接的设备。所以，尽管内核(`kernel-modules`)提供了几个`bluetooth`模块，但在 initramfs 中你不会找到任何与蓝牙相关的模块。

```
# find /lib/modules/5.3.7-301.fc31.x86_64/ -name 'bluetooth'
    /lib/modules/5.3.7-301.fc31.x86_64/kernel/net/bluetooth
    /lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/bluetooth

# lsinitrd | grep -i blue
    <no_output>

```

默认情况下，dracut 将只在 initramfs 中添加特定于主机的模块。这是通过检查当前系统状态和系统当前使用的模块来实现的。特定于主机是每个主流 Linux 发行版的默认方法。Fedora 和类似 Ubuntu 的系统也创建了一个通用的 initramfs 映像，称为 *rescue initramfs 映像*。rescue initramfs 包括用户可以在其上创建根文件系统的设备的所有可能的模块。其思想是通用 initramfs 应该适用于所有系统。因此，与特定于主机的 initramfs 相比，救援 initramfs 的大小总是更大。dracut 有一组逻辑来决定需要哪些模块来挂载根文件系统。这是 dracut 的手册页所说的，但是记住在基于 Fedora 的 Linux 中，`--hostonly`是缺省的。

> *"如果您想创建更轻、更小的 initramfs 映像，您可能需要指定- hostonly 或-H 选项。使用这个选项，产生的映像将只包含那些 dracut 模块、内核模块和文件系统，它们是引导这个特定机器所需要的。这样做的缺点是，如果不重新创建 initramfs 映像，就不能将磁盘放在另一个控制器或机器上，也不能切换到另一个根文件系统。- hostonly 选项仅供专家使用，您必须保留碎片。至少保留一个通用映像(和相应的内核)的副本，作为拯救您的系统的后备。”*

在第 [5](05.html) 章中，我们看到有许多二进制文件、模块和配置文件是由 dracut 选择并添加到 initramfs 中的，但是 dracut 如何从用户庞大的根文件系统中选择文件呢？

通过运行位置`/usr/lib/dracut/modules.d`中的脚本来选择文件。这是存放 dracut 所有脚本的地方。dracut 在生成 initramfs 的同时运行这些脚本，如下所示:

```
# ls /usr/lib/dracut/modules.d/ -l
total 288
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 00bash
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 00systemd
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 00warpclock
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 01fips
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 01systemd-initrd
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 02systemd-networkd
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 03modsign
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 03rescue
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 04watchdog
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 05busybox
drwxr-xr-x. 2 root root 4096 Oct 24 04:42 05nss-softokn
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 05rdma
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 10i18n
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 30convertfs
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 35network-legacy
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 35network-manager
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 40network
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 45ifcfg
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 45url-lib
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 50drm
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 50plymouth
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 80lvmmerge
drwxr-xr-x. 2 root root 4096 Oct 24 04:42 90bcache
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 90btrfs
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 90crypt
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 90dm
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 90dmraid
drwxr-xr-x. 2 root root 4096 Oct 24 04:44 90dmsquash-live
drwxr-xr-x. 2 root root 4096 Oct 24 04:44 90dmsquash-live-ntfs
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 90kernel-modules

drwxr-xr-x. 2 root root 4096 Oct 24 04:43 90kernel-modules-extra
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 90kernel-network-modules
drwxr-xr-x. 2 root root 4096 Oct 24 04:44 90livenet
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 90lvm
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 90mdraid
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 90multipath
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 90qemu
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 90qemu-net
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 90stratis
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 91crypt-gpg
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 91crypt-loop
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 95cifs
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 95debug
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 95fcoe
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 95fcoe-uefi
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 95fstab-sys
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 95iscsi
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 95lunmask
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 95nbd
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 95nfs
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 95resume
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 95rootfs-block
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 95ssh-client
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 95terminfo
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 95udev-rules
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 95virtfs
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 97biosdevname
drwxr-xr-x. 2 root root 4096 Jan  6 12:42 98dracut-systemd
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 98ecryptfs
drwxr-xr-x. 2 root root 4096 Oct 24 04:44 98ostree
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 98pollcdrom
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 98selinux
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 98syslog
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 98usrmount
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 99base
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 99earlykdump
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 99fs-lib
drwxr-xr-x. 2 root root 4096 Oct 24 04:44 99img-lib
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 99kdumpbase
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 99shutdown
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 99squash
drwxr-xr-x. 2 root root 4096 Oct 24 04:43 99uefi-lib

```

使用`#dracut --list-modules`可以查看相同的输出。

每当我们试图创建 initramfs 文件系统时，dracut 就会开始执行`/usr/lib/dracut/modules.d/`中每个目录下的`module-setup.sh`脚本文件。

```
# find /usr/lib/dracut/modules.d/ -name 'module-setup.sh'

/usr/lib/dracut/modules.d/95iscsi/module-setup.sh
/usr/lib/dracut/modules.d/98ecryptfs/module-setup.sh
/usr/lib/dracut/modules.d/30convertfs/module-setup.sh
/usr/lib/dracut/modules.d/90crypt/module-setup.sh
/usr/lib/dracut/modules.d/10i18n/module-setup.sh
/usr/lib/dracut/modules.d/99earlykdump/module-setup.sh
/usr/lib/dracut/modules.d/95nbd/module-setup.sh
.
.
.
/usr/lib/dracut/modules.d/04watchdog/module-setup.sh
/usr/lib/dracut/modules.d/90lvm/module-setup.sh
/usr/lib/dracut/modules.d/35network-legacy/module-setup.sh
/usr/lib/dracut/modules.d/01systemd-initrd/module-setup.sh
/usr/lib/dracut/modules.d/99squash/module-setup.sh
/usr/lib/dracut/modules.d/05busybox/module-setup.sh
/usr/lib/dracut/modules.d/50drm/module-setup.sh

```

这个`module-setup.sh`脚本将挑选特定于该主机的模块、二进制文件和配置文件。例如，将从`00bash`目录运行的第一个`module-setup.sh`脚本将在 initramfs 中包含`bash`二进制文件。

```
# vim /usr/lib/dracut/modules.d/00bash/module-setup.sh
  1 #!/usr/bin/bash
  2
  3 # called by dracut
  4 check() {
  5     require_binaries /bin/bash
  6 }
  7
  8 # called by dracut
  9 depends() {
 10     return 0
 11 }
 12
 13 # called by dracut
 14 install() {
 15     # If another shell is already installed, do not use bash
 16     [[ -x $initdir/bin/sh ]] && return
 17
 18     # Prefer bash as /bin/sh if it is available.
 19     inst /bin/bash && ln -sf bash "${initdir}/bin/sh"
 20 }
 21

```

如您所见，脚本文件正在 initramfs 中添加`/bin/bash`二进制文件。再来看另一个例子，这个`plymouth`的。

```
# vim /usr/lib/dracut/modules.d/50plymouth/module-setup.sh
  1 #!/usr/bin/bash
  2
  3 pkglib_dir() {
  4     local _dirs="/usr/lib/plymouth /usr/libexec/plymouth/"
  5     if type -P dpkg-architecture &>/dev/null; then
  6         _dirs+=" /usr/lib/$(dpkg-architecture -qDEB_HOST_MULTIARCH)/plymouth"
  7     fi
  8     for _dir in $_dirs; do
  9         if [ -x $_dir/plymouth-populate-initrd ]; then
 10             echo $_dir
 11             return
 12         fi
 13     done
 14 }
 15
 16 # called by dracut
 17 check() {
 18     [[ "$mount_needs" ]] && return 1
 19     [ -z $(pkglib_dir) ] && return 1
 20
 21     require_binaries plymouthd plymouth plymouth-set-default-theme

 22 }
 23
 24 # called by dracut
 25 depends() {
 26     echo drm
 27 }
 28
 29 # called by dracut
 30 install() {
 31     PKGLIBDIR=$(pkglib_dir)
 32     if grep -q nash ${PKGLIBDIR}/plymouth-populate-initrd \
 33         || [ ! -x ${PKGLIBDIR}/plymouth-populate-initrd ]; then
 34         . "$moddir"/plymouth-populate-initrd.sh
 35     else
 36         PLYMOUTH_POPULATE_SOURCE_FUNCTIONS="$dracutfunctions" \
 37             ${PKGLIBDIR}/plymouth-populate-initrd -t "$initdir"
 38     fi
 39
 40     inst_hook emergency 50 "$moddir"/plymouth-emergency.sh
 41
 42     inst_multiple readlink
 43
 44     if ! dracut_module_included "systemd"; then
 45         inst_hook pre-trigger 10 "$moddir"/plymouth-pretrigger.sh
 46         inst_hook pre-pivot 90 "$moddir"/plymouth-newroot.sh
 47     fi
 48 }

```

简单地 grepping `require_binaries`将显示 dracut 将添加到通用 initramfs 中的所有二进制文件。

```
# grep -ir "require_binaries" /usr/lib/dracut/modules.d/
/usr/lib/dracut/modules.d/90mdraid/module-setup.sh:    require_binaries mdadm expr || return 1
/usr/lib/dracut/modules.d/80lvmmerge/module-setup.sh:    require_binaries lvm dd swapoff || return 1
/usr/lib/dracut/modules.d/95cifs/module-setup.sh:    require_binaries mount.cifs || return 1
/usr/lib/dracut/modules.d/91crypt-gpg/module-setup.sh:    require_binaries gpg || return 1
/usr/lib/dracut/modules.d/91crypt-gpg/module-setup.sh:       require_binaries gpg-agent &&
/usr/lib/dracut/modules.d/91crypt-gpg/module-setup.sh:       require_binaries gpg-connect-agent &&
/usr/lib/dracut/modules.d/91crypt-gpg/module-setup.sh:       require_binaries /usr/libexec/scdaemon &&
/usr/lib/dracut/modules.d/45url-lib/module-setup.sh:    require_binaries curl || return 1
/usr/lib/dracut/modules.d/90stratis/module-setup.sh:    require_binaries stratisd-init thin_check thin_repair mkfs.xfs xfs_admin xfs_growfs || return 1
/usr/lib/dracut/modules.d/90multipath/module-setup.sh:    require_binaries multipath || return 1
/usr/lib/dracut/modules.d/95iscsi/module-setup.sh:    require_binaries iscsi-iname iscsiadm iscsid || return 1
/usr/lib/dracut/modules.d/95ssh-client/module-setup.sh:    require_binaries ssh scp  || return 1
/usr/lib/dracut/modules.d/35network-manager/module-setup.sh:    require_binaries sed grep || return 1
/usr/lib/dracut/modules.d/90dmsquash-live-ntfs/module-setup.sh:    require_binaries ntfs-3g || return 1
/usr/lib/dracut/modules.d/91crypt-loop/module-setup.sh:    require_binaries losetup || return 1
/usr/lib/dracut/modules.d/05busybox/module-setup.sh:    require_binaries busybox || return 1
/usr/lib/dracut/modules.d/99img-lib/module-setup.sh:    require_binaries tar gzip dd bash || return 1
/usr/lib/dracut/modules.d/90dm/module-setup.sh:    require_binaries dmsetup || return 1
/usr/lib/dracut/modules.d/03modsign/module-setup.sh:    require_binaries keyctl || return 1
/usr/lib/dracut/modules.d/97biosdevname/module-setup.sh:    require_binaries biosdevname || return 1
/usr/lib/dracut/modules.d/95nfs/module-setup.sh:    require_binaries rpc.statd mount.nfs mount.nfs4 umount || return 1
/usr/lib/dracut/modules.d/90dmraid/module-setup.sh:    require_binaries dmraid || return 1
/usr/lib/dracut/modules.d/95fcoe/module-setup.sh:    require_binaries dcbtool fipvlan lldpad ip readlink fcoemon fcoeadm || return 1
/usr/lib/dracut/modules.d/00warpclock/module-setup.sh:    require_binaries /sbin/hwclock || return 1
/usr/lib/dracut/modules.d/35network-legacy/module-setup.sh:    require_binaries ip dhclient sed awk grep || return 1
/usr/lib/dracut/modules.d/00bash/module-setup.sh:    require_binaries /bin/bash
/usr/lib/dracut/modules.d/95nbd/module-setup.sh:    require_binaries nbd-client || return 1
/usr/lib/dracut/modules.d/90btrfs/module-setup.sh:    require_binaries btrfs || return 1
/usr/lib/dracut/modules.d/00systemd/module-setup.sh:    if require_binaries $systemdutildir/systemd; then
/usr/lib/dracut/modules.d/10i18n/module-setup.sh:    require_binaries setfont loadkeys kbd_mode || return 1
/usr/lib/dracut/modules.d/90lvm/module-setup.sh:    require_binaries lvm || return 1
/usr/lib/dracut/modules.d/50plymouth/module-setup.sh:    require_binaries plymouthd plymouth plymouth-set-default-theme
/usr/lib/dracut/modules.d/95fcoe-uefi/module-setup.sh:    require_binaries dcbtool fipvlan lldpad ip readlink || return 1

```

同样，dracut 并不包括从`/usr/lib/dracut/modules.d`开始的每个模块。它只包括特定于主机的模块。在下一节中，您将学习如何在 initramfs 中添加或省略特定的模块。

### 自定义 initramfs

Dracut 也有自己的模块。内核模块和 dracut 模块是不同的。Dracut 收集特定于主机的二进制文件、相关库、配置文件和硬件设备模块，并将它们分组到名称 *dracut modules* 下。内核模块由硬件设备的`.ko`文件组成。您可以从`/usr/lib/dracut/modules.d/`或`dracut --list-modules`命令中看到 dracut 模块列表。

```
# dracut --list-modules | xargs -n6
bash systemd warpclock fips systemd-initrd systemd-networkd
modsign rescue watchdog busybox nss-softokn rdma
i18n convertfs network-legacy network-manager network ifcfg
url-lib drm plymouth lvmmerge bcache btrfs
crypt dm dmraid dmsquash-live dmsquash-live-ntfs kernel-modules
kernel-modules-extra kernel-network-modules livenet lvm mdraid multipath
qemu qemu-net stratis crypt-gpg crypt-loop cifs
debug fcoe fcoe-uefi fstab-sys iscsi lunmask
nbd nfs resume rootfs-block ssh-client terminfo
udev-rules virtfs biosdevname dracut-systemd ecryptfs ostree
pollcdrom selinux syslog usrmount base earlykdump
fs-lib img-lib kdumpbase shutdown squash uefi-lib

```

如果您想在 initramfs 中添加或省略特定的 dracut 模块(不是硬件设备模块)，那么`dracut.conf`在这里起着至关重要的作用。注意`dracut.conf`是 dracut 的配置文件，不是 initramfs 的；因此，它在 initramfs 中不可用。

```
# lsinitrd | grep -i 'dracut.conf'
    <no output>

```

生成 initramfs 时，dracut 将参考`dracut.conf file`。默认情况下，它将是一个空文件。

```
# cat /etc/dracut.conf
    # PUT YOUR CONFIG IN separate files
    # in /etc/dracut.conf.d named "<name>.conf"
    # SEE man dracut.conf(5) for options

```

`dracut.conf`提供了各种选项，可以用来添加或省略模块。

假设你想省略`plymouth-`相关文件(二进制、配置文件、模块等。)来自 initramfs 然后你可以在`dracut.conf`中增加一个`omit_dracutmodules+=plymouth`或者使用`dracut`二进制的`omit` ( `-o`)开关。这里有一个例子:

```
# lsinitrd | grep -i plymouth | wc -l
    118

```

在当前启动的内核中有将近 118 个`plymouth-`相关文件。我们现在尽量省略`plymouth-`相关文件。

```
# dracut -o plymouth /root/new.img

# lsinitrd /root/new.img | grep -i plymouth | wc -l
    4

```

正如您可以清楚地看到的，所有与 dracut 相关的模块都已经从我们新构建的 initramfs 中删除了。因此，与`plymouth`相关的二进制文件、配置文件、库和硬件设备模块(如果有的话)将不会被 initramfs 中的 dracut 捕获。在`dracut.conf`中增加`omit_dracutmodules+=plymouth`也可以达到同样的效果。

```
# cat /etc/dracut.conf | grep -v '#'
    omit_dracutmodules+=plymouth

# dracut /root/new.img --force

# lsinitrd /root/new.img | grep -i plymouth
-rw-r--r--   1 root     root          454 Jul 25  2019 usr/lib/systemd/system/systemd-ask-password-plymouth.path
-rw-r--r--   1 root     root          435 Jul 25  2019 usr/lib/systemd/system/systemd-ask-password-plymouth.service
drwxr-xr-x   2 root     root            0 Jul 25  2019 usr/lib/systemd/system/systemd-ask-password-plymouth.service.wants
lrwxrwxrwx   1 root     root           33 Jul 25  2019 usr/lib/systemd/system/systemd-ask-password-plymouth.service.wants/systemd-vconsole-setup.service -> ../systemd-vconsole-setup.service

```

以下来自`man`页面:

> *省略 dracut 模块*

> *有时候出于速度、大小或功能的原因，你并不希望包含 dracut 模块。为此，可以在 dracut.conf 或/etc/dracut.conf.d/myconf.conf 配置文件中指定 omit_dracutmodules 变量(请参见 dracut.conf(5))，或者在命令行中使用-o 或- omit 选项:# dracut-o " multipath LVM " no-multipath-LVM . img*

就像我们省略 dracut 模块一样，我们可以添加`/usr/lib/dracut/modules.d`中可用的任何模块。我们可以使用 dracut 的`--add`开关，也可以使用`add_dracutmodules+= in dracut.conf`。例如，您可以看到我们没有将 NFS 模块/文件/二进制文件添加到我们的`new.img` initramfs 中，因为我的测试系统没有从 NFS 引导，也没有在其中使用任何 NFS 挂载点。显然，dracut 会从`/usr/lib/dracut/modules.d`开始跳过`nfs`模块。所以，让我们把它添加到我们的 initramfs 中。

```
#lsinitrd | grep -i nfs
<no_output>

# cat /etc/dracut.conf
    # PUT YOUR CONFIG IN separate files
    # in /etc/dracut.conf.d named "<name>.conf"
    # SEE man dracut.conf(5) for options

    #omit_dracutmodules+=plymouth
    add_dracutmodules+=nfs

# dracut /root/new.img --force
# lsinitrd /root/new.img | grep -i nfs | wc -l
    33

```

我们也可以通过使用带有`--add`开关的`dracut`命令来实现这一点。

```
# lsinitrd /root/new.img | grep -i nfs
# dracut --add nfs /root/new.img --force
# lsinitrd /root/new.img | grep -i nfs
Arguments: --add 'nfs' --force
nfs
-rw-r--r--   1 root     root           15 Jul 25  2019 etc/modprobe.d/nfs.conf
drwxr-xr-x   2 root     root            0 Jul 25  2019 usr/lib64/libnfsidmap
-rwxr-xr-x   1 root     root        50416 Jul 25  2019 usr/lib64/libnfsidmap/nsswitch.so
-rwxr-xr-x   1 root     root        54584 Jul 25  2019 usr/lib64/libnfsidmap.so.1.0.0
lrwxrwxrwx   1 root     root           20 Jul 25  2019 usr/lib64/libnfsidmap.so.1 -> libnfsidmap.so.1.0.0
-rwxr-xr-x   1 root     root        42744 Jul 25  2019 usr/lib64/libnfsidmap/sss.so
-rwxr-xr-x   1 root     root        46088 Jul 25  2019 usr/lib64/libnfsidmap/static.so
-rwxr-xr-x   1 root     root        62600 Jul 25  2019 usr/lib64/libnfsidmap/umich_ldap.so
-rwxr-xr-x   1 root     root          849 Oct  8  2018 usr/lib/dracut/hooks/cleanup/99-nfsroot-cleanup.sh
-rwxr-xr-x   1 root     root         3337 Oct  8  2018 usr/lib/dracut/hooks/cmdline/90-parse-nfsroot.sh
-rwxr-xr-x   1 root     root          874 Oct  8  2018 usr/lib/dracut/hooks/pre-udev/99-nfs-start-rpc.sh
drwxr-xr-x   5 root     root            0 Jul 25  2019 usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/fs/nfs
drwxr-xr-x   2 root     root            0 Jul 25  2019 usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/fs/nfs/blocklayout
-rw-r--r--   1 root     root        16488 Jul 25  2019 usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/fs/nfs/blocklayout/blocklayoutdriver.ko.xz
drwxr-xr-x   2 root     root            0 Jul 25  2019 usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/fs/nfs_common
-rw-r--r--   1 root     root         2584 Jul 25  2019 usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/fs/nfs_common/grace.ko.xz
-rw-r--r--   1 root     root         3160 Jul 25  2019 usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/fs/nfs_common/nfs_acl.ko.xz
drwxr-xr-x   2 root     root            0 Jul 25  2019 usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/fs/nfs/filelayout
-rw-r--r--   1 root     root        11220 Jul 25  2019 usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/fs/nfs/filelayout/nfs_layout_nfsv41_files.ko.xz
drwxr-xr-x   2 root     root            0 Jul 25  2019 usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/fs/nfs/flexfilelayout
-rw-r--r--   1 root     root        20872 Jul 25  2019 usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/fs/nfs/flexfilelayout/nfs_layout_flexfiles.ko.xz
-rw-r--r--   1 root     root       109684 Jul 25  2019 usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/fs/nfs/nfs.ko.xz
-rw-r--r--   1 root     root        18028 Jul 25  2019 usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/fs/nfs/nfsv3.ko.xz
-rw-r--r--   1 root     root       182756 Jul 25  2019 usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/fs/nfs/nfsv4.ko.xz
-rwxr-xr-x   1 root     root         4648 Oct  8  2018 usr/lib/nfs-lib.sh
-rwsr-xr-x   1 root     root       187680 Jul 25  2019 usr/sbin/mount.nfs
lrwxrwxrwx   1 root     root            9 Jul 25  2019 usr/sbin/mount.nfs4 -> mount.nfs
-rwxr-xr-x   1 root     root          719 Oct  8  2018 usr/sbin/nfsroot
drwxr-xr-x   4 root     root            0 Jul 25  2019 var/lib/nfs
drwxr-xr-x   2 root     root            0 Jul 25  2019 var/lib/nfs/rpc_pipefs
drwxr-xr-x   3 root     root            0 Jul 25  2019 var/lib/nfs/statd
drwxr-xr-x   2 root     root            0 Jul 25  2019 var/lib/nfs/statd/sm

```

就像我们在 initramfs 中添加了额外的`nfs` dracut 模块一样，通过在`dracut.conf`中添加`dracutmodules+=`，我们可以在 initramfs 中只有`nfs`模块。这意味着生成的 initramfs 中只有`nfs`模块。来自`/usr/lib/dracut/modules.d/`的其余模块将被丢弃。

```
# cat /etc/dracut.conf
    #omit_dracutmodules+=plymouth
    #add_dracutmodules+=nfs
    dracutmodules+=nfs

# dracut /root/new.img —force

# lsinitrd /root/new.img

Image: /root/new.img: 20M
========================================================================
Early CPIO image
========================================================================
drwxr-xr-x  3 root     root       0 Jul 25  2019 .
-rw-r—r--   1 root     root       2 Jul 25  2019 early_cpio
drwxr-xr-x  3 root     root       0 Jul 25  2019 kernel
drwxr-xr-x  3 root     root       0 Jul 25  2019 kernel/x86
drwxr-xr-x  2 root     root       0 Jul 25  2019 kernel/x86/microcode
-rw-r—r--   1 root     root       100352 Jul 25  2019 kernel/x86/microcode/GenuineIntel.bin
========================================================================
Version:

Arguments: --force

dracut modules:
nss-softokn
network-manager
network
kernel-network-modules
nfs
=======================================================================

```

如您所见，只添加了`nfs`模块及其依赖模块，如`network` dracut 模块。另外，请注意 initramfs 两个版本之间的大小差异。

```
# ls -lh initramfs-5.3.16-300.fc31.x86_64.img
    -rw-------. 1 root root 28M Dec 23 06:37 initramfs-5.3.16-300.fc31.x86_64.img

# ls -lh /root/new.img
    -rw-------. 1 root root 20M Dec 24 11:05 /root/new.img

```

使用 dracut 的`-m`或`--modules`开关也可以达到同样的效果。

```
# dracut -m nfs /root/new.img --force

```

如果你只想添加硬件设备模块，那么请注意*硬件设备模块*是指`/lib/modules/<kernel-version>/drivers/<module-name>`的`kernel-modules`包提供的`*.ko`文件。那么 dracut 的`--add`开关或`add_dracutmodules+=`开关将不起作用，因为这两个开关添加的是 dracut 模块，而不是内核模块(`.ko`)文件。因此，要添加内核模块，我们需要使用 dracut 的`--add-drivers`开关或`dracut.conf`中的`drivers+=`或`add_drivers+=`。这里有一个例子:

```
# lsinitrd /root/new.img | grep -i ath3k

```

名为`ath3k`的蓝牙相关模块不在我们的 initramfs 中，但它是内核提供的模块之一。

```
#ls -lh /lib/modules/5.3.16-300.fc31.x86_64/kernel/drivers/bluetooth/ath3k.ko.xz

```

让我们添加它，如下所示:

```
# dracut --add-drivers ath3k /root/new.img --force

```

现在已经添加了，如下所示:

```
# lsinitrd /root/new.img | grep -i ath3k
Arguments: --add-drivers 'ath3k' --force
-rw-r--r-- 1 root  root 246804 Jul 25 03:54 usr/lib/firmware/ath3k-1.fw
-rw-r--r-- 1 root  root   5652 Jul 25 03:54 usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/bluetooth/ath3k.ko.xz

```

如您所见，initramfs 中添加了`ath3k.ko`模块。

### dracut 模块还是内核模块？

让我们看看何时添加 dracut 模块，何时添加内核模块。这里有一个场景:您的主机根文件系统在一个普通的 SCSI 设备上。因此，很明显，您的 initramfs 既没有一个`multipath.ko`内核模块，也没有一个类似于`multipath.conf`的配置文件。

1.  突然，您决定将您的根文件系统从普通的本地磁盘转移到 SAN(我绝不会建议在生产系统上进行这样的改变)，SAN 通过多路径设备连接。

2.  要获得多路径设备的整个环境，您需要在这里添加多路径 dracut 模块，以便将多路径的整个环境拉入 initramfs。

3.  几天后，您在同一系统上添加了新的 NIC 卡，NIC 卡供应商已经为其提供了驱动程序。驱动程序只不过是一个`.ko`文件(内核对象)。要在 initramfs 中添加这个模块，您必须选择添加`kernel module`选项。这将只添加网卡的驱动程序，而不是整个环境。

但是，如果您想在 initramfs 中添加某个特定的文件，它既不是内核模块，也不是 dracut 模块，该怎么办呢？dracut 提供了`dracut.conf`的`install_items+=`和`--include`变量，通过它们我们可以添加特定的文件。这些文件可以是从普通文本到二进制文件等任何文件。

```
#lsinitrd /root/new.img | grep -i date
    <no_output>

```

默认情况下，`date`二进制文件不存在于 initramfs 中。但是要添加二进制，我们可以使用一个`install_itsems+`开关。

```
# cat /etc/dracut.conf
    # PUT YOUR CONFIG IN separate files
    # in /etc/dracut.conf.d named "<name>.conf"
    # SEE man dracut.conf(5) for options

    #omit_dracutmodules+=plymouth
    #add_dracutmodules+=nfs
    #dracutmodules+=nfs
    install_items+=date

# dracut /root/new.img --force

# lsinitrd /root/new.img | grep -i date
-rwxr-xr-x   1 root     root       122456 Jul 25 02:36 usr/bin/date

```

正如你所看到的，已经添加了`date`二进制文件，但最重要的是它不仅添加了二进制文件；相反，它还添加了运行`date`命令所必需的库。同样可以通过`dracut`命令的`--install`开关实现。但是这有一个限制；它不能添加用户自定义的二进制文件。为此，我们需要使用 dracut 的`--include`开关。使用`--include`，您可以在 initramfs 中包含普通文件、目录甚至二进制文件。对于二进制文件，如果您的二进制文件需要一个支持库，那么您必须指定该库的名称及其绝对路径。

### “无法启动”问题 4 (initramfs)

**问题:**一个 Linux 生产系统经过四个月的定期维护后重新启动，它已经停止启动。它一直在屏幕上显示以下错误信息:

```
<snip>
.
dracut-initqueue[444]: warning: dracut-initqueue timeout - starting timeout scripts
dracut-initqueue[444]: warning: dracut-initqueue timeout - starting timeout scripts
dracut-initqueue[444]: warning: dracut-initqueue timeout - starting timeout scripts
dracut-initqueue[444]: warning: dracut-initqueue timeout - starting timeout scripts
.
</snip>

```

**解决方法:**以下是解决问题的步骤:

![../images/493794_1_En_6_Chapter/493794_1_En_6_Fig1_HTML.jpg](../images/493794_1_En_6_Chapter/493794_1_En_6_Fig1_HTML.jpg)

图 6-1

GRUB 闪屏

1.  错误信息开始时会说它无法到达交换设备，然后该过程超时。

    `[TIME] Timed out waiting for device /dev/mapper/fedora_localhost--live-swap`

    这是一条非常重要的信息，因为它告诉您这个系统的文件系统有问题。

2.  交换设备基于 HDD，并且交换文件系统已经在其上创建。现在交换设备本身丢失了。因此，要么底层磁盘本身不可访问，要么交换文件系统已损坏。了解了这一点，我们现在可以只关注存储方面。隔离问题很重要，因为“无法启动”问题有数千种可能导致系统停止启动的情况。

3.  我们要么以救援模式启动，要么使用相同发行版和版本的实时映像。这是一个 Fedora 31 系统，如图 [6-1](#Fig1) 所示，我会使用 GRUB 的 rescue 选项。

1.  一旦我们引导进入救援模式，我们将挂载用户的根文件系统并`chroot`到其中。为什么救援模式能够启动，而普通内核却不能在同一系统上启动？这是一个有效的问题，答案将在第 [10 章](10.html)中给出。

2.  因为我们能够在救援内核中挂载根文件系统，但是不能在普通内核中挂载根文件系统，这意味着 initramfs 映像有问题。也许是一些模块是必要的处理硬盘丢失。我们来验证一下这个理论。

3.  这是一个虚拟化系统，这意味着它有一个虚拟磁盘。这个从`/dev`目录就能看出来。

1.  为了处理虚拟磁盘，我们需要在 initramfs 中有一个`virtio_blk`模块。

```
#ls /dev/vd*
vda vda1 vda2

```

```
#lsinitrd /boot/new.img | grep -i virt
Arguments: --omit-drivers virtio_blk
-rw-r--r-- 1 root  root   14132 Jul 25 03:54
    usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/char/virtio_console.ko.xz
-rw-r--r-- 1 root  root   25028 Jul 25 03:54
    usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/net/virtio_net.ko.xz
-rw-r--r-- 1 root  root   7780 Jul 25 03:54
    usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/scsi/virtio_scsi.ko.xz
-rw-r--r-- 1 root  root   499 Feb 26  2018 usr/lib/sysctl.d/60-libvirtd.conf

```

如你所见，`virtio_blk`模块不见了。

1.  由于`virtio_blk`缺失，显然内核无法检测和访问`vda`磁盘，用户在这里拥有根文件系统和交换文件系统。

2.  要解决这个问题，我们需要在 initramfs 中添加缺失的`virtio_blk`模块。

![../images/493794_1_En_6_Chapter/493794_1_En_6_Fig2_HTML.jpg](../images/493794_1_En_6_Chapter/493794_1_En_6_Fig2_HTML.jpg)

图 6-2

Fedora 的登录屏幕

1.  我们将使用我们的`new.img` initramfs 进行引导。如何借助 GRUB 命令提示符手动引导系统已经在“无法引导”问题 1 中讨论过了。

2.  在添加了丢失的`virtio_blk`模块后,“无法启动”的问题已经被修复。在图 [6-2](#Fig2) 中可以看到成功启动的系统。

```
#dracut --add-drivers=virtio_blk /boot/new.img --force

# lsinitrd | grep -i virtio_blk
    -rw-r--r--   1 root     root         8356 Jul 25 03:54 usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/block/virtio_blk.ko.xz

```

### “无法启动”问题 5 (initramfs)

**问题:**图 [6-3](#Fig3) 显示了屏幕上可见的内容。

![../images/493794_1_En_6_Chapter/493794_1_En_6_Fig3_HTML.jpg](../images/493794_1_En_6_Chapter/493794_1_En_6_Fig3_HTML.jpg)

图 6-3

控制台消息

**解决方法:**以下是解决问题的步骤:

1.  这很容易理解和解决。

2.  错误消息是不言自明的；initramfs 文件本身缺失。

3.  要么是 initramfs 本身丢失，要么是因为`/boot/loader/entries/*`文件中有一个错误的条目。在这种情况下，initramfs 本身是缺失的。

4.  因此，我们需要以救援模式引导，并挂载用户的根文件系统。

5.  要么重新安装内核的`rpm`包，让包的`postscripts`部分重新生成丢失的 initramfs，并相应地更新 BLS 条目。

6.  或者您可以在`dracut`命令的帮助下重新生成 initramfs。

## 内核命令行选项

正如我们已经看到的，GRUB 接受内核命令行参数，并将它们传递给内核。内核有数百个命令行参数，任何人都几乎不可能涵盖每一个参数。因此，我们将只关注那些在引导操作系统时必需的参数。如果你对所有的内核命令行参数感兴趣，那么访问下面的页面: [`https://www.kernel.org/doc/html/v4.14/admin-guide/kernel-parameters.html`](https://www.kernel.org/doc/html/v4.14/admin-guide/kernel-parameters.html) 。

该页面上的参数列表是 4 系列内核的，但是大多数参数解释也适用于 5 系列内核。最好的选择是总是在`/usr/share/doc/`查看内核文档。

### 根

*   这是主内核的命令行参数之一。引导的最终目的是挂载用户的根文件系统。`root`内核命令行参数提供了用户根文件系统的名称，内核应该挂载这个文件系统。

*   从 initramfs 运行的 systemd 代表内核挂载用户的根文件系统。

*   如果用户的根文件系统不可用，或者如果内核不能挂载它，那么对于内核来说，这将被认为是一种紧急情况。

### 初始化

*   内核从 initramfs 运行 systemd，这成为第一个进程。它也被称为 PID-1，是所有进程的父进程。

*   但是如果您是一名开发人员，并且希望运行自己的二进制文件而不是 systemd，那么您可以使用`init`内核命令行参数。这里有一个例子:

    `init=/sbin/yogesh`

正如你在图 [6-4](#Fig4) 中看到的，这将运行`yogesh`二进制文件而不是 systemd。

![../images/493794_1_En_6_Chapter/493794_1_En_6_Fig4_HTML.jpg](../images/493794_1_En_6_Chapter/493794_1_En_6_Fig4_HTML.jpg)

图 6-4

内核命令行参数

但是`yogesh`在实际的根文件系统上不可用；因此，如图 [6-5](#Fig5) 所示，将无法启动。

![../images/493794_1_En_6_Chapter/493794_1_En_6_Fig5_HTML.jpg](../images/493794_1_En_6_Chapter/493794_1_En_6_Fig5_HTML.jpg)

图 6-5

应急外壳

![../images/493794_1_En_6_Chapter/493794_1_En_6_Fig6_HTML.jpg](../images/493794_1_En_6_Chapter/493794_1_En_6_Fig6_HTML.jpg)

图 6-6

rdsosreport.txt 文件

*   系统把我们扔进了紧急壳里。关于调试外壳的详细讨论，请参考第 [8](08.html) 章。

*   在`/run/initramfs/rdsosreport.txt`中提到了让我们进入紧急外壳的原因以及“无法启动”问题的原因。图 [6-6](#Fig6) 显示了`rdsosreport.txt`文件的一个片段。

*   这里要注意的有趣部分是，我们的`/sbin/yogesh`二进制文件将在`chroot`调用实际根文件系统时被调用。我们还没有讨论`chroot`；你可以在第 10 章中找到详细的讨论。

### Romania 罗马尼亚

*   这是对`root`内核命令行参数的支持参数。`ro`代表“只读”文件系统。用户的根文件系统将挂载在 initramfs 中，如果已经传递了`ro`内核命令行参数，它将以只读模式挂载。`ro`是每个主要 Linunx 发行版的默认选择。

### rhgb 和 quite

![../images/493794_1_En_6_Chapter/493794_1_En_6_Fig7_HTML.jpg](../images/493794_1_En_6_Chapter/493794_1_En_6_Fig7_HTML.jpg)

图 6-7

普利茅斯银幕

*   几乎每个 Linux 发行版都在引导时显示动画，以使引导过程更加激动人心，但是分析引导序列所需的重要控制台消息将隐藏在动画后面。要停止动画并在屏幕上查看详细的控制台消息，请移除`rhgb`和`quite`参数。

*   当`rhgb`和`quite`通过后，如图 [6-7](#Fig7) 所示，将显示`plymouth`动画。

![../images/493794_1_En_6_Chapter/493794_1_En_6_Fig8_HTML.jpg](../images/493794_1_En_6_Chapter/493794_1_En_6_Fig8_HTML.jpg)

图 6-8

控制台消息

*   当`rhgb`和`quite`被移除时，如图 [6-8](#Fig8) 所示，控制台消息将暴露给用户。

*   您也可以在动画(`plymouth`)屏幕上按 Escape 键，并可以看到控制台消息，但为此，您必须亲自出现在制作系统前，这是不太可能的。

### 防火墙

*   有时，为了解决“无法启动”的问题，您希望完全摆脱 SELinux。这时可以通过`selinux=0`内核命令行参数。这将完全禁用 SELinux。

这些是一些直接影响引导顺序的内核命令行参数。与内核命令行参数一样，GRUB 也可以接受 dracut 命令行参数，这些参数将被 initramfs 接受，或者更准确地说，被 initramfs 的 systemd 接受。

## dracut 命令行选项

用外行人的话来说，可以把以`rd.`开头的命令行参数看作是 initramfs 能够理解的 dracut 命令行参数。

### rd.auto (rd.auto=1)

*   根据手册页，这允许自动装配特殊设备，如 cryptoLUKS、dmraid、mdraid 或 lvm。默认为关闭。

*   考虑一个类似前面的场景，您的系统没有配置`mdraid (s/w raid)`，但是现在您最近已经实现了它，并且您希望在引导时激活该设备。换句话说，在创建 initramfs 时，机器的存储状态发生了变化。现在，在不重新生成新的 initramfs 的情况下，您希望在引导时激活新的配置(LVM 或 LUKS)。

### rd.hostonly=0

*   根据手册页，这将删除在构建 initramfs 映像的主机系统的配置中编译的所有内容。这有助于引导，如果任何磁盘布局已经改变，特别是结合`rd.auto`或指定布局的其他参数。

*   假设您的显卡提供商(如 Nvidia)为您提供了 initramfs 中的特殊驱动程序/模块，但是这些模块已经开始产生问题。由于图形驱动程序将在引导的早期阶段加载，您希望避免使用该模块；相反，你想使用一个通用的驱动程序(`vesa`)。在这种情况下，您可以将`rd.hostonly=0.`与该参数一起使用，initramfs 将加载通用驱动程序，并将避免特定于主机的 Nvidia 驱动程序。

### rd.fstab = 0

*   根据手册页，如果您不想使用在真正根目录的`/etc/fstab`中找到的根文件系统的特殊挂载选项，请使用这个参数。

### rd.skipfsck

![../images/493794_1_En_6_Chapter/493794_1_En_6_Fig9_HTML.jpg](../images/493794_1_En_6_Chapter/493794_1_En_6_Fig9_HTML.jpg)

图 6-9

控制台消息

*   根据手册页，这跳过了`rootfs`和`/usr`的`fsck`。如果您将`/usr`挂载为只读，并且`init`系统在重新挂载之前执行`fsck`，您可能想要使用这个选项来避免重复。

*   大多数 Linux 管理员对`fsck`以及它如何与`ro`内核命令行参数结合有误解。我们大多数人认为内核首先在`ro`模式下挂载实际的根文件系统，然后在其上执行`fsck`，这样`fsck`操作就不会破坏根文件系统数据。一旦`fsck`成功，它将参照`/etc/fstab`以读写模式重新挂载根文件系统。

    但是这种理解有一个基本的缺陷，那就是无论`ro`还是`rw`模式，`fsck`都不能在挂载的文件系统上执行。

*   以下 Fedora 系统的用户根文件系统位于 sda5 设备上，并且当前以只读模式挂载，因此`fsck`将失败，因为文件系统已挂载:

    ```
    # fsck.ext4 /dev/sda5
        e2fsck 1.45.3 (14-Jul-2019)
        /dev/sda5 is mounted.
        e2fsck: Cannot continue, aborting.

    ```

*   因此，证明了用户的根文件系统在`ro`模式下挂载的目的不是为了执行`fsck`。那么将`ro`命令行参数传递给内核的原因是什么呢？让我们通过引导序列来讨论它。

*   内核提取 initramfs 并将命令行参数如`root`和`ro`传递给 systemd，systemd 将从 initramfs 开始。

*   systemd 将找到实际的根文件系统。

*   一旦根文件系统(设备)被识别，systemd 将对其执行`fsck`。

*   如果`fsck`成功，那么 systemd 将把根文件系统作为`ro`(根据传递的内核命令行参数)装入 initramfs 本身。它将以只读方式安装在 initramfs 的`/sysroot`目录中。

*   如图 [6-9](#Fig9) 所示，内核已经提取了 initramfs 并从中启动 systemd(我已经去掉了`rhgb`和`quite`参数)。

Systemd 随后扫描连接的存储设备以查找根文件系统，并找到了一个。在挂载用户的根文件系统之前，它首先在其上执行了`fsck`，然后将它挂载到目录`sysroot`上的 initramfs 中。用户的根文件系统将以只读模式装载。

![../images/493794_1_En_6_Chapter/493794_1_En_6_Fig11_HTML.jpg](../images/493794_1_En_6_Chapter/493794_1_En_6_Fig11_HTML.jpg)

图 6-11

fsck 控制台消息

*   The reason for mounting it in read-only mode is simple to understand. Suppose the system fails to boot, but it has managed to mount the user’s root filesystem on `sysroot` and has provided us with a shell to fix the “can’t boot” issue. Users might accidentally corrupt or even delete the user’s root filesystem that is mounted under `sysroot`. So, to prevent the user’s root filesystem from such accidents, it is preferred to mount it in read-only mode.

    ```
    #switch_root:/# ls -ld /sysroot/
        dr-xr-xr-x 19 root 0 4096 Sep 10  2017 /sysroot/

    ```

    如何使用调试外壳以及 initramfs 如何提供它们将在第 [8](08.html) 章中讨论。

*   Figure [6-10](#Fig10) shows systemd continuing its booting sequence and leaving the initramfs environment.

    ![../images/493794_1_En_6_Chapter/493794_1_En_6_Fig10_HTML.jpg](../images/493794_1_En_6_Chapter/493794_1_En_6_Fig10_HTML.jpg)

    图 6-10

    控制台消息

    如图 [6-10](#Fig10) 所示，交换机根离开当前的 initramfs 环境，并将根从 initramfs 的临时根文件系统更改为`/sysroot`，其中安装了用户的根文件系统。(切换根过程将在第 [9 章](09.html)中讨论。)

*   在进入用户的根文件系统之后，用户的根文件系统的 systemd 读取`/etc/fstab`并在挂载点上采取适当的动作。例如，在这个 Fedora 系统上，有用户的根文件系统条目和`/boot`条目(引导在单独的分区上):

    ```
    #cat /etc/fstab

    /dev/mapper/fedora_localhost--live-root  /     ext4    defaults    1 1
    UUID=eea3d947-0618-4d8c-b083-87daf15b2679 /boot  ext4    defaults  1 2
    /dev/mapper/fedora_localhost--live-swap none   swap    defaults     0 0

    ```

*   如图 [6-11](#Fig11) 所示，在这个阶段，systemd 在挂载之前只会在引导设备上执行`fsck`。请注意，它不是在用户的根文件系统上执行`fsck`,因为它已经在 initramfs 环境中执行过了。此外，用户的根文件系统是当前挂载的，我们都知道在交换设备上做`fsck`是没有意义的。

*   如果有任何其他像`/usr`这样的额外挂载点，它也会在那个设备上执行`fsck`。

*   `fsck`取决于`/etc/fstab`的第五个参数。如果为 1，那么`fsck`将在引导时执行。此`fstab`设置不适用于用户的根文件系统，因为`fsck`将在 initramfs 内的用户根文件系统上强制执行，这是在读取`/etc/fstab`文件之前。

*   `rd.skipfsck`仅适用于 root 和用户的根文件系统。它不适用于任何其他文件系统，如`/boot`。

### rd.driver.blacklist、rd.driver.pre 和 rd.driver.post

这是来自`rd.driver.blacklist`的手册页:

```
rd.driver.blacklist=<drivername>[,<drivername>,...]

```

*不加载内核模块<驱动名>。可以多次指定该参数。*

`rd.driver.blacklist`是最重要的 dracut 命令行参数之一。顾名思义，它会将指定的模块列入黑名单。让我们尝试将对虚拟客户系统相当重要的`virtio`相关驱动程序列入黑名单。

```
# lsmod | grep -i virt
    virtio_balloon         24576  0
    virtio_net             57344  0
    virtio_console         40960  2
    virtio_blk             20480  3
    net_failover           20480  1 virtio_net

```

它在 initramfs 中也是可用的。

```
# lsinitrd | grep -i virtio
-rw-r--r-- 1 root  root  8356 Jul 25 03:54 usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/block/virtio_blk.ko.xz
-rw-r--r--   1 root     root        14132 Jul 25 03:54 usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/char/virtio_console.ko.xz
-rw-r--r--   1 root     root        25028 Jul 25 03:54 usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/net/virtio_net.ko.xz
-rw-r--r--   1 root     root         7780 Jul 25 03:54 usr/lib/modules/5.3.7-301.fc31.x86_64/kernel/drivers/scsi/virtio_scsi.ko.xz

```

请记住，要将模块列入黑名单，如图 [6-12](#Fig12) 所示，您需要确保所有其他相关模块也必须列入黑名单；否则，依赖模块将会拉出黑名单中的模块。例如，在这种情况下，`virtio_balloon`、`virtio_net`、`virtio_console`、`virtio_blk`和`virtio_pci`模块相互依赖。这意味着如果我们只将`virtio_blk`列入黑名单，其他依赖模块仍将加载`virtio_blk`模块。

![../images/493794_1_En_6_Chapter/493794_1_En_6_Fig12_HTML.jpg](../images/493794_1_En_6_Chapter/493794_1_En_6_Fig12_HTML.jpg)

图 6-12

内核命令行参数

与`virtio`相关的驱动程序很重要。虚拟磁盘和虚拟机管理程序网络就是通过这个驱动程序向来宾操作系统公开的。由于我们将它们列入黑名单，客户操作系统将停止启动。您可以在图 [6-13](#Fig13) 中看到“无法启动”控制台信息。

![../images/493794_1_En_6_Chapter/493794_1_En_6_Fig13_HTML.jpg](../images/493794_1_En_6_Chapter/493794_1_En_6_Fig13_HTML.jpg)

图 6-13

控制台消息

因此，将`virtio`模块列入黑名单是成功的，但是这种方法有两个问题。

*   `rd.driver.blacklist`只会阻塞从 initramfs 加载的模块。

*   我们每次都需要手动提供模块列表给`rd.driver.blacklist`。

如果模块不在 initramfs 中，那么您就不能真正阻止它加载。例如，`bluetooth`模块不是从 initramfs 加载的，而是内核在 initramfs 环境之后加载的。

```
# lsmod | grep -i bluetooth

    bluetooth             626688  37 btrtl,btintel,btbcm,bnep,btusb,rfcomm
    ecdh_generic           16384  1 bluetooth
    rfkill                 28672  5 bluetooth

# lsinitrd | grep -i bluetooth
    <no_output>

```

为了阻止内核加载`bluetooth`模块，我们需要告诉`modprobe`命令阻止模块加载。`modprobe`是一个代表内核加载或删除模块的二进制文件。

创建一个新的`blacklist.conf`文件。(可以选择任意名称，但必须有一个`.conf`后缀)并将该模块列入黑名单。

```
#cat /etc/modprobe.d/blacklist.conf
    blacklist bluetooth

```

但是重启后，你会发现`bluetooth`又被内核加载了。

```
#lsmod | grep -i bluetooth
    bluetooth             626688  37 btrtl,btintel,btbcm,bnep,btusb,rfcomm
    ecdh_generic           16384  1 bluetooth
    rfkill                 28672  5 bluetooth

```

这是因为`bluetooth`模块是多个其他模块的依赖，如`btrtl`、`btintel`、`btbcm`、`bnep`、`btusb`、`rfcomm`、`rfkill`。因此，`modprobe`已经加载了`bluetooth`作为其他模块的依赖项。在这种情况下，我们需要通过在`blacklist.conf`文件中添加`install bluetooth /bin/true`行来欺骗`modprobe`命令，如下所示:

```
# cat /etc/modprobe.d/blacklist.conf
    install bluetooth /bin/true

```

重启后，你会发现`bluetooth`模块已经被封锁。

```
# lsmod | grep -i bluetooth
    <no_output>

```

也可以用`/bin/false`代替`/bin/true`。

经过对`rd.driver.blacklist`的解释，`rd.driver.pre`和`rd.driver.post` dracut 命令行参数更容易理解，手册页也一目了然，如下所示:

```
rd.driver.pre=<drivername>[,<drivername>,...]

```

*强制加载内核模块<驱动名>。可以多次指定该参数。*

```
rd.driver.post=<drivername>[,<drivername>,...]

```

*在所有自动加载模块加载完毕后，强制加载内核模块<驱动名>。可以多次指定该参数。*

### 研发调试

这来自手册页:

> *为 dracut shell 设置-x。如果 systemd 在 initramfs 中是活动的，则所有输出都将记录到 systemd 日志中，您可以使用“journalctl -ab”来检查该日志。如果 systemd 未处于活动状态，日志将被写入 dmesg 和/run/initramfs/init.log。如果设置了“quiet ”,它还会记录到控制台。*

`rd.debug`将启用 systemd 的调试日志记录，这将在控制台和 systemd 日志中记录大量消息。`rd.debug`提供的详细信息将有助于识别与 systemd 相关的“无法启动”问题。

### rd.memdebug= [0-4]

这来自手册页:*打印不同点的内存使用信息，设置详细级别从 0 到 4。级别越高意味着调试输出越多:*

*   这将在屏幕上打印所有与内存子系统相关的信息，如`meminfo`和`slabinfo`文件内容。

```
       0 - no output
       1 - partial /proc/meminfo
       2 - /proc/meminfo
       3 - /proc/meminfo + /proc/slabinfo
       4 - /proc/meminfo + /proc/slabinfo + tracekomem

```

### lvm、raid 和多路径相关的 dracut 命令行参数

这来自手册页:

*   在这些参数中，您必须至少观察过 GRUB 传递的`rd.lvm.lv`选项。`rd.lvm.lv`的目的是在引导的早期阶段激活给定的 LVM 设备。默认情况下，主要的 Linux 发行商只激活根和交换(如果配置的话)LV 设备。在引导时只激活根文件系统可以加快引导过程。在将根从 initramfs 切换到实际的根文件系统之后，systemd 可以按照`/etc/fstab`中的列表激活剩余的卷组。

*   类似地，dracut 提供了多路径和 RAID 相关的命令行参数，这些参数也是不言自明的。

    ```
    MD RAID
           rd.md=0
    disable MD RAID detection

           rd.md.imsm=0
    disable MD RAID for imsm/isw raids, use DM RAID instead

           rd.md.ddf=0
    disable MD RAID for SNIA ddf raids, use DM RAID instead

           rd.md.conf=0
    ignore mdadm.conf included in initramfs

           rd.md.waitclean=1
    wait for any resync, recovery, or reshape activity to finish before continuing

           rd.md.uuid=<md raid uuid>
    only activate the raid sets with the given UUID. This parameter can be specified multiple times.

       DM RAID
           rd.dm=0
    disable DM RAID detection

           rd.dm.uuid=<dm raid uuid>
    only activate the raid sets with the given UUID. This parameter can be specified multiple times.

       MULTIPATH
           rd.multipath=0
    disable multipath detection

    ```

*   dracut 为网络、NFS、CIFS、iSCSI、FCoE 等提供了 *n* 个命令行参数。这也意味着这些是您可以放置根文件系统的各种选项，但是几乎不可能涵盖每一个 dracut 命令行参数。另外，我不赞成从所有这些复杂的结构中引导系统。我相信让用户的根文件系统总是在本地磁盘上，这样引导过程会很容易，主要是因为在“不能引导”的情况下，更简单的引导序列可以更快地修复。

```
       rd.lvm=0
disable LVM detection

       rd.lvm.vg=<volume group name>
only activate the volume groups with the given name. rd.lvm.vg can be specified multiple times on the kernel command line.

       rd.lvm.lv=<logical volume name>
only activate the logical volumes with the given name. rd.lvm.lv can be specified multiple times on the kernel command line.

       rd.lvm.conf=0
remove any /etc/lvm/lvm.conf, which may exist in the initramfs

```

### 研发突破和研发外壳

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

**参数**

 | 

**目的**

 |
| --- | --- |
| `cmdline` | 这个钩子收集内核命令行参数。 |
| `pre-udev` | 该钩子在启动`udev`处理器之前启动。 |
| `pre-trigger` | 在这个钩子中，你可以用`'udevadm' control --property=KEY=value`设置`udev`环境变量或者控制`udev`的进一步执行。 |
| `pre-mount` | 这个钩子在`/sysroot`挂载用户的根文件系统之前开始。 |
| `mount` | 钩子将在`/sysroot`挂载根文件系统后启动。 |
| `pre-pivot` | 钩子将在切换到实际的根文件系统之前执行。 |

*   `rd.shell`将在引导序列结束时为我们提供 shell，使用`rd.break`，我们可以打破引导序列。但是要理解这些参数，我们需要很好地理解 systemd。因此，在讨论`rd.break`和 dracut 钩子之前，我们将在下一章首先讨论 systemd。以下是`rd.break`接受的参数: