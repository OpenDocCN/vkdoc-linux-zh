# 四、通向成功的文件路径

在这一章中，我们来看看什么是文件系统，以及不同的操作系统是如何理解它们的。我们解释了单独的根文件系统和统一的根文件系统之间的区别，以及为什么预先知道这一点会省去您很多麻烦。

然后，我们继续查看您的 Pi 上显示的文件系统。我们探索标准布局，并解释什么去哪里，它实际上做什么。我们还将展示一些简单的命令，强调 Unix“一切都是文件”的系统设计方法的一些好处。

接下来，我们将向您展示如何在系统中移动，您将了解完全限定路径和相对路径。我们将向您展示如何创建目录和文件(然后复制、移动和删除它们),以及如何创建相当于快捷方式的 Linux。

然后，我们将以对 Linux 文件权限的探索来结束这一章，并向您展示 Linux 如何决定谁可以对您的文件做什么。我们还将涉及用户和组，并向您展示如何设置您自己的文件的所有权和文件权限。

## 什么是归档系统？

我们实际上已经计划从字典定义开始这一部分，然后是我们的解释。不幸的是，我们能找到的大多数定义基本上都是说“归档系统是一个归档系统”，我们将不得不跳过这一部分，直接进入我们自己的定义。然而，这确实表明，尽管文件系统说起来容易，但定义起来却困难得多。但是对我们来说，我们认为归档系统是:

一种对数据进行排序和分类的方式，使查找更容易。

这个定义涵盖了一切，从简单的收件箱(至少你知道文件在哪里，即使你不能马上把手放在上面)，到你在手机上查看联系人的方式(这是一个字母系统)，一直到一些更奇特的系统，如杜威十进制系统，用于在当地图书馆对非小说内容进行分类。

实际上，图书馆是文件系统的一个有趣的用例，因为大多数图书馆至少同时运行两个。一般来说，图书馆倾向于按照作者的姓(然后是名)来排列虚构的作品，而非虚构的部分是根据他们的杜威十进制数来排序的。通过同时使用两个系统，他们解决了一个基本问题。如果你有一个最喜欢的作者，并想找到更多他们的书，按作者的名字存储书籍是很棒的。不过，说到非小说类，你可能想浏览某个特定主题的精选书籍，但往往你心里没有特定的作者。如果这些书按作者名分类，你可能永远也找不到任何东西。

一些图书馆更进了一步，首先根据流派(比如科幻或奇幻)对虚构书籍进行分类，然后在这一类别中，他们根据作者姓名进行分类。这有一些非常好的好处。你仍然可以直接找到你最喜欢的作者，因为你知道他的类型，但是你也可以浏览相同类型的类似书籍。如果你正在寻找奇幻类的下一个最佳作品，你可以简单地站在那个区域快速浏览。

目前为止一切顺利。归档系统使寻找东西变得更容易，我们可以看到使用正确的归档系统对任务的重要性，否则你可能会比没有归档系统更好。但是他和电脑有什么关系呢？任何计算机的主要任务之一是处理信息，这意味着它必须能够轻松地存储和检索信息。旧的计算机系统确实使用字母系统，而且运行得非常好，但是一旦你开始建立一些文件，它就开始变得非常混乱，找到你想要的就成了一个挑战。这个问题可以通过创建一个目录(现在通常称为文件夹)来解决，在这个目录中可以放置相关的文件。这很有帮助，但同样的老问题开始在人们身上蔓延。是的，你可以有一个账户目录和一个纳税申报表目录，但是如果你是一家会计公司，你有很多账户和很多纳税申报表，那该怎么办呢？很快，您又回到了开始的地方，因为您要么拥有包含大量文件的少量目录，要么拥有仅包含一两个文件的大量目录。

文件系统结构的最后一个变化是允许目录包含其他目录，这一点至今仍为人们所熟悉。这将允许您以最合适的方式灵活地存储内容。像往常一样，有多种方法来排列给定的文件集，但总的来说，这个系统为我们提供了很好的服务，借助现代搜索技术，找到我们想要的东西比以往任何时候都更容易。

### 不止一个文件系统

这就是我们使用这种方法遇到的一点障碍。文件系统位于某种形式的存储之上。它可以是硬盘、u 盘、DVD 或任何数量的存储介质。每个设备实际上相互独立。这是有意义的，因为你可以从你的笔记本电脑上拿一个 u 盘，然后在你的台式机上使用它。很明显，u 盘上的文件系统和你的笔记本电脑之间没有联系，否则你的电脑就没有找到文件所需的所有信息。

每个文件系统都有一个“根目录”。这是设备上的第一个目录，它包含所有其他文件和目录。像树根一样，所有的文件和目录都从这个中心位置分支。不过这确实带来了一点问题。如果每个设备都有自己的文件系统和根目录，如何轻松地将这种结构呈现给最终用户？事实证明，它们是解决这个问题的两种方法。第一个是单独的根，第二个是统一的文件系统。

### 分离根

这种方法早在 MSDOS 时代就被微软采用了，并且一直沿用到今天。方法很简单。每个设备都有自己的根条目，然后用户可以使用该条目来定位感兴趣的设备，然后可以像平常一样简单地导航文件系统来找到该文件。在 Windows 下，每个根目录都有自己的字母。由于历史原因，Windows 上的系统盘被称为“C:”你会经常听到人们称之为“c 盘”。软驱被分配给 A:和 B:(有硬盘的个人电脑倾向于有两个软驱)由于很少有人有一个以上的硬盘，光驱倾向于被分配给 D:。

这个系统真的很容易使用，从来没有任何混乱的特定文件在哪里，因为你可以告诉简单地看看驱动器号。然而，这种设计有几个问题。首先，由于根设备被分配给字母，字母表中只有 26 个字母，因此您只能使用 26 个设备。即使在今天，这对家庭用户来说也几乎不是问题，但是当企业使用大型主机时，他们可能有数百台这样的设备。

第二个问题是用户必须知道他们的文件的物理位置。这实际上会增加复杂性，因为它将文件的位置与文件所在的物理设备联系在一起。如果系统中添加了一个更大的磁盘，并且文件被移动到新的位置，那么它们的根设备将会改变。任何依赖于文件位置的人(或软件)都需要更新，这可不好玩。

简而言之，尽管 Windows 使用的系统简单而有效，但在非常大的分布式系统上，它会成为一个管理难题。现在有很多方法可以解决这个问题，新的技术已经出现，将这种结构隐藏在表面之下，所以对于今天的 Windows 系统来说，这真的不是一个大问题。然而，当 Unix 占据主导地位时，这些技术还不可用，它们采用了另一种方法，即统一文件系统。

### 统一文件系统

基于 Unix 的 Linux 有统一的文件系统。这意味着，与拥有多个根设备的 Windows 不同，Linux 系统只有一个根设备，并且总是安装在“/”上，这是 Unix 中的根目录。如果只有一个根目录，那么 Linux 如何处理额外的设备，我们知道这些设备都包含它们自己的文件系统？

解决方案是获取新设备的根目录，然后将其附加到树中的现有目录。这就是所谓的挂载文件系统。这允许 Linux 拥有几乎无限数量的设备，因为它可以将它们连接到现有树中的任何位置。这意味着您可以装载一个设备，然后在第一个设备内的目录中装载另一个设备。从用户的角度来看，他们可以在所有这些不同的目录中移动，就好像他们都在一个大设备上一样。物理结构(即所有磁盘和磁盘上的原始数据)对最终用户完全隐藏。他们没有办法知道他们已经从一个设备穿越到另一个设备。

这解决了分离根方法突出的问题，因为无论底层机制是什么，统一文件系统都是一致的。事实上，您可以将网络文件共享甚至虚拟文件系统挂载到树中。当然，分离根方法的优点现在已经变成了统一方法的缺点。要看清事情的走向不再容易，这又会让事情变得更加混乱。像 Windows 一样，Linux 系统也随着时间的推移而发展，所以这些问题不像在其他情况下那样明显。然而，这些好处大多是在 GUI 中看到的，在使用命令行时往往不太明显。

### 苹果电脑必须与众不同

作为一个有趣的对比，Mac 上的 OSX 同时使用了这两种方法。在幕后，OSX 是一个基于 Unix 的系统，所以它有一个统一的文件系统。然而，除非你使用命令行(大多数 Mac 用户不会这样做)，否则你永远看不到这方面的证据。当你把 u 盘连接到 Mac 电脑上时，它会以与 Linux 类似的方式安装 u 盘，但它会以与 Windows 类似的方式向用户展示 u 盘，就好像它是自己的根设备一样。然而，Mac 并不分配驱动器号，它只是设置了一个唯一的名称。

### 把所有的东西放在一起

诚然，这是一个相当不错的理论，你可能想知道我们承诺向你展示的所有有趣的命令在哪里。你可能还想知道为什么我们会让你厌烦这些，以及这些信息什么时候(如果有的话)会有用。我们一开始就强调这一理论的原因是，当我们开始使用 Linux 时，许多事情使我们摆脱了使用其他操作系统的先入之见。大约 15 年前，当我们中的一个人第一次安装 Linux 时，他花了几个小时咒骂才弄明白“你需要一个根“/”设备是什么意思。这不仅仅是 Linux 的问题，对 BSD 操作系统家族及其处理磁盘的替代方式的涉猎导致我们擦除了错误的磁盘，因为我们考虑的是 Linux 而不是 BSD。

因此，希望这最后一节将把你从我们刚开始时所经历的痛苦中解救出来。你不需要记住所有的理论，但是如果你在阅读完这一部分后，意识到尽管有许多相似之处，但 Linux 不是 Windows 或 Mac，那么你将会领先于这个游戏。

## 所有东西都作为一个文件

现在，当我们讨论这个话题时，我们通常从谈论硬盘分区开始，因为大多数人都熟悉硬盘分区，并且在 Linux 呈现它们的方式和物理设备本身之间有一个很好的简单映射。由于 Pi 在技术上没有硬盘(它拉一些线使 SD 卡看起来和感觉上像一个硬盘)，这个简单的例子在 Pi 上实际上是不可用的。问题是，这个例子太好了，不能错过，所以我们要坚持经典。所以，事不宜迟，下面是描述我们的一个服务器上的磁盘设置的文件:

`/dev/sda`

`/dev/sda1`

`/dev/sda2`

`/dev/sdb`

`/dev/sdb1`

如您所见，这些文件都位于/dev 目录中，这是 Linux 保存所有设备文件的地方。关于这一点还有很多要说的，但是我们稍后会回到这一点，相信我们，如果我们最后讨论它，会更有意义。所以现在，让我们忽略目录，专注于我们的文件集合。您会注意到，在这个示例中，所有文件都以“sd”前缀开头。这是因为它们都是“SCSI 磁盘”,并且共享相同的驱动程序。出于兴趣，对于具有基于 IDE 的磁盘的机器，前缀是“硬盘”的“hd”。

现在我们知道我们有一些基于 SCSI 的磁盘(SATA 磁盘也显示为 SCSI ),但是从这些文件中我们还能知道什么呢？你会注意到我们有 sda 和 sdb。系统上的第一个 SCSI 磁盘分配给 sda，第二个分配给 sdb。得知第三个磁盘最终将被分配给 sdc 时，可能不会感到意外。由于我们在示例中没有看到 sdc，我们可以假设这个系统上只有两个磁盘。

现在我们真的有所进展了。我们可以看到我们的系统上有两个 SCSI 磁盘，现在我们只剩下一件事要讨论了——名称末尾的数字。在这种情况下，编号是指驱动器上的分区号。第一个分区是 1，第二个分区是 2。很好，很简单，我们确信没有真正的惊喜。有了这些附加信息，我们不仅可以指定哪个磁盘，还可以指定该磁盘上的哪个分区。

这当然引出了你为什么要关心的问题。肯定有更简单的方法来找出系统连接了哪些磁盘吧？你可能是对的，但我们并不是通过这个来发现什么连接到系统，而是看我们如何指定我们想要访问的特定设备。请记住，Linux 中的一切都是文件，所以即使是物理设备也是以这种方式表示的。当我们想访问一个硬盘或我们想访问一个特定的部分，我们这样做是访问相关的文件。

一些真实世界的例子在这里会很有用。当你想改变硬盘上的分区表时，你可以使用“fdisk”工具。fdisk 工具当然需要知道您想在哪个磁盘上工作。假设您想要对第二个磁盘进行分区，该命令如下所示:

`fdisk /dev/sdb`

因为我们正在对驱动器本身进行分区，所以我们希望引用整个设备，而/dev/sdb 允许我们这样做。但是，假设我们已经完成了分区，并且我们有一个大分区，我们想格式化它以供 Linux 使用。命令是 mkfs.ext4(在现代 Linux 发行版上),和以前一样，您需要告诉命令您想要格式化什么。在这种情况下，我们希望第一个分区位于第二个磁盘上，因此命令如下所示:

`mkfs.ext4 /dev/sdb1`

同样，这是有意义的，因为我们指的是特定设备上的特定分区。这里没有大的信仰跳跃，但我们现在可以和你分享一个小秘密。mkfs.ext4 命令并不真正关心您给它取了什么文件名。如果你忘记在末尾加上“1 ”,它会很高兴地格式化整个设备。这是一个“一切都是文件”的例子——因为一切都是文件，文件都以同样的方式访问，我们的工具只是简单地读写文件——它们既不知道也不关心它们写的是什么！

这个概念需要更多的努力才能真正理解。在幕后，Linux 为我们管理所有这些不同的设备，每一个都有自己特定的需求和驱动程序。为了让应用程序开发人员(更不用说用户)简单，Linux 隐藏了所有这些复杂性，而是将每个设备作为一个特定的文件呈现给我们。这让我们很好地回到了/dev 目录(我们告诉过你它会出现)。该目录中的文件很特殊，因为它们并不真正存在，至少不是存储在任何地方的物理文件。Linux 创建一个虚拟文件系统，然后用给定计算机上可用设备的文件填充它。因为我们的 Pi 没有任何 SATA 或 SCSI 磁盘，所以您不会在您的 Pi 上找到任何/dev/sd 文件。

## 文件系统布局

好了，现在让我们看看文件系统是如何在您的 Pi 上布局的。你会发现它的结构与你在任何 Linux 系统上发现的非常相似，所以这不仅会帮助你掌握你的 Pi，而且你也能浏览服务器。所以让我们陷入…

### /(根目录)

这是根目录(不要与根用户的主目录混淆)，代表文件层次结构的顶层。所有东西都在这个目录中或目录下，没有例外。正如我们在本章前面所讨论的，Linux 有一个统一的层次结构，这是一切的起点。

### /root

这是根用户的主目录，大部分时间都与根目录(即“/”)混淆。这可能会变得更加混乱，因为如果你在根目录中，有人让你“进入根目录”，他们实际上指的是哪一个？通常你可以很容易地从上下文中判断出来，但如果不能，不要害怕要求澄清；你会惊讶这个问题出现的频率。

### /等等

/etc 可以说是系统中最重要的目录之一。它不仅包含您的系统的所有配置文件，还包含您可能已经安装的应用程序(比如 Apache web 服务器)。许多不熟悉 Linux 的用户小心翼翼地备份他们的应用程序，但是经常忘记存储在/etc 中的配置。在一天结束的时候，应用程序通常可以很容易地被替换，但是从头开始进行正确的配置却是一件非常头疼的事情。这是一个你想要非常小心的目录。

### /proc

/proc 是一个虚拟文件系统，内核使用它来提供从用户空间工具的简单访问。您需要了解的关于系统状态或正在运行的进程的所有信息都可以在/proc 中找到。两个常见的例子是 CPU 配置(存储在/proc/cpuinfo 中)和内存使用(存储在/proc/meminfo 中)。这些信息大部分是只读的，这是有意义的，因为它只是一个虚拟的表示。然而，有些文件确实允许双向通信，你可以在机器运行时用它来调整内核和系统设置。

### /var

/var 通常是您可以找到由您的应用程序和系统本身创建的文件的地方。例如，大多数应用程序将它们的日志存储在/var/log/中，许多应用程序将锁文件存储在/var/run/中。apache web 服务器过去使用/var/www/来存储网站文件。事实上，我们在前一本书里强调了这个特性。在现代发行版中，这种文件不再位于/srv/目录中。

### /boot

传统上,/boot 目录实际上位于第一个硬盘上自己的小分区中。当时，大多数计算机都不能从一个大分区启动，所以看到这些分区分开是很常见的。在现代机器上，这不再是一个问题，所以这个目录通常直接包含在根目录中。顾名思义，它保存了引导系统所需的关键文件，包括引导装载程序和 Linux 内核本身。

### /bin 和/sbin

这些位置分别存储用户和管理程序。通常，普通用户的路径中只有/bin，所以他们实际上看不到/sbin 中的应用程序。有些应用程序用户可以访问，尽管它们通常只由管理员使用，但是用户需要知道它们在哪里。通常这不会造成问题，你也不需要去寻找任何东西。

### /开发

我们已经在“一切作为文件”一节中提到了这个目录。它包含当前系统上每个设备或子设备的文件，并为系统工具(当然还有用户)提供了一种方便地访问特定机器上的硬件的方法。除了我们前面提到的磁盘设备，还有显卡、声卡、虚拟终端等设备。

Note

您不会在/dev 目录中找到网卡，因为它们被视为特例。要查找网络接口的信息，您需要使用“sudo ifconfig -a”命令。这将列出 Linux 知道的所有网络设备。

### /home

传统上，所有用户主目录都存储在/home 下，这通常是它自己的分区、磁盘或网络共享。这个想法是将用户数据与系统数据和应用程序分开。大多数基于 Unix 的系统仍然遵循这一规则，但是有时您会将一些主目录放在其他地方，例如根用户的主目录。例如，Mac 将主目录存储在/Users 中，一些企业会根据不同用户的需求将他们放在不同的位置。虽然/home 通常只包含主目录，但并不要求主目录实际驻留在这里。

### /库

该目录包含各种应用程序所需的库文件。库允许将功能打包，然后由其他应用程序共享。数据库驱动程序就是一个很好的例子。为了让这些应用程序能够找到这些库，需要将它们安装在一个已知的位置，并使用一个已知的文件名。很少需要查看这个目录，但是如果您这样做，您应该小心，因为破坏这里的内容可能会影响系统的稳定性。

### /丢失+找到

我们提到这一点是为了完整性，但它本身并不是文件系统结构的一部分。相反，它是当文件系统失去对文件的跟踪时，文件被放置的地方。例如，如果磁盘损坏，您需要运行磁盘修复。有些文件可以恢复，但由于各种原因，可能无法确定该文件的来源。如果发生这种情况，Linux 将把那些迷失的灵魂放在这个目录中。我们从来没有理由查看这个目录，而且很可能你也永远不需要查看那里。最后，这个目录可以出现在任何挂载的文件系统的根目录中，而不仅仅是在/中，因为每个文件系统都必须独立地跟踪它丢失的灵魂。

### /媒体

这个目录对于 Linux 来说相对较新，添加它是为了明确区分挂载的外部设备(如/mnt 中的设备)和可移动介质(如 USB 棒、相机和媒体播放器)。在 Linux 下这些通常是自动处理的，所以通常你不会手动添加或删除这个目录中的任何东西。

### /mnt

作为 mount 的缩写，/mnt 目录通常是您挂载附加文件系统的地方。如果您想要附加一个网络共享或一个外部硬盘，您应该在/mnt 中创建一个目录并挂载到那里。软盘和 cdrom 在这里通常也分别称为/mnt/floppy 和/mnt/cdrom。然而，在最近几年，这个目录大多已经半途而废。

### /usr

这是机器上大部分软件的最终位置，因此它通常是服务器上最大的目录(至少如果不计算用户的主目录)。虽然知道软件在你机器上的位置是有用的，因为一切都是自动为你处理的，这里的一切都应该“正常工作”。

### /opt

这个目录是万能的。在一些系统中，它装满了应用程序，而在另一些系统中，它完全是空的。它通常用于第三方软件和应用程序。例如，默认情况下，Oracle 数据库服务器安装在/opt/中。您可能找不到使用这个目录的理由，但是如果您这样做的话要小心，因为在进行备份等操作时，很容易忘记/opt/中的内容。

### /srv

另一个相对较新的,/srv/目录是为服务文件的服务存储数据的指定位置。例如，这是 Apache web 服务器的新家。尽管这个目录似乎存在，但是一些应用程序仍然不使用它，或者出于习惯，或者仅仅是因为每个人都习惯于其他地方的内容。如果您正在寻找曾经在/var/中的东西，这可能是接下来要寻找的一个好地方。

### /sys

这个目录包含系统信息，像/proc 一样，它只存储在内存中，因为它是一个虚拟系统。它似乎没有得到太多的使用，我们自己甚至从来没有看过这个目录。然而，我们有可靠的消息称/sys 非常有用，我们应该非常乐意拥有它。

### /tmp

这个目录是计算机的暂存区，各种应用程序都在这个目录中创建文件。每当使用临时文件存储时(例如在处理过程中)，都会使用它。历史上，这个目录应该在重启时清空，但实际上很少这样做。随着更新的发行版转移到 systemd，/tmp 几乎肯定会在重启时消失。如果你在这里放任何东西都要非常小心，因为它不太可能在你重启 Pi 后存活。

包装它

这基本上总结了 Linux 文件系统的关键领域。毫无疑问，当你环顾你的系统时，你可能会遇到其他小角落和缝隙，但它们可能是其中的一个子集。请记住，虽然大多数系统都遵循这种结构，但大多数并不一定意味着全部，您可能会遇到一些不同之处或目录以其他方式使用的地方。

## 让它发挥作用

到目前为止，我们在这一章中已经讲了很多。我们已经研究了文件系统如何工作，以及 Unix 系统(尤其是 Linux)如何采用统一的方法。我们看着“所有的东西都是一个文件”,我们展示了这些特殊的文件和文件系统如何适应事物的大计划。我们总结了所有这些，概述了文件系统上的内容以及它们的作用。我们还没有做的是实际上自己使用文件系统。

到目前为止，我们已经相当“解放双手”，但这一切都将改变这一部分。我们将从向您展示如何创建目录和在文件系统中移动开始。一旦我们给了你创造的能力，我们就给你毁灭的能力，你就可以随意删除文件和目录(这并不总是一个好主意)。我们将用一个关于 Linux 文件权限以及如何读取和设置它们的快速概述来结束这一节。让我们开始吧！

### 我们在哪里？使用 pwd

我们首先要向您展示的是如何找出您在系统中的位置。找到方向的最简单方法是查看命令提示符。我们在上一章谈到了这一点。作为快速复习，下面是我们在主目录中时命令提示符的样子:

`[pi@raspberrypi ∼]$`

波浪号(又名曲线)是当前用户主目录的缩写。当我们第一次介绍这个特性时，我们已经强调了它，所以我们不会再重复了，但是让我们看看当我们在/usr/lib 目录中时它是什么样子的:

`[pi@raspberrypi lib]$`

这可能会带来一个问题。我们知道我们在/usr/lib 中，但是提示只显示了路径的最后一部分。这实际上是一个好主意，因为尽管你可以设置你的提示来显示整个路径(这在当时看来是一个好主意)，但是当路径占据了大部分屏幕时，你很快就会变得不耐烦。但这并没有解决问题。据我们所知，我们可能在/usr/lib 或/danger/lib 中。不用说，这可能会带来不愉快的后果。所以我们需要的是‘pwd’命令。我们在上一章中也提到了这个有用的工具，但是如果你错过了它，它又出现了:

`[pi@raspberrypi lib]$ pwd`

`/usr/lib/`

`[pi@raspberrypi lib]$`

这个工具对于告诉我们我们在哪里非常有用，但是它不能告诉我们在同一个位置有什么。就像被蒙上眼睛，告诉你站在厨房里；这是一个很好的开始，但你实际上仍然是盲人。您肯定想知道房间里有谁和什么，为此我们需要“ls”命令。这个命令有大量的选项，所以我们将只讨论最常见的选项，也就是我们每天都在使用的选项。实际上，你可以把它们记为食谱，因为你经常会一次又一次地传递相同的选项(或者至少我们是这样)。

首先，让我们回到我们的主目录:

`[pi@raspberrypi lib]$ cd ∼`

### 我们这里有什么？使用 ls

现在让我们看看这里有什么:

`[pi@raspberrypi ∼]$ ls`

`Desktop    python_games`

`[pi@raspberrypi ∼]$`

虽然我们不能轻易在书中表现出来，但是 Desktop 和 python_games 都是深蓝色的。这告诉我们它们是目录。目前我们在这个目录中没有任何文件，是吗？实际上我们有，但是它们被认为是隐藏文件。在 Linux 下，任何以句点(或句号)开头的文件都被认为是隐藏的。文件本身没有什么特别的，它们通常是各种应用程序创建的各种配置或临时文件。我们通常不希望这些文件弄乱我们的显示，所以 ls 和朋友不会显示它们。但是，我们可以强制 ls 向我们显示那些带有'-a '标志的文件，如下所示:

`[pi@raspberrypi ∼]$ ls`

`.  ..  .bash_history  .bash_logout  .bashrc  .profile  python_games`

`[pi@raspberrypi ∼]$`

### 使用 Touch 创建要使用的文件

现在，我们将不再使用-a 标志，而是创建我们自己的文件来使用。由于我们还没有介绍如何创建和编辑文本文件(我们将在第 7 章中告诉你如何做)，我们将向你介绍另一个叫做“触摸”的小工具。在 Linux 下，文件有两个时间戳——创建时间戳和最后修改时间戳。这些允许您查看文件的创建时间和最后更新时间。从管理的角度来看，这是很有用的，因为您可以看到哪些文件正在被使用，但是各种工具(如备份脚本)使用这个时间戳来判断自上次查看以来文件是否发生了更改。有时，能够在不改变文件内容的情况下更新时间戳是很有用的，这就是 touch 的用武之地。它会接触更新时间戳的文件，但是如果该文件当前不存在，那么 touch 会为您创建它。换句话说，这是一个创建空文件的好工具。因此，让我们从创建两个最初命名的文件开始:

`[pi@raspberrypi ∼]$ touch raspberry`

`[pi@raspberrypi ∼]$ touch pi`

`[pi@raspberrypi ∼]$ ls`

`Desktop pi python_games raspberry`

`[pi@raspberrypi ∼]$`

这就是全部了。正如你从后面的 ls 中看到的，我们现在有两个额外的文件。这次它们是灰色的，这告诉我们它们是普通文件。通过给条目着色，ls 让我们更容易看到我们在做什么。例如，任何可执行文件都将被标为绿色，但是我们将在本章的后面回到文件权限。

到目前为止，我们只有两个文件，但如果我们有十个或二十个，这里会变得有点拥挤。处理的方法当然是创建目录来存储我们的文件(可能还有其他目录),这是我们接下来要看的。

Note

目录和文件夹基本上是一回事。最初称为目录，微软开始称它们为文件夹，他们觉得这是一个更好的描述。虽然 Linux 过去使用目录这个术语，但是随着人们从 Windows 迁移过来，它已经变得更像一个桌面操作系统，文件夹这个术语也变得越来越普遍。

### 使用 Mkdir 来存储我们的文件

要创建目录，我们使用“mkdir”或“make directory”命令。不出所料，这将创建一个新目录。但是，如果存在同名文件或目录已经存在，您将得到一条错误消息。让我们创建一个名为“pifun”的目录来存储我们的文件:

`[pi@raspberrypi ∼]$ mkdir pifun`

`[pi@raspberrypi ∼]$ mkdir pifun`

`mkdir: cannot create directory ’pifun’: File exists`

`[pi@raspberrypi ∼]$`

如您所见，尝试创建目录两次将会导致错误。不要被“文件存在”分散注意力，这实际上可能指的是目录或文件。另一个快速 ls，我们会看到事情进展得非常顺利:

`[pi@raspberrypi ∼]$ ls`

`Desktop pi pifun python_games raspberry`

`[pi@raspberrypi ∼]$`

### 使用我们的新目录，使用 mv 命令

现在我们有了目录，让我们收拾一下我们制造的混乱。因为我们想要将文件移动到我们的新目录中(而不仅仅是创建它们的副本)，我们需要使用' mv '(或' move ')命令。这个命令比我们之前讨论过的命令稍微复杂一点，因为它需要两个参数而不是一个。这是有意义的，因为我们不仅需要告诉 mv 我们想要移动的内容，还需要告诉它我们想要将文件移动到哪里。与 Linux 下的大多数文件命令一样，第一个参数是源，第二个参数是目的。让我们现在移动这些文件:

`[pi@raspberrypi ∼]$ mv pi pifun`

`[pi@raspberrypi ∼]$ mv raspberry pifun`

`[pi@raspberrypi ∼]$ ls`

`Desktop pifun python_games`

`[pi@raspberrypi ∼]$`

目前为止一切顺利。现在我们要确保我们的文件完整无缺地到达。有两种方法可以做到这一点。我们可以用“cd”进入 pifun 目录，然后运行 ls 命令，或者，我们可以简单地给 ls 我们想要查看的目录的路径。我们已经使用了第一种方法，所以让我们试试第二种方法:

`[pi@raspberrypi ∼]$ ls pifun`

`pi raspberry`

`[pi@raspberrypi ∼]$`

### 克隆的时间到了，如何使用 cp 命令

诚然，这不是很令人兴奋，但作为一名新上任的管理员，您将花费大量时间移动文件和检查东西的位置。到目前为止，你已经学会了如何移动一个文件，但是如果你只是想复制一个文件呢？当备份或选择一些文件准备发送给朋友时，您实际上想要保留原始文件。为此，我们使用“cp”命令，你可能已经猜对了，它是“copy”的缩写。让我们进入新目录，复制我们的一个文件:

`[pi@raspberrypi ∼]$ cd pifun`

`[pi@raspberrypi pifun]$ cp pi pi2`

`[pi@raspberrypi pifun]$ ls`

`pi pi2 raspberry`

`[pi@raspberrypi pifun]$`

这很好，我们现在有了 pi 和 pi2，正如我们所预期的。让我们再次尝试同样的事情，只是这一次，我们将复制一个目录:

`[pi@raspberrypi pifun]$ mkdir moarpi`

`[pi@raspberrypi pifun]$ cp moarpi moarpi2`

`cp: ommiting directory ’moarpi’`

`[pi@raspberrypi pifun]$`

那一次并没有完全按照计划进行。我们的复制尝试失败的原因是因为默认情况下“cp”将只复制单个文件。它不会复制整个目录。这背后的原因是，当您复制一个目录时，您复制了其中的所有内容，包括它的所有文件和目录。这可能是大量的数据，可能会占用大量的空间以及大量的时间来完成。强迫我们明确我们的意图(这将很快成为你的第二天性)意味着当我们想要复制一个文件，但不小心选择了一个目录时，我们将在任何复制发生之前被阻止。

这很好，但是如果您真的想要复制那个目录呢？当我们第一次看到 copy 命令时，我们提到了备份等任务，说实话，您更可能想要备份一个目录，而不是一系列特定的文件。我们可以通过告诉“cp”我们想要递归复制来获得我们想要的行为。这将把目录和目录中的任何内容复制到目的地。我们通过使用'-r '标志来指定这一点，如下所示:

`[pi@raspberrypi pifun]$ cp -r moarpi moarpi2`

`[pi@raspberrypi pifun]$ ls`

`moarpi moarpi2 pi pi2 raspberry`

`[pi@raspberrypi pifun]$`

与 copy 命令不同，当您移动一个目录时，不需要指定您要递归地这样做，这是因为移动一个没有内容的目录没有太大的意义。

### 毁灭的力量，使用 rm 命令

到目前为止，我们已经向您展示了如何创建文件和目录，以及如何复制和移动它们。现在，我们将向您展示如何使用 remove 或“rm”命令销毁这些文件。不言而喻，rm 命令是你的武器库中最危险的命令之一。如果你不小心的话，它很容易摧毁整个服务器，我们知道有人曾经不小心这样做过。

为了改变一下思路，让我们看看如何删除一个空目录。我们可以使用“rmdir”命令，这是“删除目录”的缩写。这个命令的问题是，它只会删除完全空的目录。如果里面只有一个文件，这个命令就会失败。这使得它使用起来非常安全，但并不实用，因为通常当你删除一个目录时，你还想删除它的所有内容。让我们一石二鸟:

`[pi@raspberrypi pifun]$ rmdir moarpi2`

`[pi@raspberrypi pifun]$ rm moarpi`

`rm: cannot remove ’moarpi’: Is a directory`

`[pi@raspberrypi pifun]$`

我们能够用' rmdir '删除 moarpi2，因为目录本身是空的，但是当我们尝试使用 rm 命令时，它拒绝合作。这是因为 rm 命令是按照与 copy 命令相似的推理编写的。由于删除一个目录比简单地复制它要危险得多，这可能是一件好事。我们可以使用相同的'-r '标志来告诉 rm 递归删除:

`[pi@raspberrypi pifun]$ rm -r moarpi`

`[pi@raspberrypi pifun]$`

成功！现在，有时当您尝试这样做时，尤其是在有许多文件和子目录的大型目录上，您可能会遇到许多问题，导致 rm 放弃。例如，某些文件可能是写保护的。您可以通过使用'-f '标志来抑制这些错误。这意味着“力量”,类似于说“该死的鱼雷！全速前进！”。这听起来是个好主意，直到你停下来想想如果你运行这个命令会发生什么(你永远不应该这样做):

`[pi@raspberrypi pifun]$ rm -rf /`

如果您不小心运行了该命令，rm 将会删除您系统上的所有内容。如果你碰巧有一个 USB 硬盘，或者你已经安装了一些网络共享，那么你就真的有麻烦了，因为 rm 不会把自己限制在你的内部磁盘上——它会在整个树中爬行，删除它身后的所有东西。这就是为什么你应该在日常工作中使用普通用户帐号的原因之一。您自己的用户没有足够的权限删除任何对系统至关重要的内容，但即使这样，您仍然有可能损坏所有附加的介质。无论何时使用 rm 命令，您都需要非常非常小心，并且您最好反复检查它，因为 Linux 会假设您知道您在做什么，并且它不会要求确认！

“rm”命令还可以通过提供文件的路径来删除文件。对于此操作，您不需要使用'-r '标志，因此您可以简单地执行以下操作:

`[pi@raspberrypi pifun]$ rm pi2`

`[pi@raspberrypi pifun]$ ls`

`pi raspberry`

`[pi@raspberrypi pifun]$`

简而言之，这就是你如何移动和操作文件系统。

### 完全限定路径和相对路径

在 Linux 中，有两种方式来指定路径。您可以给出以正斜杠开头的完全限定路径，也可以给出以文件名、目录名、一个点或两个点开头的相对路径。虽然这听起来很奇怪，但它们都是为程序提供特定位置的方法。

当路径从固定的参考点(即根目录)开始时，它被认为是完全限定的。无论您在系统的哪个位置，完全限定路径总是指向同一个位置。这就像镇中心的旧钟楼，如果你以此为参考点给任何人指路，你和你的朋友就有了一个共同的支点，知道如何到达。

另一方面，相对路径取决于你当前的位置。您可以指定路径，使用`./`表示当前目录，或者使用`../`表示下一个目录。如果你有一个看起来像`../../test.txt`的路径，这将只能从几个特定的位置工作。它又好又短，而且容易打字。可以使用/home/pi/test.txt 访问同一个文件。与相对路径不同，这个文件可以在文件系统的任何地方使用，不会有任何问题。

那么什么时候应该使用其中的一种呢？答案是，您应该使用最方便或对任务最有意义的选项。有时使用完全限定路径会更快或更容易。其他时候，您被深深地埋在树中，编写完全限定的路径在最好的情况下是乏味的，在最坏的情况下是完全混乱的。

## 用户和组

我们在这里只涉及用户和组的基础知识，这样你就有足够的知识来理解接下来的文件权限部分。用户和组是 Linux 保护您的文件的关键，在我们进入下一节之前，您需要了解它们。

在 Unix 的思维方式中，每个人都有自己的用户名。用户名标识特定系统上的特定个人或实体(例如，web 服务器可能有自己的用户名)。到目前为止，我们大部分时间都是作为“pi”用户，但我们也看到了我们可以成为“root”用户。您的用户名是 Linux 用来识别您身份的密钥。

团体也是同样的简单明了。每个用户属于一个主要组，但实际上可能是系统中任意多个组的成员。在大学系统中，一个学生的用户名可能有自己的私有组(目前在 Red Hat 和 Debian 系统中的标准做法)，但是他们也可能属于一个学生组和一个研究组。他们也可能属于特定于他们部门的组。组对我们管理员来说很有用，因为我们可以将一组用户组合在一起，并将他们视为一个实体。这使得诸如文件权限之类的事情更容易管理。

当您在 Pi 上创建新用户时，您将自动创建一个同名的组。在某些系统中，用户会默认加入一个用户组——但是正如您将在下一节中看到的，这可能会导致意外地授予用户访问他们不应该拥有的文件的权限。因为根据定义，私有组是私有的，没有其他人会是成员，所以没有人可以访问你的文件，只是因为他们碰巧和你在同一个组。这就是为什么在现代系统中，您通常会看到文件的所有者和组恰好是相同的。

我们将在 BASH 的第 8 章中更深入地讨论用户和组。

## 文件权限

文件权限允许您表达您希望谁能够访问您的文件，以及他们可以对这些文件做什么。您可以设置三种不同的权限。第一个是是否有人可以阅读你的文件。第二个是他们是否可以写入你的文件，第三个是他们是否可以执行它(例如，像运行应用程序一样运行它)。

当然，仅仅能够在文件上设置这些权限并不是特别灵活。您可能希望只允许某一组人访问，而限制其他所有人。这就是用户和组发挥作用的地方。在 Linux 上，一个给定的用户实际上有三种角色。第一个是用户，指的是文件的所有者。第二个是 group，指的是拥有该文件的组。最后一个在技术上被称为世界，但它也经常被称为其他。

每个角色都有自己的权限组合，也就是说，您可以定义这三个角色中的任何一个是否可以读取、写入或执行您的文件。我们将向您展示如何做到这一点，但在此之前，我们需要向您展示如何查看哪些权限实际上是有效的，因此现在是向您展示如何对' ls '命令使用'-lh '选项的好时机。让我们现在试着运行它:

`[pi@raspberrypi pifun]$ ls -lh`

`-rw-r˗˗r˗˗ 1 pi pi 0 Oct 7 16:29 pi`

`-rw-r˗˗r˗˗ 1 pi pi 0 Oct 7 16:58 pi2`

`-rw-r˗˗r˗˗ 1 pi pi 0 Oct 7 16:29 raspberry`

`[pi@raspberrypi pifun]$`

'-lh '参数指定我们希望 ls 向我们显示一个文件列表(-l)，并且我们希望文件大小是人类可读的格式(-h)。如果没有人类可读标志，ls 将以字节为单位向我们显示所有大小，当您处理大文件时，这不是很容易阅读。在这个例子中这并不重要，因为我们的文件是空的。

就文件权限而言，我们真正感兴趣的有两件事。第一个描述了当前生效的权限，第二个显示了哪个用户和组拥有该文件。让我们来分析一下树莓文件:

`-rw-r˗˗r˗˗ 1 pi pi 0 Oct 7 16:29 raspberry`

文件权限部分是:

`-rw-r˗˗r˗˗`

列表中有 10 个可能插槽，现在，我们只对前 9 个感兴趣。如果缺少特定的权限(或者在第一个连字符是普通文件的情况下)，ls 将显示一个连字符。普通文件总是在第一个槽中有一个连字符。如果它引用一个目录，第一个槽将是一个“d ”,以强调它不是一个文件。如果文件是一个链接(或快捷方式),这个槽也可以是一个“l ”,我们将在下一节向您展示如何使用它们。不过现在我们可以忽略第一个槽，而专注于最后九个槽。

剩下的九个位置三个一组，这样我们就有三组。这些分别对应于用户、组和世界角色。每个组中的三个槽分别代表一个特定的权限，读、写和执行。在设置了权限的地方，您会看到一个字母，但是在没有设置权限的地方，您会看到连字符。如果我们的 raspberry 文件设置了所有权限，它将如下所示:

`-rwxrwxrwx`

让我们把它分开一点，这样更容易阅读:

`-   rwx   rwx  rwx`

因此，如果我们看一下前三个，我们可以看到所有者拥有读、写和执行权限。我们还可以看到，group 和 world 也拥有完全权限。为了解释这些权限的含义，我们确实需要知道谁真正拥有该文件。让我们看一下显示谁拥有该文件的那一行:

`pi pi`

嗯，那并不太痛苦。请记住，在现代的 Linux 机器上，用户有自己的私有组，这些组以用户的名字命名。这就是我们在这里看到的。第一个“pi”指的是所有者，当然也就是 pi 用户。默认情况下，创建文件时，组所有权设置为用户的默认组。在这种情况下，这将是我们的私有组，也称为“pi”。因此，如果我们查看原始文件条目:

`-rw-r˗˗r˗˗ 1 pi pi 0 Oct 7 16:29 raspberry`

我们可以理解为“pi 用户拥有读写权限。该组具有读取权限，而 world 也具有读取权限”。Linux 根据您的身份以特定的顺序应用这些权限。如果您的用户名与文件的所有者匹配，那么当您尝试访问该文件时，将应用用户权限。如果您不是所有者，但是您和文件在同一个组中，那么 Linux 会将组权限应用于您。如果您既不是所有者也不在同一个组中，Linux 将应用来自 world 角色的权限。在我们的例子中，world 和 group 的权限是相同的，所以如果您不是所有者，您将获得相同级别的访问权限。然而，只有所有者才能实际保存对文件的更改。然而，这个规则有一个例外——根用户。root 用户实际上不受文件权限的影响，可以更改系统上任何文件的权限和文件所有权，而不管所有者是谁。

“执行”权限允许您将文件作为程序执行。这是一项安全功能，因此您可以有效地阻止人们执行您不希望他们执行的命令。然而，你必须小心，因为如果一个用户可以读取你的文件，没有什么可以阻止他们复制到他们自己的文件，并使该文件可执行。对于目录，execute 位还有另一个用途。很明显，你不能执行一个目录，所以这个标志意味着用户(或者组或者世界)被允许浏览这个目录，也就是说，他们可以在这个目录上做一个“ls”。他们可能无法访问目录中的任何内容，但他们仍然可以拥有一个峰值，并查看其中隐藏的内容。如果您授予用户读取目录但不执行目录的权限，他们将能够读取目录中的文件，但不能浏览目录，他们必须事先知道文件名。

这就是事情的全部。有一个叫做“扩展文件属性”的特性，但是我们不打算在本书中讨论。它们比标准模型提供了更大的灵活性，但同样也更复杂。如果你习惯了 Windows 处理权限的方式，那么你会发现扩展文件属性更符合你的习惯。

### 设置文件权限

首先，我们将看看如何设置文件权限，为此，表 [4-1](#Tab1) 将非常有帮助。

表 4-1。

Setting Permissions

<colgroup><col> <col> <col></colgroup> 
| 作用 | 如何申请 | 申请什么 |
| --- | --- | --- |
| u -用户 g -组 o -其他/世界 a -所有 | + - add - - remove = -明确设置 | r -读 w -写 x -执行 |

我们将使用更改文件权限的 chmod 命令。您可以将权限指定为上述值的组合。这些可以以三种不同的方式结合起来。您可以添加权限、取消权限和显式设置权限。不同之处在于，前两者在完成他们的工作后，将保持所有其他权限不变。如果显式设置权限，任何未指定的权限都将被撤销。

让我们从删除每个人对 pi 文件的所有权限开始:

`[pi@raspberrypi pifun]$ chmod a=  pi`

`[pi@raspberrypi pifun]$ ls -lh`

`˗˗˗˗˗˗˗˗˗˗ 1 pi pi 0 Oct  8 03:52 pi`

`[pi@raspberrypi pifun]$`

我们可以看到所有文件权限都已从文件中删除，但是该命令实际上是如何工作的呢？井权限由三部分指定。您希望将变更应用于谁，您希望如何应用变更，以及您希望变更是什么。在这种情况下，我们将更改应用于“a ”,这基本上是“ugo”的简写，即它将更改应用于每个人。我们使用了等号，这意味着我们希望显式地设置权限，但实际上我们没有提供任何权限。如果一个权限不存在，它就被认为没有被设置，因此在我们的例子中，通过不提供任何权限，我们有效地撤销了所有的权限，而不管它们以前是什么。

鉴于这是我们的文件，我们想给自己完全的权限。诚然，执行位在这种情况下用处不大(但是当你开始编写脚本时，你会发现它的价值不可估量——见第 8 章),但是无论如何我们还是要把它给自己。我们可以用这个命令来实现:

`[pi@raspberrypi pifun]$ chmod u+rwx pi`

`[pi@raspberrypi pifun]$ ls -lh`

`-rwx˗˗˗˗˗˗ 1 pi pi 0 Oct  8 03:52 pi`

`[pi@raspberrypi pifun]$`

让我们把这个命令拆开。我们指定我们只想要更改用户的权限，我们想要添加它们(在这种情况下这并不重要，因为我们已经事先删除了所有权限，所以等号可以完成相同的工作)，我们想要读、写和执行权限。为了总结这个示例，让我们恢复对组和世界角色的读取权限:

`[pi@raspberrypi pifun]$ chmod go+r pi`

`[pi@raspberrypi pifun]$ ls -lh`

`-rwxr˗˗r˗˗ 1 pi pi 0 Oct  8 03:52 pi`

`[pi@raspberrypi pifun]$`

为了完整起见，让我们看一下最后一个例子。我们希望将权限应用于组和其他角色，我们希望将权限添加到已经存在的内容中，并且我们希望授予读取权限。这就是设置文件权限的大部分内容。还有一种替代样式，它使用数字而不是字母来指定您想要设置的权限。为了获得与我们已经获得的效果相同的效果(即没有任何效果),我们将使用:

`[pi@raspberrypi pifun]$ chmod 744 pi`

`[pi@raspberrypi pifun]$ ls -lh`

`-rwxr˗˗r˗˗ 1 pi pi 0 Oct  8 03:52 pi`

`[pi@raspberrypi pifun]$`

在这个系统中，每个权限都有自己的值。读取是 4，写入是 2，执行是 1。要设置权限，您需要将这些数字相加得到总数。例如，要设置所有权限，您需要将 4、2 和 1 相加得到 7。对于 read，你可以简单地做 4+0+0，当然得到 4。把它们放在一起，我们得到 744。该语法是大多数 Unix 系统上使用的原始语法。使用字母是一个相对较新的想法，但在一天结束时，他们都达到了相同的结果。新语法的主要好处是更清晰，更容易理解。就个人而言，我们倾向于使用数字风格，但那只是因为我们已经这样做了很长时间，它已经成为我们的第二天性。你可以随意使用你觉得最舒服的系统。

所以现在你可以像大师一样操作权限，但是我们仍然缺少第二部分，我们没有告诉你如何改变文件的所有权。这实际上比你想象的要少得多，远没有调整偶尔的文件权限那么常见。还有一个小问题。普通用户(除了 root 之外的任何人)实际上不能更改哪个用户拥有该文件。这样做的原因是，如果您不小心将该文件分配给了另一个用户，您就没有办法再取回该文件。当然，根用户可以改变系统中任何文件的所有权。

我们可以用 sudo 来模拟“根性”。如前所述，这个小命令充当某种过滤器。无论谁执行它，它总是以 root 用户身份运行，并代表他们以 root 用户身份执行命令。为了防止任何恶作剧，sudo 将根据批准的列表检查用户和他们试图运行的命令。如果您在这个列表中(pi 用户也是),您就可以执行各种各样的魔法，而无需在技术上成为 root 用户。

要使用 sudo，我们所要做的就是在命令前面加上“sudo”命令。差不多就是这样。当你第一次运行 sudo 时，它会要求你输入密码。这是您的特定用户的密码，而不是根用户的密码。目的是您可以证明您是 pi 用户，然后 sudo 将检查 pi 用户被允许做什么。这意味着，如果你的电脑上有很多用户，你想让他们执行一些更强大的命令，但不想给他们 root 访问权限，你可以设置 sudo，让他们执行特定的命令，而不必交出大厦的钥匙。

让我们首先尝试使用“chown”(或更改所有权)命令将文件交给 root 用户:

`[pi@raspberrypi pifun]$ chown root pi`

`chown: changing ownership of ’pi’: Operation not permitted`

`[pi@raspberrypi pifun]$`

不允许的操作是 Linux 告诉我们滚蛋的方式。要实现这一点，我们需要 root 权限，所以让 sudo 为我们工作，并再次运行命令:

`[pi@raspberrypi pifun]$ sudo chown root pi`

`[pi@raspberrypi pifun]$ ls -lh`

`-rwxr˗˗r˗˗ 1 root pi 0 Oct  8 03:52 pi`

`[pi@raspberrypi pifun]$`

成功！我们能够将所有者更改为根用户。这将适用于任何有效用户和任何您希望更改的文件或目录。还有另一个名为“chgrp”的命令，它允许您更改哪个组拥有某个特定文件，您对此不会感到惊讶。现在这个命令也有一点问题。虽然普通用户可以更改群组，但他们只能更改他们所属的群组。如果您的用户只是其私有组的成员，那么您也不能用这个命令做太多事情。

又一次是鲁特和须藤来营救了。由于 root 可以为所欲为，因此可以相应地更改组。碰巧的是，它看起来非常像我们的最后一个命令:

`[pi@raspberrypi pifun]$ sudo chgrp root pi`

`[pi@raspberrypi pifun]$ ls -lh`

`-rwxr˗˗r˗˗ 1 root root 0 Oct  8 03:52 pi`

`[pi@raspberrypi pifun]$`

就这样——文件现在属于根组和根用户。当您必须更改文件所有权时，更常见的情况是需要更改拥有该文件的用户和组。只更改组的情况相对较少(我们不记得上次使用 chgrp 命令是什么时候了)。chown 命令提供了一个快捷方式，允许我们同时设置新的所有者和新的组。现在让我们使用这个快捷方式将文件的所有权返回给我们的 pi 用户。当然，我们仍然需要使用 sudo:

`[pi@raspberrypi pifun]$ sudo chown pi:pi pi`

`[pi@raspberrypi pifun]$ ls -lh`

`-rwxr˗˗r˗˗ 1 pi pi 0 Oct  8 03:52 pi`

`[pi@raspberrypi pifun]$`

使用快捷方式，您只需指定用冒号分隔的用户和组。关于这些命令，我们需要注意的最后一点是，它们只对您提供的文件进行操作。如果您提供一个目录而不是一个文件，它将设置目录的权限，但这些更改不会过滤到所有文件。有时这是您想要的，但是更多的时候您想要传播更改。与使用-r 的 cp 和 rm 命令不同，这两个命令使用-R，(也就是说，它们使用大写字母而不是小写字母)。使用时要小心，因为通常文件权限是精确设置的，如果你在新版本中轻易地删除了它们，就没有办法挽回损失。像往常一样，在你按下回车键之前要仔细检查你输入的内容。

## 快捷方式和链接

Linux 允许使用 ln 命令(link 的缩写)创建链接(或快捷方式)。有两种链接，一种叫做硬链接，一种叫做软链接。软链接更像是使用“创建快捷方式”功能后在 Windows 系统上看到的内容。它创建一个文件，这个文件只是一个指向文件在磁盘上的真实位置的指针。然而，硬链接更有趣。当你使用一个硬链接时，你实际上为同一个文件创建了两个名字。这听起来像是语义，大多数现代应用程序都能够遵循软链接，很少需要使用硬链接。硬链接也仅限于单个文件系统，并且该文件系统必须支持它们(大多数 Linux 文件系统都支持)。硬链接的主要好处是硬链接与原始文件完全无法区分，它们只是指向同一位置的两个名称。为了避免混淆并允许链接跨文件系统工作，您应该使用软链接。

让我们做一个简单的例子来展示这一点:

`[pi@raspberrypi pifun]$ ln pi pi1`

`[pi@raspberrypi pifun]$ ln -s pi pi2`

`[pi@raspberrypi pifun]$ ls -lh`

`-rw-rw-r˗˗ 2 miggyx miggyx    0 Oct  8 08:14 pi`

`-rw-rw-r˗˗ 2 miggyx miggyx    0 Oct  8 08:14 pi1`

`lrwxrwxrwx 1 miggyx miggyx    3 Oct  8 08:33 pi2 -> pi`

`[pi@raspberrypi pifun]$`

让我们看看这里有什么。pi 和 pi1 在各方面都是相同的，但这并不奇怪，因为除了名字之外，它们是同一个文件。您会注意到，pi 和 pi1 的文件权限块后面的数字现在显示为“2”。这告诉我们，当前有两个文件名指向这个特定的文件。也没什么好惊讶的，因为是我们创建了第二个条目。更有趣的是我们用软链接创建的 pi2。首先，我们可以看到文件权限已经全部设置完毕。这不是问题，因为当 Linux 通过软链接访问真实文件时，真实文件的权限将用于定义谁可以访问该文件。软链接实际上只是指出了位置。我们还可以看到文件名本身有点不同。它显示了我们最初给软链接的文件名，但也显示了软链接指向的文件。在这种情况下，文件碰巧在同一个目录中，但它也可能在系统中的任何地方。

这就是创建链接的全部内容。当您想让一个目录或文件看起来位于新位置时，它们会很有用。例如，一个程序可能会写入一个数据目录，而您希望将该目录移动到一个更大的磁盘上。没问题，你可以把它移到更大的磁盘上，然后创建一个同名的软链接。应用程序可能甚至不会注意到。这真的可以帮你省去很多麻烦，尤其是当时间非常宝贵的时候(老实说，什么时候不是呢？).

## 摘要

这一章已经给了你关于文件系统的内幕消息。我们已经查看了历史，并展示了为什么我们的文件系统看起来是这样的。然后，我们讨论了它们是如何结合在一起的，以及 Linux 文件系统本身是如何构造的。然后我们继续很好地利用它，让你快速掌握创建、复制、移动和删除文件的所有基础知识。

然后，我们研究了文件权限以及它们是如何实施的，以及我们如何设置它们来满足我们的需求。我们还研究了更传统的设置文件权限的方法，如果你曾经遇到过的话。然后，我们向您展示了 Linux 如何应用这些权限，以及如何更改拥有特定文件的用户和组。然后，我们讨论了如何创建链接，以及软链接和硬链接之间的区别，从而圆满地完成了所有内容。

在下一章中，我们将向您展示您可以在 Pi 上找到的所有最常见的命令。这些命令将成为你经常使用的工具箱的一部分。事实上，我们在日常工作中使用所有这些命令。所以，向前看[第五章](05.html)！